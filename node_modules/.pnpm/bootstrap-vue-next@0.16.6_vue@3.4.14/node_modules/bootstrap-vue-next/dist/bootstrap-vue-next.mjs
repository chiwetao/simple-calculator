var Ln = Object.defineProperty;
var zn = (e, t, o) => t in e ? Ln(e, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[t] = o;
var qe = (e, t, o) => (zn(e, typeof t != "symbol" ? t + "" : t, o), o);
import { computed as w, toValue as Le, toRef as P, unref as p, ref as W, shallowRef as kt, watch as ce, getCurrentScope as Qo, onScopeDispose as el, shallowReadonly as Pt, isRef as tl, readonly as Ue, customRef as Hn, onMounted as at, nextTick as Fe, getCurrentInstance as Tt, reactive as yo, defineComponent as q, watchEffect as Yt, onBeforeUnmount as Ga, openBlock as g, createElementBlock as I, Fragment as me, createElementVNode as le, renderSlot as O, createBlock as H, Teleport as _t, mergeProps as ee, normalizeClass as G, normalizeStyle as Me, createTextVNode as de, toDisplayString as ae, createCommentVNode as se, createApp as Rn, h as Re, inject as ze, onActivated as xn, Transition as Mn, withCtx as R, useAttrs as Zt, resolveDynamicComponent as fe, provide as dt, createVNode as ye, useSlots as je, normalizeProps as we, guardReactiveProps as Ae, withDirectives as wt, vShow as ba, renderList as Ee, TransitionGroup as al, withModifiers as ht, vModelCheckbox as Dn, vModelRadio as jn, vModelSelect as qn, createSlots as Ua, onUnmounted as Wn, withKeys as ta } from "vue";
const Jt = (e) => w(() => {
  const t = Le(e);
  return t ? `justify-content-${t}` : "";
}), Gn = (e) => typeof e == "boolean" || e === "true" || e === "false", d = (e) => w(() => {
  const t = Le(e);
  return Gn(t) ? !!t : t;
}), ya = (e, t) => {
  const o = d(e), a = P(t);
  return w(
    () => o.value === !0 ? "true" : typeof o.value == "string" ? o.value : a.value === !1 ? "true" : o.value === !1 ? "false" : void 0
  );
}, ol = /_/g, ll = /([a-z])([A-Z])/g, Un = /^[0-9]*\.?[0-9]+$/, Xn = /(\s|^)(\w)/g, Kn = /(\s|^)(\w)/, ra = /\s+/, Yn = /^#/, Zn = /^#[A-Za-z]+[\w\-:.]*$/, Jn = /[-/\\^$*+?.()|[\]{}]/g, Qn = /[\s\uFEFF\xA0]+/g, Pa = (e) => w(() => {
  const t = Le(e);
  return Un.test(String(t)) ? `${Number(t)}px` : t;
});
class vt {
  constructor(t, o = {}) {
    qe(this, "cancelable", !0);
    qe(this, "componentId", null);
    qe(this, "_defaultPrevented", !1);
    qe(this, "eventType", "");
    qe(this, "nativeEvent", null);
    qe(this, "_preventDefault");
    qe(this, "relatedTarget", null);
    qe(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, vt.Defaults, o, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class Vt extends vt {
  constructor(o, a = {}) {
    super(o, a);
    qe(this, "trigger", null);
    Object.assign(this, vt.Defaults, a, { eventType: o });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class nl extends vt {
  constructor(o, a) {
    super(o, a);
    qe(this, "from");
    qe(this, "to");
    qe(this, "direction");
    Object.assign(this, vt.Defaults, a, { eventType: o });
    const { from: l, direction: n, to: r } = a;
    this.from = l, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const es = (e, t = {}) => {
  const o = (l = []) => {
    const { activeElement: n } = document;
    return n && !l.some((r) => r === n) ? n : null;
  }, a = (l) => l === o();
  try {
    e.focus(t);
  } catch (l) {
    console.error(l);
  }
  return a(e);
}, He = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, ts = (e) => {
  if (e.getAttribute("display") === "none")
    return !1;
  const t = e.getBoundingClientRect();
  return !!(t && t.height > 0 && t.width > 0);
}, Na = (e) => {
  const t = window.getComputedStyle(e), o = t.transitionDelay.split(",")[0] || "", a = t.transitionDuration.split(",")[0] || "", l = Number(o.slice(0, -1)) * 1e3, n = Number(a.slice(0, -1)) * 1e3;
  return l + n;
}, Xa = typeof window < "u" && typeof document < "u" && typeof navigator < "u", as = (e) => (() => {
  let o = !1;
  if (Xa)
    try {
      const a = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          o = !0;
        }
      };
      WINDOW.addEventListener("test", a, a), WINDOW.removeEventListener("test", a, a);
    } catch {
      o = !1;
    }
  return o;
})() ? typeof e == "object" ? e : { capture: !!e || !1 } : typeof e == "object" ? e.capture : e, os = (e, t, o, a) => {
  e && e.addEventListener && e.addEventListener(t, o, as(a));
}, ls = (e, t, o, a) => {
  e && e.removeEventListener && e.removeEventListener(t, o, a);
}, ho = (e, t) => {
  (e ? os : ls)(...t);
}, ns = ["TD", "TH", "TR"], ss = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), aa = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || ns.indexOf(t.tagName) !== -1)
    return !1;
  if (t.closest(".dropdown-menu"))
    return !0;
  const o = t.tagName === "LABEL" ? t : t.closest("label");
  if (o) {
    const a = o.getAttribute("for"), l = a ? document.getElementById(a) : o.querySelector("input, select, textarea");
    if (l && !l.disabled)
      return !0;
  }
  return t.matches(ss);
}, sl = ["top", "right", "bottom", "left"], Bo = ["start", "end"], So = /* @__PURE__ */ sl.reduce((e, t) => e.concat(t, t + "-" + Bo[0], t + "-" + Bo[1]), []), ut = Math.min, xe = Math.max, da = Math.round, oa = Math.floor, St = (e) => ({
  x: e,
  y: e
}), rs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, is = {
  start: "end",
  end: "start"
};
function Ia(e, t, o) {
  return xe(e, ut(t, o));
}
function bt(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function et(e) {
  return e.split("-")[0];
}
function rt(e) {
  return e.split("-")[1];
}
function rl(e) {
  return e === "x" ? "y" : "x";
}
function Ka(e) {
  return e === "y" ? "height" : "width";
}
function Mt(e) {
  return ["top", "bottom"].includes(et(e)) ? "y" : "x";
}
function Ya(e) {
  return rl(Mt(e));
}
function il(e, t, o) {
  o === void 0 && (o = !1);
  const a = rt(e), l = Ya(e), n = Ka(l);
  let r = l === "x" ? a === (o ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (r = fa(r)), [r, fa(r)];
}
function us(e) {
  const t = fa(e);
  return [ca(e), t, ca(t)];
}
function ca(e) {
  return e.replace(/start|end/g, (t) => is[t]);
}
function ds(e, t, o) {
  const a = ["left", "right"], l = ["right", "left"], n = ["top", "bottom"], r = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return o ? t ? l : a : t ? a : l;
    case "left":
    case "right":
      return t ? n : r;
    default:
      return [];
  }
}
function cs(e, t, o, a) {
  const l = rt(e);
  let n = ds(et(e), o === "start", a);
  return l && (n = n.map((r) => r + "-" + l), t && (n = n.concat(n.map(ca)))), n;
}
function fa(e) {
  return e.replace(/left|right|bottom|top/g, (t) => rs[t]);
}
function fs(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Za(e) {
  return typeof e != "number" ? fs(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Ht(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function wo(e, t, o) {
  let {
    reference: a,
    floating: l
  } = e;
  const n = Mt(t), r = Ya(t), s = Ka(r), i = et(t), u = n === "y", c = a.x + a.width / 2 - l.width / 2, f = a.y + a.height / 2 - l.height / 2, b = a[s] / 2 - l[s] / 2;
  let m;
  switch (i) {
    case "top":
      m = {
        x: c,
        y: a.y - l.height
      };
      break;
    case "bottom":
      m = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      m = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      m = {
        x: a.x - l.width,
        y: f
      };
      break;
    default:
      m = {
        x: a.x,
        y: a.y
      };
  }
  switch (rt(t)) {
    case "start":
      m[r] -= b * (o && u ? -1 : 1);
      break;
    case "end":
      m[r] += b * (o && u ? -1 : 1);
      break;
  }
  return m;
}
const vs = async (e, t, o) => {
  const {
    placement: a = "bottom",
    strategy: l = "absolute",
    middleware: n = [],
    platform: r
  } = o, s = n.filter(Boolean), i = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let u = await r.getElementRects({
    reference: e,
    floating: t,
    strategy: l
  }), {
    x: c,
    y: f
  } = wo(u, a, i), b = a, m = {}, h = 0;
  for (let $ = 0; $ < s.length; $++) {
    const {
      name: B,
      fn: v
    } = s[$], {
      x: S,
      y,
      data: _,
      reset: C
    } = await v({
      x: c,
      y: f,
      initialPlacement: a,
      placement: b,
      strategy: l,
      middlewareData: m,
      rects: u,
      platform: r,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = S ?? c, f = y ?? f, m = {
      ...m,
      [B]: {
        ...m[B],
        ..._
      }
    }, C && h <= 50 && (h++, typeof C == "object" && (C.placement && (b = C.placement), C.rects && (u = C.rects === !0 ? await r.getElementRects({
      reference: e,
      floating: t,
      strategy: l
    }) : C.rects), {
      x: c,
      y: f
    } = wo(u, b, i)), $ = -1);
  }
  return {
    x: c,
    y: f,
    placement: b,
    strategy: l,
    middlewareData: m
  };
};
async function Rt(e, t) {
  var o;
  t === void 0 && (t = {});
  const {
    x: a,
    y: l,
    platform: n,
    rects: r,
    elements: s,
    strategy: i
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: b = !1,
    padding: m = 0
  } = bt(t, e), h = Za(m), B = s[b ? f === "floating" ? "reference" : "floating" : f], v = Ht(await n.getClippingRect({
    element: (o = await (n.isElement == null ? void 0 : n.isElement(B))) == null || o ? B : B.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: i
  })), S = f === "floating" ? {
    ...r.floating,
    x: a,
    y: l
  } : r.reference, y = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(s.floating)), _ = await (n.isElement == null ? void 0 : n.isElement(y)) ? await (n.getScale == null ? void 0 : n.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = Ht(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: S,
    offsetParent: y,
    strategy: i
  }) : S);
  return {
    top: (v.top - C.top + h.top) / _.y,
    bottom: (C.bottom - v.bottom + h.bottom) / _.y,
    left: (v.left - C.left + h.left) / _.x,
    right: (C.right - v.right + h.right) / _.x
  };
}
const ps = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: o,
      y: a,
      placement: l,
      rects: n,
      platform: r,
      elements: s,
      middlewareData: i
    } = t, {
      element: u,
      padding: c = 0
    } = bt(e, t) || {};
    if (u == null)
      return {};
    const f = Za(c), b = {
      x: o,
      y: a
    }, m = Ya(l), h = Ka(m), $ = await r.getDimensions(u), B = m === "y", v = B ? "top" : "left", S = B ? "bottom" : "right", y = B ? "clientHeight" : "clientWidth", _ = n.reference[h] + n.reference[m] - b[m] - n.floating[h], C = b[m] - n.reference[m], T = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(u));
    let k = T ? T[y] : 0;
    (!k || !await (r.isElement == null ? void 0 : r.isElement(T))) && (k = s.floating[y] || n.floating[h]);
    const N = _ / 2 - C / 2, V = k / 2 - $[h] / 2 - 1, A = ut(f[v], V), E = ut(f[S], V), K = A, oe = k - $[h] - E, F = k / 2 - $[h] / 2 + N, z = Ia(K, F, oe), D = !i.arrow && rt(l) != null && F !== z && n.reference[h] / 2 - (F < K ? A : E) - $[h] / 2 < 0, J = D ? F < K ? F - K : F - oe : 0;
    return {
      [m]: b[m] + J,
      data: {
        [m]: z,
        centerOffset: F - z - J,
        ...D && {
          alignmentOffset: J
        }
      },
      reset: D
    };
  }
});
function ms(e, t, o) {
  return (e ? [...o.filter((l) => rt(l) === e), ...o.filter((l) => rt(l) !== e)] : o.filter((l) => et(l) === l)).filter((l) => e ? rt(l) === e || (t ? ca(l) !== l : !1) : !0);
}
const gs = function(e) {
  return e === void 0 && (e = {}), {
    name: "autoPlacement",
    options: e,
    async fn(t) {
      var o, a, l;
      const {
        rects: n,
        middlewareData: r,
        placement: s,
        platform: i,
        elements: u
      } = t, {
        crossAxis: c = !1,
        alignment: f,
        allowedPlacements: b = So,
        autoAlignment: m = !0,
        ...h
      } = bt(e, t), $ = f !== void 0 || b === So ? ms(f || null, m, b) : b, B = await Rt(t, h), v = ((o = r.autoPlacement) == null ? void 0 : o.index) || 0, S = $[v];
      if (S == null)
        return {};
      const y = il(S, n, await (i.isRTL == null ? void 0 : i.isRTL(u.floating)));
      if (s !== S)
        return {
          reset: {
            placement: $[0]
          }
        };
      const _ = [B[et(S)], B[y[0]], B[y[1]]], C = [...((a = r.autoPlacement) == null ? void 0 : a.overflows) || [], {
        placement: S,
        overflows: _
      }], T = $[v + 1];
      if (T)
        return {
          data: {
            index: v + 1,
            overflows: C
          },
          reset: {
            placement: T
          }
        };
      const k = C.map((A) => {
        const E = rt(A.placement);
        return [A.placement, E && c ? (
          // Check along the mainAxis and main crossAxis side.
          A.overflows.slice(0, 2).reduce((K, oe) => K + oe, 0)
        ) : (
          // Check only the mainAxis.
          A.overflows[0]
        ), A.overflows];
      }).sort((A, E) => A[1] - E[1]), V = ((l = k.filter((A) => A[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        rt(A[0]) ? 2 : 3
      ).every((E) => E <= 0))[0]) == null ? void 0 : l[0]) || k[0][0];
      return V !== s ? {
        data: {
          index: v + 1,
          overflows: C
        },
        reset: {
          placement: V
        }
      } : {};
    }
  };
}, bs = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var o, a;
      const {
        placement: l,
        middlewareData: n,
        rects: r,
        initialPlacement: s,
        platform: i,
        elements: u
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: b,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: $ = !0,
        ...B
      } = bt(e, t);
      if ((o = n.arrow) != null && o.alignmentOffset)
        return {};
      const v = et(l), S = et(s) === s, y = await (i.isRTL == null ? void 0 : i.isRTL(u.floating)), _ = b || (S || !$ ? [fa(s)] : us(s));
      !b && h !== "none" && _.push(...cs(s, $, h, y));
      const C = [s, ..._], T = await Rt(t, B), k = [];
      let N = ((a = n.flip) == null ? void 0 : a.overflows) || [];
      if (c && k.push(T[v]), f) {
        const K = il(l, r, y);
        k.push(T[K[0]], T[K[1]]);
      }
      if (N = [...N, {
        placement: l,
        overflows: k
      }], !k.every((K) => K <= 0)) {
        var V, A;
        const K = (((V = n.flip) == null ? void 0 : V.index) || 0) + 1, oe = C[K];
        if (oe)
          return {
            data: {
              index: K,
              overflows: N
            },
            reset: {
              placement: oe
            }
          };
        let F = (A = N.filter((z) => z.overflows[0] <= 0).sort((z, D) => z.overflows[1] - D.overflows[1])[0]) == null ? void 0 : A.placement;
        if (!F)
          switch (m) {
            case "bestFit": {
              var E;
              const z = (E = N.map((D) => [D.placement, D.overflows.filter((J) => J > 0).reduce((J, ie) => J + ie, 0)]).sort((D, J) => D[1] - J[1])[0]) == null ? void 0 : E[0];
              z && (F = z);
              break;
            }
            case "initialPlacement":
              F = s;
              break;
          }
        if (l !== F)
          return {
            reset: {
              placement: F
            }
          };
      }
      return {};
    }
  };
};
function Co(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function ko(e) {
  return sl.some((t) => e[t] >= 0);
}
const ys = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: o
      } = t, {
        strategy: a = "referenceHidden",
        ...l
      } = bt(e, t);
      switch (a) {
        case "referenceHidden": {
          const n = await Rt(t, {
            ...l,
            elementContext: "reference"
          }), r = Co(n, o.reference);
          return {
            data: {
              referenceHiddenOffsets: r,
              referenceHidden: ko(r)
            }
          };
        }
        case "escaped": {
          const n = await Rt(t, {
            ...l,
            altBoundary: !0
          }), r = Co(n, o.floating);
          return {
            data: {
              escapedOffsets: r,
              escaped: ko(r)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function ul(e) {
  const t = ut(...e.map((n) => n.left)), o = ut(...e.map((n) => n.top)), a = xe(...e.map((n) => n.right)), l = xe(...e.map((n) => n.bottom));
  return {
    x: t,
    y: o,
    width: a - t,
    height: l - o
  };
}
function hs(e) {
  const t = e.slice().sort((l, n) => l.y - n.y), o = [];
  let a = null;
  for (let l = 0; l < t.length; l++) {
    const n = t[l];
    !a || n.y - a.y > a.height / 2 ? o.push([n]) : o[o.length - 1].push(n), a = n;
  }
  return o.map((l) => Ht(ul(l)));
}
const Bs = function(e) {
  return e === void 0 && (e = {}), {
    name: "inline",
    options: e,
    async fn(t) {
      const {
        placement: o,
        elements: a,
        rects: l,
        platform: n,
        strategy: r
      } = t, {
        padding: s = 2,
        x: i,
        y: u
      } = bt(e, t), c = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference)) || []), f = hs(c), b = Ht(ul(c)), m = Za(s);
      function h() {
        if (f.length === 2 && f[0].left > f[1].right && i != null && u != null)
          return f.find((B) => i > B.left - m.left && i < B.right + m.right && u > B.top - m.top && u < B.bottom + m.bottom) || b;
        if (f.length >= 2) {
          if (Mt(o) === "y") {
            const A = f[0], E = f[f.length - 1], K = et(o) === "top", oe = A.top, F = E.bottom, z = K ? A.left : E.left, D = K ? A.right : E.right, J = D - z, ie = F - oe;
            return {
              top: oe,
              bottom: F,
              left: z,
              right: D,
              width: J,
              height: ie,
              x: z,
              y: oe
            };
          }
          const B = et(o) === "left", v = xe(...f.map((A) => A.right)), S = ut(...f.map((A) => A.left)), y = f.filter((A) => B ? A.left === S : A.right === v), _ = y[0].top, C = y[y.length - 1].bottom, T = S, k = v, N = k - T, V = C - _;
          return {
            top: _,
            bottom: C,
            left: T,
            right: k,
            width: N,
            height: V,
            x: T,
            y: _
          };
        }
        return b;
      }
      const $ = await n.getElementRects({
        reference: {
          getBoundingClientRect: h
        },
        floating: a.floating,
        strategy: r
      });
      return l.reference.x !== $.reference.x || l.reference.y !== $.reference.y || l.reference.width !== $.reference.width || l.reference.height !== $.reference.height ? {
        reset: {
          rects: $
        }
      } : {};
    }
  };
};
async function Ss(e, t) {
  const {
    placement: o,
    platform: a,
    elements: l
  } = e, n = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), r = et(o), s = rt(o), i = Mt(o) === "y", u = ["left", "top"].includes(r) ? -1 : 1, c = n && i ? -1 : 1, f = bt(t, e);
  let {
    mainAxis: b,
    crossAxis: m,
    alignmentAxis: h
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return s && typeof h == "number" && (m = s === "end" ? h * -1 : h), i ? {
    x: m * c,
    y: b * u
  } : {
    x: b * u,
    y: m * c
  };
}
const dl = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var o, a;
      const {
        x: l,
        y: n,
        placement: r,
        middlewareData: s
      } = t, i = await Ss(t, e);
      return r === ((o = s.offset) == null ? void 0 : o.placement) && (a = s.arrow) != null && a.alignmentOffset ? {} : {
        x: l + i.x,
        y: n + i.y,
        data: {
          ...i,
          placement: r
        }
      };
    }
  };
}, ws = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: o,
        y: a,
        placement: l
      } = t, {
        mainAxis: n = !0,
        crossAxis: r = !1,
        limiter: s = {
          fn: (B) => {
            let {
              x: v,
              y: S
            } = B;
            return {
              x: v,
              y: S
            };
          }
        },
        ...i
      } = bt(e, t), u = {
        x: o,
        y: a
      }, c = await Rt(t, i), f = Mt(et(l)), b = rl(f);
      let m = u[b], h = u[f];
      if (n) {
        const B = b === "y" ? "top" : "left", v = b === "y" ? "bottom" : "right", S = m + c[B], y = m - c[v];
        m = Ia(S, m, y);
      }
      if (r) {
        const B = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", S = h + c[B], y = h - c[v];
        h = Ia(S, h, y);
      }
      const $ = s.fn({
        ...t,
        [b]: m,
        [f]: h
      });
      return {
        ...$,
        data: {
          x: $.x - o,
          y: $.y - a
        }
      };
    }
  };
}, Cs = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: o,
        rects: a,
        platform: l,
        elements: n
      } = t, {
        apply: r = () => {
        },
        ...s
      } = bt(e, t), i = await Rt(t, s), u = et(o), c = rt(o), f = Mt(o) === "y", {
        width: b,
        height: m
      } = a.floating;
      let h, $;
      u === "top" || u === "bottom" ? (h = u, $ = c === (await (l.isRTL == null ? void 0 : l.isRTL(n.floating)) ? "start" : "end") ? "left" : "right") : ($ = u, h = c === "end" ? "top" : "bottom");
      const B = m - i[h], v = b - i[$], S = !t.middlewareData.shift;
      let y = B, _ = v;
      if (f) {
        const T = b - i.left - i.right;
        _ = c || S ? ut(v, T) : T;
      } else {
        const T = m - i.top - i.bottom;
        y = c || S ? ut(B, T) : T;
      }
      if (S && !c) {
        const T = xe(i.left, 0), k = xe(i.right, 0), N = xe(i.top, 0), V = xe(i.bottom, 0);
        f ? _ = b - 2 * (T !== 0 || k !== 0 ? T + k : xe(i.left, i.right)) : y = m - 2 * (N !== 0 || V !== 0 ? N + V : xe(i.top, i.bottom));
      }
      await r({
        ...t,
        availableWidth: _,
        availableHeight: y
      });
      const C = await l.getDimensions(n.floating);
      return b !== C.width || m !== C.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function pt(e) {
  return Ja(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ke(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function yt(e) {
  var t;
  return (t = (Ja(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ja(e) {
  return e instanceof Node || e instanceof Ke(e).Node;
}
function mt(e) {
  return e instanceof Element || e instanceof Ke(e).Element;
}
function ct(e) {
  return e instanceof HTMLElement || e instanceof Ke(e).HTMLElement;
}
function $o(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ke(e).ShadowRoot;
}
function Qt(e) {
  const {
    overflow: t,
    overflowX: o,
    overflowY: a,
    display: l
  } = tt(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + o) && !["inline", "contents"].includes(l);
}
function ks(e) {
  return ["table", "td", "th"].includes(pt(e));
}
function Qa(e) {
  const t = eo(), o = tt(e);
  return o.transform !== "none" || o.perspective !== "none" || (o.containerType ? o.containerType !== "normal" : !1) || !t && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !t && (o.filter ? o.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((a) => (o.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (o.contain || "").includes(a));
}
function cl(e) {
  let t = xt(e);
  for (; ct(t) && !ha(t); ) {
    if (Qa(t))
      return t;
    t = xt(t);
  }
  return null;
}
function eo() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ha(e) {
  return ["html", "body", "#document"].includes(pt(e));
}
function tt(e) {
  return Ke(e).getComputedStyle(e);
}
function Ba(e) {
  return mt(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function xt(e) {
  if (pt(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    $o(e) && e.host || // Fallback.
    yt(e)
  );
  return $o(t) ? t.host : t;
}
function fl(e) {
  const t = xt(e);
  return ha(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ct(t) && Qt(t) ? t : fl(t);
}
function Xt(e, t, o) {
  var a;
  t === void 0 && (t = []), o === void 0 && (o = !0);
  const l = fl(e), n = l === ((a = e.ownerDocument) == null ? void 0 : a.body), r = Ke(l);
  return n ? t.concat(r, r.visualViewport || [], Qt(l) ? l : [], r.frameElement && o ? Xt(r.frameElement) : []) : t.concat(l, Xt(l, [], o));
}
function vl(e) {
  const t = tt(e);
  let o = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const l = ct(e), n = l ? e.offsetWidth : o, r = l ? e.offsetHeight : a, s = da(o) !== n || da(a) !== r;
  return s && (o = n, a = r), {
    width: o,
    height: a,
    $: s
  };
}
function to(e) {
  return mt(e) ? e : e.contextElement;
}
function Lt(e) {
  const t = to(e);
  if (!ct(t))
    return St(1);
  const o = t.getBoundingClientRect(), {
    width: a,
    height: l,
    $: n
  } = vl(t);
  let r = (n ? da(o.width) : o.width) / a, s = (n ? da(o.height) : o.height) / l;
  return (!r || !Number.isFinite(r)) && (r = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: r,
    y: s
  };
}
const $s = /* @__PURE__ */ St(0);
function pl(e) {
  const t = Ke(e);
  return !eo() || !t.visualViewport ? $s : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Ts(e, t, o) {
  return t === void 0 && (t = !1), !o || t && o !== Ke(e) ? !1 : t;
}
function $t(e, t, o, a) {
  t === void 0 && (t = !1), o === void 0 && (o = !1);
  const l = e.getBoundingClientRect(), n = to(e);
  let r = St(1);
  t && (a ? mt(a) && (r = Lt(a)) : r = Lt(e));
  const s = Ts(n, o, a) ? pl(n) : St(0);
  let i = (l.left + s.x) / r.x, u = (l.top + s.y) / r.y, c = l.width / r.x, f = l.height / r.y;
  if (n) {
    const b = Ke(n), m = a && mt(a) ? Ke(a) : a;
    let h = b.frameElement;
    for (; h && a && m !== b; ) {
      const $ = Lt(h), B = h.getBoundingClientRect(), v = tt(h), S = B.left + (h.clientLeft + parseFloat(v.paddingLeft)) * $.x, y = B.top + (h.clientTop + parseFloat(v.paddingTop)) * $.y;
      i *= $.x, u *= $.y, c *= $.x, f *= $.y, i += S, u += y, h = Ke(h).frameElement;
    }
  }
  return Ht({
    width: c,
    height: f,
    x: i,
    y: u
  });
}
const _s = [":popover-open", ":modal"];
function ml(e) {
  let t = !1, o = 0, a = 0;
  function l(n) {
    try {
      t = t || e.matches(n);
    } catch {
    }
  }
  if (_s.forEach((n) => {
    l(n);
  }), t) {
    const n = cl(e);
    if (n) {
      const r = n.getBoundingClientRect();
      o = r.x, a = r.y;
    }
  }
  return [t, o, a];
}
function Vs(e) {
  let {
    elements: t,
    rect: o,
    offsetParent: a,
    strategy: l
  } = e;
  const n = yt(a), [r] = t ? ml(t.floating) : [!1];
  if (a === n || r)
    return o;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, i = St(1);
  const u = St(0), c = ct(a);
  if ((c || !c && l !== "fixed") && ((pt(a) !== "body" || Qt(n)) && (s = Ba(a)), ct(a))) {
    const f = $t(a);
    i = Lt(a), u.x = f.x + a.clientLeft, u.y = f.y + a.clientTop;
  }
  return {
    width: o.width * i.x,
    height: o.height * i.y,
    x: o.x * i.x - s.scrollLeft * i.x + u.x,
    y: o.y * i.y - s.scrollTop * i.y + u.y
  };
}
function As(e) {
  return Array.from(e.getClientRects());
}
function gl(e) {
  return $t(yt(e)).left + Ba(e).scrollLeft;
}
function Os(e) {
  const t = yt(e), o = Ba(e), a = e.ownerDocument.body, l = xe(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), n = xe(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let r = -o.scrollLeft + gl(e);
  const s = -o.scrollTop;
  return tt(a).direction === "rtl" && (r += xe(t.clientWidth, a.clientWidth) - l), {
    width: l,
    height: n,
    x: r,
    y: s
  };
}
function Es(e, t) {
  const o = Ke(e), a = yt(e), l = o.visualViewport;
  let n = a.clientWidth, r = a.clientHeight, s = 0, i = 0;
  if (l) {
    n = l.width, r = l.height;
    const u = eo();
    (!u || u && t === "fixed") && (s = l.offsetLeft, i = l.offsetTop);
  }
  return {
    width: n,
    height: r,
    x: s,
    y: i
  };
}
function Ps(e, t) {
  const o = $t(e, !0, t === "fixed"), a = o.top + e.clientTop, l = o.left + e.clientLeft, n = ct(e) ? Lt(e) : St(1), r = e.clientWidth * n.x, s = e.clientHeight * n.y, i = l * n.x, u = a * n.y;
  return {
    width: r,
    height: s,
    x: i,
    y: u
  };
}
function To(e, t, o) {
  let a;
  if (t === "viewport")
    a = Es(e, o);
  else if (t === "document")
    a = Os(yt(e));
  else if (mt(t))
    a = Ps(t, o);
  else {
    const l = pl(e);
    a = {
      ...t,
      x: t.x - l.x,
      y: t.y - l.y
    };
  }
  return Ht(a);
}
function bl(e, t) {
  const o = xt(e);
  return o === t || !mt(o) || ha(o) ? !1 : tt(o).position === "fixed" || bl(o, t);
}
function Ns(e, t) {
  const o = t.get(e);
  if (o)
    return o;
  let a = Xt(e, [], !1).filter((s) => mt(s) && pt(s) !== "body"), l = null;
  const n = tt(e).position === "fixed";
  let r = n ? xt(e) : e;
  for (; mt(r) && !ha(r); ) {
    const s = tt(r), i = Qa(r);
    !i && s.position === "fixed" && (l = null), (n ? !i && !l : !i && s.position === "static" && !!l && ["absolute", "fixed"].includes(l.position) || Qt(r) && !i && bl(e, r)) ? a = a.filter((c) => c !== r) : l = s, r = xt(r);
  }
  return t.set(e, a), a;
}
function Is(e) {
  let {
    element: t,
    boundary: o,
    rootBoundary: a,
    strategy: l
  } = e;
  const r = [...o === "clippingAncestors" ? Ns(t, this._c) : [].concat(o), a], s = r[0], i = r.reduce((u, c) => {
    const f = To(t, c, l);
    return u.top = xe(f.top, u.top), u.right = ut(f.right, u.right), u.bottom = ut(f.bottom, u.bottom), u.left = xe(f.left, u.left), u;
  }, To(t, s, l));
  return {
    width: i.right - i.left,
    height: i.bottom - i.top,
    x: i.left,
    y: i.top
  };
}
function Fs(e) {
  const {
    width: t,
    height: o
  } = vl(e);
  return {
    width: t,
    height: o
  };
}
function Ls(e, t, o, a) {
  const l = ct(t), n = yt(t), r = o === "fixed", s = $t(e, !0, r, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = St(0);
  if (l || !l && !r)
    if ((pt(t) !== "body" || Qt(n)) && (i = Ba(t)), l) {
      const $ = $t(t, !0, r, t);
      u.x = $.x + t.clientLeft, u.y = $.y + t.clientTop;
    } else
      n && (u.x = gl(n));
  let c = s.left + i.scrollLeft - u.x, f = s.top + i.scrollTop - u.y;
  const [b, m, h] = ml(a);
  return b && (c += m, f += h, l && (c += t.clientLeft, f += t.clientTop)), {
    x: c,
    y: f,
    width: s.width,
    height: s.height
  };
}
function _o(e, t) {
  return !ct(e) || tt(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function yl(e, t) {
  const o = Ke(e);
  if (!ct(e))
    return o;
  let a = _o(e, t);
  for (; a && ks(a) && tt(a).position === "static"; )
    a = _o(a, t);
  return a && (pt(a) === "html" || pt(a) === "body" && tt(a).position === "static" && !Qa(a)) ? o : a || cl(e) || o;
}
const zs = async function(e) {
  const t = this.getOffsetParent || yl, o = this.getDimensions;
  return {
    reference: Ls(e.reference, await t(e.floating), e.strategy, e.floating),
    floating: {
      x: 0,
      y: 0,
      ...await o(e.floating)
    }
  };
};
function Hs(e) {
  return tt(e).direction === "rtl";
}
const Rs = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Vs,
  getDocumentElement: yt,
  getClippingRect: Is,
  getOffsetParent: yl,
  getElementRects: zs,
  getClientRects: As,
  getDimensions: Fs,
  getScale: Lt,
  isElement: mt,
  isRTL: Hs
};
function xs(e, t) {
  let o = null, a;
  const l = yt(e);
  function n() {
    var s;
    clearTimeout(a), (s = o) == null || s.disconnect(), o = null;
  }
  function r(s, i) {
    s === void 0 && (s = !1), i === void 0 && (i = 1), n();
    const {
      left: u,
      top: c,
      width: f,
      height: b
    } = e.getBoundingClientRect();
    if (s || t(), !f || !b)
      return;
    const m = oa(c), h = oa(l.clientWidth - (u + f)), $ = oa(l.clientHeight - (c + b)), B = oa(u), S = {
      rootMargin: -m + "px " + -h + "px " + -$ + "px " + -B + "px",
      threshold: xe(0, ut(1, i)) || 1
    };
    let y = !0;
    function _(C) {
      const T = C[0].intersectionRatio;
      if (T !== i) {
        if (!y)
          return r();
        T ? r(!1, T) : a = setTimeout(() => {
          r(!1, 1e-7);
        }, 100);
      }
      y = !1;
    }
    try {
      o = new IntersectionObserver(_, {
        ...S,
        // Handle <iframe>s
        root: l.ownerDocument
      });
    } catch {
      o = new IntersectionObserver(_, S);
    }
    o.observe(e);
  }
  return r(!0), n;
}
function hl(e, t, o, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: l = !0,
    ancestorResize: n = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: i = !1
  } = a, u = to(e), c = l || n ? [...u ? Xt(u) : [], ...Xt(t)] : [];
  c.forEach((v) => {
    l && v.addEventListener("scroll", o, {
      passive: !0
    }), n && v.addEventListener("resize", o);
  });
  const f = u && s ? xs(u, o) : null;
  let b = -1, m = null;
  r && (m = new ResizeObserver((v) => {
    let [S] = v;
    S && S.target === u && m && (m.unobserve(t), cancelAnimationFrame(b), b = requestAnimationFrame(() => {
      var y;
      (y = m) == null || y.observe(t);
    })), o();
  }), u && !i && m.observe(u), m.observe(t));
  let h, $ = i ? $t(e) : null;
  i && B();
  function B() {
    const v = $t(e);
    $ && (v.x !== $.x || v.y !== $.y || v.width !== $.width || v.height !== $.height) && o(), $ = v, h = requestAnimationFrame(B);
  }
  return o(), () => {
    var v;
    c.forEach((S) => {
      l && S.removeEventListener("scroll", o), n && S.removeEventListener("resize", o);
    }), f == null || f(), (v = m) == null || v.disconnect(), m = null, i && cancelAnimationFrame(h);
  };
}
const Ms = gs, Bl = ws, Sl = bs, wl = Cs, Ds = ys, js = ps, qs = Bs, Ws = (e, t, o) => {
  const a = /* @__PURE__ */ new Map(), l = {
    platform: Rs,
    ...o
  }, n = {
    ...l.platform,
    _c: a
  };
  return vs(e, t, {
    ...l,
    platform: n
  });
};
function Gs(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function Fa(e) {
  if (Gs(e)) {
    const t = e.$el;
    return Ja(t) && pt(t) === "#comment" ? null : t;
  }
  return e;
}
function Us(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const o = Fa(p(e.element));
      return o == null ? {} : js({
        element: o,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Cl(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Vo(e, t) {
  const o = Cl(e);
  return Math.round(t * o) / o;
}
function kl(e, t, o) {
  o === void 0 && (o = {});
  const a = o.whileElementsMounted, l = w(() => {
    var k;
    return (k = p(o.open)) != null ? k : !0;
  }), n = w(() => p(o.middleware)), r = w(() => {
    var k;
    return (k = p(o.placement)) != null ? k : "bottom";
  }), s = w(() => {
    var k;
    return (k = p(o.strategy)) != null ? k : "absolute";
  }), i = w(() => {
    var k;
    return (k = p(o.transform)) != null ? k : !0;
  }), u = w(() => Fa(e.value)), c = w(() => Fa(t.value)), f = W(0), b = W(0), m = W(s.value), h = W(r.value), $ = kt({}), B = W(!1), v = w(() => {
    const k = {
      position: m.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return k;
    const N = Vo(c.value, f.value), V = Vo(c.value, b.value);
    return i.value ? {
      ...k,
      transform: "translate(" + N + "px, " + V + "px)",
      ...Cl(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: m.value,
      left: N + "px",
      top: V + "px"
    };
  });
  let S;
  function y() {
    u.value == null || c.value == null || Ws(u.value, c.value, {
      middleware: n.value,
      placement: r.value,
      strategy: s.value
    }).then((k) => {
      f.value = k.x, b.value = k.y, m.value = k.strategy, h.value = k.placement, $.value = k.middlewareData, B.value = !0;
    });
  }
  function _() {
    typeof S == "function" && (S(), S = void 0);
  }
  function C() {
    if (_(), a === void 0) {
      y();
      return;
    }
    if (u.value != null && c.value != null) {
      S = a(u.value, c.value, y);
      return;
    }
  }
  function T() {
    l.value || (B.value = !1);
  }
  return ce([n, r, s], y, {
    flush: "sync"
  }), ce([u, c], C, {
    flush: "sync"
  }), ce(l, T, {
    flush: "sync"
  }), Qo() && el(_), {
    x: Pt(f),
    y: Pt(b),
    strategy: Pt(m),
    placement: Pt(h),
    middlewareData: Pt($),
    isPositioned: Pt(B),
    floatingStyles: v,
    update: y
  };
}
const Xs = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Ks = /^aria-[\w-]*$/i, Ys = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Zs = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Js = (e, t) => {
  const o = e.nodeName.toLowerCase();
  return t.includes(o) ? Xs.has(o) ? !!(Ys.test(e.nodeValue || "") || Zs.test(e.nodeValue || "")) : !0 : t.filter((a) => a instanceof RegExp).some((a) => a.test(o));
}, Nt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Ks],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, It = (e, t, o) => {
  if (!e.length)
    return e;
  if (o && typeof o == "function")
    return o(e);
  const l = new window.DOMParser().parseFromString(e, "text/html"), n = l.body.querySelectorAll("*");
  for (const r of n) {
    const s = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(s)) {
      r.remove();
      continue;
    }
    const i = r.attributes, u = [...t["*"] || [], ...t[s] || []];
    for (const c of i)
      Js(c, u) || r.removeAttribute(c.nodeName);
  }
  return l.body.innerHTML;
};
function gt(e) {
  return Qo() ? (el(e), !0) : !1;
}
function Qs(e, t) {
  if (typeof Symbol < "u") {
    const o = { ...e };
    return Object.defineProperty(o, Symbol.iterator, {
      enumerable: !1,
      value() {
        let a = 0;
        return {
          next: () => ({
            value: t[a++],
            done: a > t.length
          })
        };
      }
    }), o;
  } else
    return Object.assign([...t], e);
}
function Ye(e) {
  return typeof e == "function" ? e() : p(e);
}
const va = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const er = (e) => typeof e < "u", tr = (e) => e != null, ar = Object.prototype.toString, or = (e) => ar.call(e) === "[object Object]", Qe = () => {
}, La = /* @__PURE__ */ lr();
function lr() {
  var e, t;
  return va && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function $l(e, t) {
  function o(...a) {
    return new Promise((l, n) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(l).catch(n);
    });
  }
  return o;
}
const Tl = (e) => e();
function nr(e, t = {}) {
  let o, a, l = Qe;
  const n = (s) => {
    clearTimeout(s), l(), l = Qe;
  };
  return (s) => {
    const i = Ye(e), u = Ye(t.maxWait);
    return o && n(o), i <= 0 || u !== void 0 && u <= 0 ? (a && (n(a), a = null), Promise.resolve(s())) : new Promise((c, f) => {
      l = t.rejectOnCancel ? f : c, u && !a && (a = setTimeout(() => {
        o && n(o), a = null, c(s());
      }, u)), o = setTimeout(() => {
        a && n(a), a = null, c(s());
      }, i);
    });
  };
}
function sr(e = Tl) {
  const t = W(!0);
  function o() {
    t.value = !1;
  }
  function a() {
    t.value = !0;
  }
  const l = (...n) => {
    t.value && e(...n);
  };
  return { isActive: Ue(t), pause: o, resume: a, eventFilter: l };
}
function rr(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return (o) => t[o] || (t[o] = e(o));
}
const ir = /-(\w)/g, ur = rr((e) => e.replace(ir, (t, o) => o ? o.toUpperCase() : ""));
function dr(e) {
  return e || Tt();
}
function _l(...e) {
  if (e.length !== 1)
    return P(...e);
  const t = e[0];
  return typeof t == "function" ? Ue(Hn(() => ({ get: t, set: Qe }))) : W(t);
}
function cr(e, t = 200, o = {}) {
  return $l(
    nr(t, o),
    e
  );
}
function fr(e, t, o = {}) {
  const {
    eventFilter: a = Tl,
    ...l
  } = o;
  return ce(
    e,
    $l(
      a,
      t
    ),
    l
  );
}
function za(e, t, o = {}) {
  const {
    eventFilter: a,
    ...l
  } = o, { eventFilter: n, pause: r, resume: s, isActive: i } = sr(a);
  return { stop: fr(
    e,
    t,
    {
      ...l,
      eventFilter: n
    }
  ), pause: r, resume: s, isActive: i };
}
function Ha(e, t, ...[o]) {
  const {
    flush: a = "sync",
    deep: l = !1,
    immediate: n = !0,
    direction: r = "both",
    transform: s = {}
  } = o || {}, i = [], u = "ltr" in s && s.ltr || ((b) => b), c = "rtl" in s && s.rtl || ((b) => b);
  return (r === "both" || r === "ltr") && i.push(za(
    e,
    (b) => {
      i.forEach((m) => m.pause()), t.value = u(b), i.forEach((m) => m.resume());
    },
    { flush: a, deep: l, immediate: n }
  )), (r === "both" || r === "rtl") && i.push(za(
    t,
    (b) => {
      i.forEach((m) => m.pause()), e.value = c(b), i.forEach((m) => m.resume());
    },
    { flush: a, deep: l, immediate: n }
  )), () => {
    i.forEach((b) => b.stop());
  };
}
function Vl(e, t = !0, o) {
  dr() ? at(e, o) : t ? e() : Fe(e);
}
function Al(e, t = 1e3, o = {}) {
  const {
    immediate: a = !0,
    immediateCallback: l = !1
  } = o;
  let n = null;
  const r = W(!1);
  function s() {
    n && (clearInterval(n), n = null);
  }
  function i() {
    r.value = !1, s();
  }
  function u() {
    const c = Ye(t);
    c <= 0 || (r.value = !0, l && e(), s(), n = setInterval(e, c));
  }
  if (a && va && u(), tl(t) || typeof t == "function") {
    const c = ce(t, () => {
      r.value && va && u();
    });
    gt(c);
  }
  return gt(i), {
    isActive: r,
    pause: i,
    resume: u
  };
}
function Se(e, t = {}) {
  const {
    method: o = "parseFloat",
    radix: a,
    nanToZero: l
  } = t;
  return w(() => {
    let n = Ye(e);
    return typeof n == "string" && (n = Number[o](n, a)), l && Number.isNaN(n) && (n = 0), n;
  });
}
function pa(e = {}) {
  const {
    inheritAttrs: t = !0
  } = e, o = kt(), a = /* @__PURE__ */ q({
    setup(n, { slots: r }) {
      return () => {
        o.value = r.default;
      };
    }
  }), l = /* @__PURE__ */ q({
    inheritAttrs: t,
    setup(n, { attrs: r, slots: s }) {
      return () => {
        var i;
        if (!o.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const u = (i = o.value) == null ? void 0 : i.call(o, { ...vr(r), $slots: s });
        return t && (u == null ? void 0 : u.length) === 1 ? u[0] : u;
      };
    }
  });
  return Qs(
    { define: a, reuse: l },
    [a, l]
  );
}
function vr(e) {
  const t = {};
  for (const o in e)
    t[ur(o)] = e[o];
  return t;
}
function Xe(e) {
  var t;
  const o = Ye(e);
  return (t = o == null ? void 0 : o.$el) != null ? t : o;
}
const Ze = va ? window : void 0;
function Ne(...e) {
  let t, o, a, l;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([o, a, l] = e, t = Ze) : [t, o, a, l] = e, !t)
    return Qe;
  Array.isArray(o) || (o = [o]), Array.isArray(a) || (a = [a]);
  const n = [], r = () => {
    n.forEach((c) => c()), n.length = 0;
  }, s = (c, f, b, m) => (c.addEventListener(f, b, m), () => c.removeEventListener(f, b, m)), i = ce(
    () => [Xe(t), Ye(l)],
    ([c, f]) => {
      if (r(), !c)
        return;
      const b = or(f) ? { ...f } : f;
      n.push(
        ...o.flatMap((m) => a.map((h) => s(c, m, h, b)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    i(), r();
  };
  return gt(u), u;
}
let Ao = !1;
function Ol(e, t, o = {}) {
  const { window: a = Ze, ignore: l = [], capture: n = !0, detectIframe: r = !1 } = o;
  if (!a)
    return Qe;
  La && !Ao && (Ao = !0, Array.from(a.document.body.children).forEach((b) => b.addEventListener("click", Qe)), a.document.documentElement.addEventListener("click", Qe));
  let s = !0;
  const i = (b) => l.some((m) => {
    if (typeof m == "string")
      return Array.from(a.document.querySelectorAll(m)).some((h) => h === b.target || b.composedPath().includes(h));
    {
      const h = Xe(m);
      return h && (b.target === h || b.composedPath().includes(h));
    }
  }), c = [
    Ne(a, "click", (b) => {
      const m = Xe(e);
      if (!(!m || m === b.target || b.composedPath().includes(m))) {
        if (b.detail === 0 && (s = !i(b)), !s) {
          s = !0;
          return;
        }
        t(b);
      }
    }, { passive: !0, capture: n }),
    Ne(a, "pointerdown", (b) => {
      const m = Xe(e);
      s = !i(b) && !!(m && !b.composedPath().includes(m));
    }, { passive: !0 }),
    r && Ne(a, "blur", (b) => {
      setTimeout(() => {
        var m;
        const h = Xe(e);
        ((m = a.document.activeElement) == null ? void 0 : m.tagName) === "IFRAME" && !(h != null && h.contains(a.document.activeElement)) && t(b);
      }, 0);
    })
  ].filter(Boolean);
  return () => c.forEach((b) => b());
}
function pr(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function Ge(...e) {
  let t, o, a = {};
  e.length === 3 ? (t = e[0], o = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, o = e[0], a = e[1]) : (t = e[0], o = e[1]) : (t = !0, o = e[0]);
  const {
    target: l = Ze,
    eventName: n = "keydown",
    passive: r = !1,
    dedupe: s = !1
  } = a, i = pr(t);
  return Ne(l, n, (c) => {
    c.repeat && Ye(s) || i(c) && o(c);
  }, r);
}
function mr() {
  const e = W(!1);
  return Tt() && at(() => {
    e.value = !0;
  }), e;
}
function ao(e) {
  const t = mr();
  return w(() => (t.value, !!e()));
}
function gr(e, t = {}) {
  const { window: o = Ze } = t, a = ao(() => o && "matchMedia" in o && typeof o.matchMedia == "function");
  let l;
  const n = W(!1), r = (u) => {
    n.value = u.matches;
  }, s = () => {
    l && ("removeEventListener" in l ? l.removeEventListener("change", r) : l.removeListener(r));
  }, i = Yt(() => {
    a.value && (s(), l = o.matchMedia(Ye(e)), "addEventListener" in l ? l.addEventListener("change", r) : l.addListener(r), n.value = l.matches);
  });
  return gt(() => {
    i(), s(), l = void 0;
  }), n;
}
function br(e) {
  return JSON.parse(JSON.stringify(e));
}
const la = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, na = "__vueuse_ssr_handlers__", yr = /* @__PURE__ */ hr();
function hr() {
  return na in la || (la[na] = la[na] || {}), la[na];
}
function oo(e, t) {
  return yr[e] || t;
}
function Br(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const Sr = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Oo = "vueuse-storage";
function wr(e, t, o, a = {}) {
  var l;
  const {
    flush: n = "pre",
    deep: r = !0,
    listenToStorageChanges: s = !0,
    writeDefaults: i = !0,
    mergeDefaults: u = !1,
    shallow: c,
    window: f = Ze,
    eventFilter: b,
    onError: m = (V) => {
      console.error(V);
    },
    initOnMounted: h
  } = a, $ = (c ? kt : W)(typeof t == "function" ? t() : t);
  if (!o)
    try {
      o = oo("getDefaultStorage", () => {
        var V;
        return (V = Ze) == null ? void 0 : V.localStorage;
      })();
    } catch (V) {
      m(V);
    }
  if (!o)
    return $;
  const B = Ye(t), v = Br(B), S = (l = a.serializer) != null ? l : Sr[v], { pause: y, resume: _ } = za(
    $,
    () => C($.value),
    { flush: n, deep: r, eventFilter: b }
  );
  return f && s && Vl(() => {
    Ne(f, "storage", N), Ne(f, Oo, k), h && N();
  }), h || N(), $;
  function C(V) {
    try {
      if (V == null)
        o.removeItem(e);
      else {
        const A = S.write(V), E = o.getItem(e);
        E !== A && (o.setItem(e, A), f && f.dispatchEvent(new CustomEvent(Oo, {
          detail: {
            key: e,
            oldValue: E,
            newValue: A,
            storageArea: o
          }
        })));
      }
    } catch (A) {
      m(A);
    }
  }
  function T(V) {
    const A = V ? V.newValue : o.getItem(e);
    if (A == null)
      return i && B != null && o.setItem(e, S.write(B)), B;
    if (!V && u) {
      const E = S.read(A);
      return typeof u == "function" ? u(E, B) : v === "object" && !Array.isArray(E) ? { ...B, ...E } : E;
    } else
      return typeof A != "string" ? A : S.read(A);
  }
  function k(V) {
    N(V.detail);
  }
  function N(V) {
    if (!(V && V.storageArea !== o)) {
      if (V && V.key == null) {
        $.value = B;
        return;
      }
      if (!(V && V.key !== e)) {
        y();
        try {
          (V == null ? void 0 : V.newValue) !== S.write($.value) && ($.value = T(V));
        } catch (A) {
          m(A);
        } finally {
          V ? Fe(_) : _();
        }
      }
    }
  }
}
function Cr(e) {
  return gr("(prefers-color-scheme: dark)", e);
}
function kr(e = {}) {
  const {
    selector: t = "html",
    attribute: o = "class",
    initialValue: a = "auto",
    window: l = Ze,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: s = !0,
    storageRef: i,
    emitAuto: u,
    disableTransition: c = !0
  } = e, f = {
    auto: "",
    light: "light",
    dark: "dark",
    ...e.modes || {}
  }, b = Cr({ window: l }), m = w(() => b.value ? "dark" : "light"), h = i || (r == null ? _l(a) : wr(r, a, n, { window: l, listenToStorageChanges: s })), $ = w(() => h.value === "auto" ? m.value : h.value), B = oo(
    "updateHTMLAttrs",
    (_, C, T) => {
      const k = typeof _ == "string" ? l == null ? void 0 : l.document.querySelector(_) : Xe(_);
      if (!k)
        return;
      let N;
      if (c && (N = l.document.createElement("style"), N.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), l.document.head.appendChild(N)), C === "class") {
        const V = T.split(/\s/g);
        Object.values(f).flatMap((A) => (A || "").split(/\s/g)).filter(Boolean).forEach((A) => {
          V.includes(A) ? k.classList.add(A) : k.classList.remove(A);
        });
      } else
        k.setAttribute(C, T);
      c && (l.getComputedStyle(N).opacity, document.head.removeChild(N));
    }
  );
  function v(_) {
    var C;
    B(t, o, (C = f[_]) != null ? C : _);
  }
  function S(_) {
    e.onChanged ? e.onChanged(_, v) : v(_);
  }
  ce($, S, { flush: "post", immediate: !0 }), Vl(() => S($.value));
  const y = w({
    get() {
      return u ? h.value : $.value;
    },
    set(_) {
      h.value = _;
    }
  });
  try {
    return Object.assign(y, { store: h, system: m, state: $ });
  } catch {
    return y;
  }
}
function $r(e, t, o = {}) {
  const { window: a = Ze, ...l } = o;
  let n;
  const r = ao(() => a && "MutationObserver" in a), s = () => {
    n && (n.disconnect(), n = void 0);
  }, i = ce(
    () => Xe(e),
    (f) => {
      s(), r.value && a && f && (n = new MutationObserver(t), n.observe(f, l));
    },
    { immediate: !0 }
  ), u = () => n == null ? void 0 : n.takeRecords(), c = () => {
    s(), i();
  };
  return gt(c), {
    isSupported: r,
    stop: c,
    takeRecords: u
  };
}
function lo(e, t = {}) {
  const {
    delayEnter: o = 0,
    delayLeave: a = 0,
    window: l = Ze
  } = t, n = W(!1);
  let r;
  const s = (i) => {
    const u = i ? o : a;
    r && (clearTimeout(r), r = void 0), u ? r = setTimeout(() => n.value = i, u) : n.value = i;
  };
  return l && (Ne(e, "mouseenter", () => s(!0), { passive: !0 }), Ne(e, "mouseleave", () => s(!1), { passive: !0 })), n;
}
function Tr(e, t, o = {}) {
  const {
    root: a,
    rootMargin: l = "0px",
    threshold: n = 0.1,
    window: r = Ze,
    immediate: s = !0
  } = o, i = ao(() => r && "IntersectionObserver" in r), u = w(() => {
    const h = Ye(e);
    return (Array.isArray(h) ? h : [h]).map(Xe).filter(tr);
  });
  let c = Qe;
  const f = W(s), b = i.value ? ce(
    () => [u.value, Xe(a), f.value],
    ([h, $]) => {
      if (c(), !f.value || !h.length)
        return;
      const B = new IntersectionObserver(
        t,
        {
          root: Xe($),
          rootMargin: l,
          threshold: n
        }
      );
      h.forEach((v) => v && B.observe(v)), c = () => {
        B.disconnect(), c = Qe;
      };
    },
    { immediate: s, flush: "post" }
  ) : Qe, m = () => {
    c(), b(), f.value = !1;
  };
  return gt(m), {
    isSupported: i,
    isActive: f,
    pause() {
      c(), f.value = !1;
    },
    resume() {
      f.value = !0;
    },
    stop: m
  };
}
function De(e, t = {}) {
  const { initialValue: o = !1, focusVisible: a = !1 } = t, l = W(!1), n = w(() => Xe(e));
  Ne(n, "focus", (s) => {
    var i, u;
    (!a || (u = (i = s.target).matches) != null && u.call(i, ":focus-visible")) && (l.value = !0);
  }), Ne(n, "blur", () => l.value = !1);
  const r = w({
    get: () => l.value,
    set(s) {
      var i, u;
      !s && l.value ? (i = n.value) == null || i.blur() : s && !l.value && ((u = n.value) == null || u.focus());
    }
  });
  return ce(
    n,
    () => {
      r.value = o;
    },
    { immediate: !0, flush: "post" }
  ), { focused: r };
}
function _a(e) {
  return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e;
}
const _r = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function Vr(e = {}) {
  const {
    type: t = "page",
    touch: o = !0,
    resetOnTouchEnds: a = !1,
    initialValue: l = { x: 0, y: 0 },
    window: n = Ze,
    target: r = n,
    scroll: s = !0,
    eventFilter: i
  } = e;
  let u = null;
  const c = W(l.x), f = W(l.y), b = W(null), m = typeof t == "function" ? t : _r[t], h = (C) => {
    const T = m(C);
    u = C, T && ([c.value, f.value] = T, b.value = "mouse");
  }, $ = (C) => {
    if (C.touches.length > 0) {
      const T = m(C.touches[0]);
      T && ([c.value, f.value] = T, b.value = "touch");
    }
  }, B = () => {
    if (!u || !n)
      return;
    const C = m(u);
    u instanceof MouseEvent && C && (c.value = C[0] + n.scrollX, f.value = C[1] + n.scrollY);
  }, v = () => {
    c.value = l.x, f.value = l.y;
  }, S = i ? (C) => i(() => h(C), {}) : (C) => h(C), y = i ? (C) => i(() => $(C), {}) : (C) => $(C), _ = i ? () => i(() => B(), {}) : () => B();
  if (r) {
    const C = { passive: !0 };
    Ne(r, ["mousemove", "dragover"], S, C), o && t !== "movement" && (Ne(r, ["touchstart", "touchmove"], y, C), a && Ne(r, "touchend", v, C)), s && t === "page" && Ne(n, "scroll", _, { passive: !0 });
  }
  return {
    x: c,
    y: f,
    sourceType: b
  };
}
function Eo(e, t = {}) {
  const {
    handleOutside: o = !0,
    window: a = Ze
  } = t, l = t.type || "page", { x: n, y: r, sourceType: s } = Vr(t), i = W(e ?? (a == null ? void 0 : a.document.body)), u = W(0), c = W(0), f = W(0), b = W(0), m = W(0), h = W(0), $ = W(!0);
  let B = () => {
  };
  return a && (B = ce(
    [i, n, r],
    () => {
      const v = Xe(i);
      if (!v)
        return;
      const {
        left: S,
        top: y,
        width: _,
        height: C
      } = v.getBoundingClientRect();
      f.value = S + (l === "page" ? a.pageXOffset : 0), b.value = y + (l === "page" ? a.pageYOffset : 0), m.value = C, h.value = _;
      const T = n.value - f.value, k = r.value - b.value;
      $.value = _ === 0 || C === 0 || T < 0 || k < 0 || T > _ || k > C, (o || !$.value) && (u.value = T, c.value = k);
    },
    { immediate: !0 }
  ), Ne(document, "mouseleave", () => {
    $.value = !0;
  })), {
    x: n,
    y: r,
    sourceType: s,
    elementX: u,
    elementY: c,
    elementPositionX: f,
    elementPositionY: b,
    elementHeight: m,
    elementWidth: h,
    isOutside: $,
    stop: B
  };
}
function El(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const o = e.parentNode;
    return !o || o.tagName === "BODY" ? !1 : El(o);
  }
}
function Ar(e) {
  const t = e || window.event, o = t.target;
  return El(o) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);
}
const sa = /* @__PURE__ */ new WeakMap();
function Or(e, t = !1) {
  const o = W(t);
  let a = null, l;
  ce(_l(e), (s) => {
    const i = _a(Ye(s));
    if (i) {
      const u = i;
      sa.get(u) || sa.set(u, l), o.value && (u.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const n = () => {
    const s = _a(Ye(e));
    !s || o.value || (La && (a = Ne(
      s,
      "touchmove",
      (i) => {
        Ar(i);
      },
      { passive: !1 }
    )), s.style.overflow = "hidden", o.value = !0);
  }, r = () => {
    var s;
    const i = _a(Ye(e));
    !i || !o.value || (La && (a == null || a()), i.style.overflow = (s = sa.get(i)) != null ? s : "", sa.delete(i), o.value = !1);
  };
  return gt(r), w({
    get() {
      return o.value;
    },
    set(s) {
      s ? n() : r();
    }
  });
}
function Er(e, t = {}) {
  const {
    threshold: o = 50,
    onSwipe: a,
    onSwipeEnd: l,
    onSwipeStart: n,
    passive: r = !0,
    window: s = Ze
  } = t, i = yo({ x: 0, y: 0 }), u = yo({ x: 0, y: 0 }), c = w(() => i.x - u.x), f = w(() => i.y - u.y), { max: b, abs: m } = Math, h = w(() => b(m(c.value), m(f.value)) >= o), $ = W(!1), B = w(() => h.value ? m(c.value) > m(f.value) ? c.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none"), v = (V) => [V.touches[0].clientX, V.touches[0].clientY], S = (V, A) => {
    i.x = V, i.y = A;
  }, y = (V, A) => {
    u.x = V, u.y = A;
  };
  let _;
  const C = Pr(s == null ? void 0 : s.document);
  r ? _ = C ? { passive: !0 } : { capture: !1 } : _ = C ? { passive: !1, capture: !0 } : { capture: !0 };
  const T = (V) => {
    $.value && (l == null || l(V, B.value)), $.value = !1;
  }, k = [
    Ne(e, "touchstart", (V) => {
      if (V.touches.length !== 1)
        return;
      _.capture && !_.passive && V.preventDefault();
      const [A, E] = v(V);
      S(A, E), y(A, E), n == null || n(V);
    }, _),
    Ne(e, "touchmove", (V) => {
      if (V.touches.length !== 1)
        return;
      const [A, E] = v(V);
      y(A, E), !$.value && h.value && ($.value = !0), $.value && (a == null || a(V));
    }, _),
    Ne(e, ["touchend", "touchcancel"], T, _)
  ];
  return {
    isPassiveEventSupported: C,
    isSwiping: $,
    direction: B,
    coordsStart: i,
    coordsEnd: u,
    lengthX: c,
    lengthY: f,
    stop: () => k.forEach((V) => V())
  };
}
function Pr(e) {
  if (!e)
    return !1;
  let t = !1;
  const o = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", Qe, o), e.removeEventListener("x", Qe), t;
}
function _e(e, t, o, a = {}) {
  var l, n, r;
  const {
    clone: s = !1,
    passive: i = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: b
  } = a, m = Tt(), h = o || (m == null ? void 0 : m.emit) || ((l = m == null ? void 0 : m.$emit) == null ? void 0 : l.bind(m)) || ((r = (n = m == null ? void 0 : m.proxy) == null ? void 0 : n.$emit) == null ? void 0 : r.bind(m == null ? void 0 : m.proxy));
  let $ = u;
  t || (t = "modelValue"), $ = $ || `update:${t.toString()}`;
  const B = (y) => s ? typeof s == "function" ? s(y) : br(y) : y, v = () => er(e[t]) ? B(e[t]) : f, S = (y) => {
    b ? b(y) && h($, y) : h($, y);
  };
  if (i) {
    const y = v(), _ = W(y);
    let C = !1;
    return ce(
      () => e[t],
      (T) => {
        C || (C = !0, _.value = B(T), Fe(() => C = !1));
      }
    ), ce(
      _,
      (T) => {
        !C && (T !== e[t] || c) && S(T);
      },
      { deep: c }
    ), _;
  } else
    return w({
      get() {
        return v();
      },
      set(y) {
        S(y);
      }
    });
}
const Nr = ["id"], Ir = ["innerHTML"], Fr = ["innerHTML"], no = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BPopover",
  props: {
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: [Boolean, String], default: !1 },
    container: { default: void 0 },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    hide: { type: [Boolean, String], default: void 0 },
    html: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    inline: { type: [Boolean, String], default: !1 },
    manual: { type: [Boolean, String], default: !1 },
    modelValue: { type: [Boolean, String], default: !1 },
    noAutoClose: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noFlip: { type: [Boolean, String], default: !1 },
    noHide: { type: [Boolean, String], default: !1 },
    noShift: { type: [Boolean, String], default: !1 },
    noSize: { type: [Boolean, String], default: !1 },
    noninteractive: { type: [Boolean, String], default: !1 },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: [Boolean, String], default: !1 },
    realtime: { type: [Boolean, String], default: !1 },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  emits: ["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = d(() => a.modelValue), r = W(n.value), s = W(n.value);
    Yt(() => {
      l("update:modelValue", r.value);
    }), ce(n, () => {
      n.value !== r.value && (n.value ? pe() : ne(new Event("update:modelValue")));
    });
    const i = Pe(() => a.id, "popover"), u = d(() => a.click), c = d(() => a.manual), f = d(() => a.noShift), b = d(() => a.noSize), m = d(() => a.noFlip), h = d(() => a.noFade), $ = d(() => a.noAutoClose), B = d(() => a.noHide), v = d(() => a.realtime), S = d(() => a.inline), y = d(() => a.persistent), _ = d(() => a.tooltip), C = d(() => a.noninteractive), T = d(() => a.html), k = W(!1), N = W(null), V = W(null), A = W(null), E = W(null), K = W(null), oe = w(
      () => a.title ? It(a.title, Nt) : ""
    ), F = w(
      () => a.content ? It(a.content, Nt) : ""
    ), z = P(() => a.placement.startsWith("auto")), D = Se(() => a.offset ?? NaN), J = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), ie = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), te = W({}), he = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const x = a.offset !== null ? D.value : _.value ? 6 : 8, U = [dl(x)];
      return m.value === !1 && !z.value && U.push(
        Sl({
          boundary: J.value,
          rootBoundary: ie.value,
          padding: a.boundaryPadding
        })
      ), z.value && U.push(
        Ms({
          alignment: a.placement.split("-")[1] || void 0,
          boundary: J.value,
          rootBoundary: ie.value,
          padding: a.boundaryPadding
        })
      ), f.value === !1 && U.push(
        Bl({
          boundary: J.value,
          rootBoundary: ie.value,
          padding: a.boundaryPadding
        })
      ), B.value === !1 && U.push(
        Ds({
          boundary: J.value,
          rootBoundary: ie.value,
          padding: a.boundaryPadding
        })
      ), S.value === !0 && U.push(qs()), U.push(Us({ element: A, padding: 10 })), b.value === !1 && U.push(
        wl({
          boundary: J.value,
          rootBoundary: ie.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: re, availableHeight: Te }) {
            te.value = {
              maxHeight: Te ? `${Te}px` : void 0,
              maxWidth: re ? `${re}px` : void 0
            };
          }
        })
      ), U;
    }), Oe = P(
      () => z.value ? void 0 : a.placement
    ), { floatingStyles: ve, middlewareData: ge, placement: ke, update: Ce } = kl(V, N, {
      placement: Oe,
      middleware: he,
      strategy: P(() => a.strategy),
      whileElementsMounted: (...x) => hl(...x, { animationFrame: v.value })
    }), M = W({ position: "absolute" });
    ce(ge, () => {
      var x;
      if (B.value === !1 && ((x = ge.value.hide) != null && x.referenceHidden ? k.value = !0 : k.value = !1), ge.value.arrow) {
        const { x: U, y: re } = ge.value.arrow;
        M.value = {
          position: "absolute",
          top: re ? `${re}px` : "",
          left: U ? `${U}px` : ""
        };
      }
    });
    const X = w(() => {
      const x = _.value ? "tooltip" : "popover";
      return [
        x,
        `b-${x}`,
        {
          [`b-${x}-${a.variant}`]: a.variant !== null,
          show: r.value && !k.value,
          "pe-none": !r.value,
          fade: !h.value,
          "d-none": !r.value && h.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${x}-${zr(ke.value)}`]: ke.value !== void 0
        }
      ];
    }), { isOutside: L } = Eo(N), { isOutside: j } = Eo(E), Q = (x) => {
      const U = x ?? new Event("click");
      r.value ? ne(U) : pe();
    }, Z = (x, U = {}) => new Vt(x, {
      cancelable: !1,
      target: N.value || null,
      relatedTarget: null,
      trigger: null,
      ...U,
      componentId: i.value
    });
    let Y;
    const pe = () => {
      const x = Z("show", { cancelable: !0 });
      if (l("show", x), x.defaultPrevented) {
        l("show-prevented");
        return;
      }
      s.value = !0, Fe(() => {
        var U;
        Ce(), Y = setTimeout(
          () => {
            Ce(), r.value = !0, Fe(() => {
              l("shown", Z("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((U = a.delay) == null ? void 0 : U.show) || 0
        );
      });
    }, ne = (x) => {
      var Te;
      const U = Z("hide", { cancelable: !0 });
      if (l("hide", U), U.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      Y && (clearTimeout(Y), Y = void 0);
      const re = typeof a.delay == "number" ? a.delay : ((Te = a.delay) == null ? void 0 : Te.hide) || 0;
      setTimeout(() => {
        var $e, Ve;
        (x == null ? void 0 : x.type) === "click" || (x == null ? void 0 : x.type) === "forceHide" || (x == null ? void 0 : x.type) === "update:modelValue" && c.value || !C.value && L.value && j.value && !(($e = N.value) != null && $e.contains(document == null ? void 0 : document.activeElement)) && !((Ve = E.value) != null && Ve.contains(document == null ? void 0 : document.activeElement)) || C.value && j.value ? (r.value = !1, Fe(() => {
          setTimeout(
            () => {
              s.value = !1;
            },
            N.value ? Na(N.value) : 150
          ), l("hidden", Z("hidden"));
        })) : setTimeout(
          () => {
            ne(x);
          },
          re < 50 ? 50 : re
        );
      }, re);
    };
    t({
      hide: ne,
      show: pe,
      toggle: Q
    });
    const Be = () => {
      var x;
      if (a.target) {
        const U = Ct(a.target);
        U ? E.value = U : console.warn("Target element not found", a.target);
      } else
        E.value = (x = K.value) == null ? void 0 : x.nextElementSibling;
      if (a.reference) {
        const U = Ct(a.reference);
        U ? V.value = U : console.warn("Reference element not found", a.reference);
      } else
        V.value = E.value;
      if (!(!E.value || c.value) && Xa) {
        if (E.value.addEventListener("forceHide", ne), u.value) {
          E.value.addEventListener("click", Q);
          return;
        }
        E.value.addEventListener("pointerenter", pe), E.value.addEventListener("pointerleave", ne), E.value.addEventListener("focus", pe), E.value.addEventListener("blur", ne);
      }
    }, ue = () => {
      E.value && (E.value.removeEventListener("forceHide", ne), E.value.removeEventListener("click", Q), E.value.removeEventListener("pointerenter", pe), E.value.removeEventListener("pointerleave", ne), E.value.removeEventListener("focus", pe), E.value.removeEventListener("blur", ne));
    };
    return Ol(
      N,
      () => {
        r.value && u.value && !$.value && !c.value && ne(new Event("clickOutside"));
      },
      { ignore: [E] }
    ), ce([() => a.click, () => a.target, () => a.reference], () => {
      ue(), Be();
    }), at(Be), Ga(ue), (x, U) => (g(), I(me, null, [
      le("span", {
        ref_key: "placeholder",
        ref: K
      }, null, 512),
      O(x.$slots, "target", {
        show: pe,
        hide: ne,
        toggle: Q,
        showState: r.value
      }),
      (g(), H(_t, {
        to: x.container || "body",
        disabled: !x.container
      }, [
        s.value || p(y) ? (g(), I("div", ee({
          key: 0,
          id: x.id
        }, x.$attrs, {
          ref_key: "element",
          ref: N,
          class: X.value,
          role: "tooltip",
          tabindex: "-1",
          style: p(ve)
        }), [
          le("div", {
            ref_key: "arrow",
            ref: A,
            class: G(`${p(_) ? "tooltip" : "popover"}-arrow`),
            style: Me(M.value),
            "data-popper-arrow": ""
          }, null, 6),
          le("div", {
            class: "overflow-auto",
            style: Me(te.value)
          }, [
            x.title || x.$slots.title ? (g(), I(me, { key: 0 }, [
              p(T) ? (g(), I("div", {
                key: 1,
                class: G(["position-sticky top-0", p(_) ? "tooltip-inner" : "popover-header"]),
                innerHTML: oe.value
              }, null, 10, Ir)) : (g(), I("div", {
                key: 0,
                class: G(["position-sticky top-0", p(_) ? "tooltip-inner" : "popover-header"])
              }, [
                O(x.$slots, "title", {}, () => [
                  de(ae(x.title), 1)
                ])
              ], 2))
            ], 64)) : se("", !0),
            p(_) && !x.$slots.title && !x.title || !p(_) ? (g(), I(me, { key: 1 }, [
              p(T) ? (g(), I("div", {
                key: 1,
                class: G(p(_) ? "tooltip-inner" : "popover-body"),
                innerHTML: F.value
              }, null, 10, Fr)) : (g(), I("div", {
                key: 0,
                class: G(p(_) ? "tooltip-inner" : "popover-body")
              }, [
                O(x.$slots, "default", {}, () => [
                  de(ae(x.content), 1)
                ])
              ], 2))
            ], 64)) : se("", !0)
          ], 4)
        ], 16, Nr)) : se("", !0)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
}), Lr = ({
  top: e,
  end: t,
  start: o,
  alignCenter: a,
  alignEnd: l
}) => {
  const n = e ? "top" : o ? "left" : t ? "right" : "bottom", r = l ? "end" : a ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
}, zr = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, Kt = (e) => typeof e != "object" || e.active !== !1, ma = (e, t) => {
  if (!Kt(e))
    return {};
  const a = typeof e > "u" || typeof e == "object" && !e.title && !e.content, l = t.getAttribute("title") || t.getAttribute("data-original-title");
  return a ? l ? (t.removeAttribute("title"), t.setAttribute("data-original-title", l), {
    content: It(l, Nt)
  }) : {} : typeof e == "string" ? {
    content: It(e, Nt)
  } : {
    title: e != null && e.title ? It(e == null ? void 0 : e.title, Nt) : void 0,
    content: e != null && e.content ? It(e == null ? void 0 : e.content, Nt) : void 0
  };
}, zt = (e, t) => ({
  target: t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  persistent: e.modifiers.persistent,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  ...e.modifiers.interactive ? { noninteractive: !1 } : {},
  title: null,
  content: null
}), ga = (e, t) => {
  var a;
  const o = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(o) : t.modifiers.child ? e.appendChild(o) : (a = e.parentNode) == null || a.insertBefore(o, e.nextSibling), e.$__app = Rn({ render: () => {
    var l;
    return Re(no, { ...(l = e.$__state) == null ? void 0 : l.value });
  } }), e.$__app.mount(o), e.$__element = o;
}, Pl = (e) => {
  var o;
  const t = e.$__element;
  (o = e.$__app) == null || o.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
}, Nl = (e, t, o) => {
  const a = st(e, t);
  return o && typeof o == "function" ? o(a, t, e) : a;
}, Sa = (e, t, o) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, l) => (a[e ? `${e}${l.charAt(0).toUpperCase() + l.slice(1)}` : l] = o, a), {}), Il = (e, t, o, a = o) => Object.keys(t).reduce((l, n) => (e[n] && l.push(
  [a, n.replace(o, ""), e[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), l), []), Ct = (e) => {
  if (e)
    return typeof e == "string" ? typeof document > "u" ? void 0 : document.getElementById(e) ?? document.querySelector(e) ?? void 0 : e.$el ?? e;
}, Gt = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, Hr = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((o, a) => (typeof a.type == "symbol" ? o = o.concat(a.children) : o.push(a), o), []).filter((o) => {
  var a;
  return ((a = o.type) == null ? void 0 : a.__name) === t;
}), Va = (e) => e.replace(ol, " ").replace(ll, (t, o, a) => `${o} ${a}`).replace(Kn, (t, o, a) => o + a.toUpperCase()), Po = (e) => e.replace(ol, " ").replace(ll, (t, o, a) => `${o} ${a}`).replace(Xn, (t, o, a) => o + a.toUpperCase()), Rr = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, xr = (e) => e.replace(Jn, "\\$&"), Mr = (e) => xr(e).replace(Qn, "\\s"), ia = (e) => typeof e == "string" ? Po(e) : e.label !== void 0 ? e.label : typeof e.key == "string" ? Po(e.key) : e.key, Dr = (e) => !!(e.href || e.to), Fl = Symbol("carousel"), Ll = Symbol("tabs"), zl = Symbol("progress"), Hl = Symbol("listGroup"), Rl = Symbol("avatarGroup"), xl = Symbol("accordion"), Ml = Symbol("checkboxGroup"), Dl = Symbol("radioGroup"), so = Symbol("collapse"), jl = Symbol("collapse"), ro = Symbol("navbar"), ql = Symbol("toastPlugin"), Wl = Symbol("rtlPlugin"), Gl = Symbol("breadcrumbPlugin"), Ul = Symbol("modalControllerPlugin"), Xl = Symbol("modalManagerPlugin"), Wt = (e, t = {}, o = {}) => {
  const a = [e];
  let l;
  for (let n = 0; n < a.length && !l; n++) {
    const r = a[n];
    l = o[r];
  }
  return l && typeof l == "function" ? l(t) : l;
}, wa = (e, t) => Object.keys(e).filter((o) => !t.map((a) => a.toString()).includes(o)).reduce((o, a) => ({ ...o, [a]: e[a] }), {}), io = (e, t) => [...t].reduce(
  (o, a) => (o[a] = e[a], o),
  {}
), st = (e, t, o) => {
  const a = t.split(/[.[\]]/g);
  let l = e;
  for (const n of a) {
    if (l === null || l === void 0)
      return o;
    n.trim() !== "" && (l = l[n]);
  }
  return l === void 0 ? o : l;
}, No = (e, t) => {
  const { all: o, ...a } = e, l = {};
  o && t.forEach((r) => {
    l[r] = o;
  });
  const n = { ...l, ...a };
  return Object.entries(n).filter(([r, s]) => !!s && t.includes(r)).map(([r]) => r);
}, Io = (e, t) => t + (e ? Rr(e) : ""), At = (e, t) => {
  const o = P(t), a = P(e), l = P(() => Dr(a.value)), n = w(
    () => l.value ? io(
      a.value,
      o.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: l, computedLinkProps: n };
}, Kl = () => ({ ...ze(Gl) }), jr = (e = {}) => {
  const t = e.persist ?? !1, o = "data-bs-theme", a = "body";
  return kr({
    attribute: o,
    selector: a,
    storageKey: t === !0 ? `bv-color-${e.attribute ?? o}-${e.selector ?? a}` : null,
    ...e
  });
}, it = (e) => w(() => {
  let t = Le(e);
  return t = {
    ...t,
    variant: t.variant ?? null,
    bgVariant: t.bgVariant ?? null,
    textVariant: t.textVariant ?? null
  }, {
    [`text-bg-${t.variant}`]: t.variant !== null,
    [`text-${t.textVariant}`]: t.textVariant !== null && t.variant === null,
    [`bg-${t.bgVariant}`]: t.bgVariant !== null && t.variant === null
  };
}), qr = (e) => w(() => {
  const t = Le(e);
  return {
    container: t === !0,
    [`container-${t}`]: typeof t == "string"
  };
}), Yl = (e, t = W(1e3), o = {}) => {
  const a = Ue(P(e)), l = Ue(P(t)), n = W(!1), r = W(0), s = P(() => Math.ceil(a.value / l.value)), i = P(
    () => f.value || n.value ? Math.round(a.value - r.value * l.value) : 0
  ), { pause: u, resume: c, isActive: f } = Al(
    () => {
      r.value = r.value + 1;
    },
    t,
    o
  ), b = () => {
    n.value = !1, r.value = 0, c();
  }, m = () => {
    n.value = !1, r.value = s.value;
  };
  Yt(() => {
    r.value > s.value && (r.value = s.value), r.value === s.value && u();
  }), ce([l, a], () => {
    m(), b();
  });
  const h = () => {
    f.value !== !1 && (n.value = !0, u());
  }, $ = () => {
    r.value !== s.value && (n.value = !1, c());
  };
  return {
    isActive: Ue(f),
    isPaused: Ue(n),
    restart: b,
    stop: m,
    pause: h,
    resume: $,
    value: i
  };
}, Ot = (e) => w(() => {
  const t = Le(e);
  return t === !0 ? "is-valid" : t === !1 ? "is-invalid" : null;
}), Zl = (e) => w(() => {
  const t = Le(e);
  return {
    "form-check": t.plain === !1 && t.button === !1,
    "form-check-inline": t.inline === !0,
    "form-switch": t.switch === !0,
    [`form-control-${t.size}`]: t.size !== void 0 && t.size !== "md" && t.button === !1
  };
}), Jl = (e) => {
  const t = P(e), o = Ot(() => t.value.state ?? null);
  return w(() => [
    o.value,
    {
      "form-check-input": t.value.plain === !1 && t.value.button === !1,
      "btn-check": t.value.button === !0
    }
  ]);
}, Ql = (e) => w(() => {
  const t = Le(e);
  return {
    "form-check-label": t.plain === !1 && t.button === !1,
    btn: t.button === !0,
    [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,
    [`btn-${t.size}`]: t.button && t.size && t.size !== "md"
  };
}), en = (e) => {
  const t = P(e), o = ya(
    () => t.value.ariaInvalid,
    () => t.value.state
  );
  return w(() => ({
    "aria-invalid": o.value,
    "aria-required": t.value.required === !0 ? !0 : void 0
  }));
}, tn = (e) => w(() => {
  const t = Le(e);
  return {
    "was-validated": t.validated === !0,
    "btn-group": t.buttons === !0 && t.stacked === !1,
    "btn-group-vertical": t.stacked === !0 && t.buttons === !0,
    [`btn-group-${t.size}`]: t.size !== void 0
  };
}), Pe = (e, t) => w(() => Le(e) || Gt(t)), an = (e, t) => {
  const o = W(null), a = _e(e, "modelValue", t, { passive: !0 }), l = Pe(() => e.id, "input"), n = d(() => e.autofocus), r = d(() => e.disabled), s = d(() => e.lazy), i = d(() => e.lazyFormatter), u = d(() => e.number), c = d(() => e.state), f = d(() => e.trim), b = Se(() => e.debounce ?? 0), m = Se(() => e.debounceMaxWait ?? NaN), h = cr(
    (V) => {
      a.value = V;
    },
    () => s.value === !0 ? 0 : b.value,
    { maxWait: () => s.value === !0 ? NaN : m.value }
  ), $ = (V, A = !1) => {
    s.value === !0 && A === !1 || h(V);
  }, { focused: B } = De(o, {
    initialValue: n.value
  }), v = (V, A, E = !1) => e.formatter !== void 0 && (!i.value || E) ? e.formatter(V, A) : V, S = (V) => f.value ? V.trim() : u.value ? Number.parseFloat(V) : V;
  at(() => {
    var V;
    o.value && (o.value.value = ((V = a.value) == null ? void 0 : V.toString()) ?? "");
  }), xn(() => {
    Fe(() => {
      n.value && (B.value = !0);
    });
  });
  const y = ya(() => e.ariaInvalid, c);
  return {
    input: o,
    computedId: l,
    computedAriaInvalid: y,
    onInput: (V) => {
      const { value: A } = V.target, E = v(A, V);
      if (V.defaultPrevented) {
        V.preventDefault();
        return;
      }
      const K = S(E);
      $(K);
    },
    onChange: (V) => {
      const { value: A } = V.target, E = v(A, V);
      if (V.defaultPrevented) {
        V.preventDefault();
        return;
      }
      const K = S(E);
      a.value !== K && $(E, !0);
    },
    onBlur: (V) => {
      if (!s.value && !i.value)
        return;
      const { value: A } = V.target, E = v(A, V, !0), K = S(E);
      a.value !== K && $(E, !0);
    },
    focus: () => {
      r.value || (B.value = !0);
    },
    blur: () => {
      r.value || (B.value = !1);
    }
  };
}, on = (e, t) => {
  const o = (r) => typeof r == "object" && r !== null && "label" in r, a = (r) => {
    if (typeof r == "string")
      return { value: r, text: r };
    const s = st(r, t.valueField), i = st(r, t.textField), u = st(r, t.htmlField), c = st(r, t.disabledField), f = t.optionsField ? st(r, t.optionsField) : void 0;
    return f !== void 0 ? {
      label: st(r, t.labelField) || i,
      options: f
    } : {
      value: s,
      text: i,
      html: u,
      disabled: c
    };
  }, l = (r) => r.map((s) => a(s));
  return { normalizedOptions: w(() => l(Le(e))), isComplex: o };
}, Aa = "modal-open", uo = () => {
  const e = ze(Xl), t = (a) => {
    e == null || e.removeStack(a), e == null || e.removeRegistry(a);
  }, o = oo("updateHTMLAttrs", (a, l, n) => {
    const r = typeof a == "string" ? window == null ? void 0 : window.document.querySelector(a) : Xe(a);
    r && (l === "class" ? r.classList.toggle(Aa, n === Aa) : r.setAttribute(l, n));
  });
  return gt(() => {
    o("body", "class", "");
  }), ce(
    () => e == null ? void 0 : e.countStack.value,
    (a) => {
      a !== void 0 && o("body", "class", a > 0 ? Aa : "");
    }
  ), {
    ...e,
    dispose: t
  };
}, Wr = (e) => {
  const { pushRegistry: t, pushStack: o, removeStack: a, stack: l, dispose: n, countStack: r } = uo(), s = Tt();
  if (!s || s.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  return t == null || t(s), gt(() => {
    n(s);
  }), ce(
    e,
    (i, u) => {
      i ? o == null || o(s) : u && !i && (a == null || a(s));
    },
    { immediate: !0 }
  ), {
    activePosition: w(
      () => l == null ? void 0 : l.value.findIndex((i) => {
        var u, c;
        return ((u = i.exposed) == null ? void 0 : u.id) === ((c = s.exposed) == null ? void 0 : c.id);
      })
    ),
    activeModalCount: r
  };
}, Gr = (e = void 0) => {
  const { registry: t } = uo(), o = Tt(), a = (r) => r.parent ? r.parent.type.__name === "BModal" ? r.parent : a(r.parent) : null, l = w(() => {
    const r = Le(e);
    return r ? (t == null ? void 0 : t.value.find((s) => {
      var i;
      return ((i = s.exposed) == null ? void 0 : i.id.value) === r;
    })) || null : o ? a(o) : null;
  }), n = P(() => {
    var r;
    return (r = l.value) == null ? void 0 : r.proxy;
  });
  return {
    show() {
      var r, s;
      (s = (r = l.value) == null ? void 0 : r.exposed) == null || s.show();
    },
    hide(r = "") {
      var s, i;
      (i = (s = l.value) == null ? void 0 : s.exposed) == null || i.hide(r);
    },
    modal: n
  };
}, ln = () => {
  const { lastStack: e, stack: t } = uo();
  return {
    ...ze(Ul),
    hide: (n = "") => {
      var r;
      e != null && e.value && ((r = e == null ? void 0 : e.value.exposed) == null || r.hide(n));
    },
    hideAll: (n = "") => {
      t == null || t.value.forEach((r) => {
        var s;
        (s = r.exposed) == null || s.hide(n);
      });
    }
    // Todo: Supports listening events globally in the future
  };
}, co = (e) => {
  const t = (i, u) => {
    const c = u === null ? "" : `${u}-`;
    return i === "circle" ? `${c}rounded-circle` : i === "pill" ? `${c}rounded-pill` : typeof i == "number" || i === "0" || i === "1" || i === "2" || i === "3" || i === "4" || i === "5" ? `${c}rounded-${i}` : i === "none" ? `${c}rounded-0` : i === "sm" ? `${c}rounded-1` : i === "lg" ? `${c}rounded-5` : `${c}rounded`;
  }, o = Ue(P(e)), a = d(() => o.value.rounded), l = d(() => o.value.roundedTop), n = d(() => o.value.roundedBottom), r = d(() => o.value.roundedStart), s = d(() => o.value.roundedEnd);
  return w(() => ({
    [`${t(a.value, null)}`]: !!a.value,
    [`${t(l.value, "top")}`]: !!l.value,
    [`${t(n.value, "bottom")}`]: !!n.value,
    [`${t(r.value, "start")}`]: !!r.value,
    [`${t(s.value, "end")}`]: !!s.value
  }));
}, Ur = () => {
  const e = ze(Wl);
  return at(() => {
    ce(
      [() => e == null ? void 0 : e.isRtl.value, () => e == null ? void 0 : e.locale.value],
      ([t, o]) => {
        const a = document.documentElement;
        a.setAttribute("dir", t ?? !1 ? "rtl" : "ltr"), a.setAttribute("lang", o ?? "");
      },
      { immediate: !0 }
    );
  }), { ...e };
}, nn = (e, t) => {
  const o = Ue(P(e)), a = Ue(P(t)), l = P(() => !a.value);
  at(() => {
    const n = Or(
      document.body,
      o.value && l.value
    );
    ce([o, l], ([r, s]) => {
      n.value = r && s;
    });
  });
}, sn = (e, t, o = {}) => {
  const a = P(e), l = P(t), n = W(Ct(a.value)), r = W(Ct(l.value));
  ce([a, l], () => {
    S();
  });
  const {
    contentQuery: s = ":scope > [id]",
    targetQuery: i = "[href]",
    manual: u = !1,
    root: c,
    rootMargin: f = "0px 0px -25%",
    threshold: b = [0.1, 0.5, 1],
    watchChanges: m = !0
  } = o, h = W(null), $ = W([]), B = W([]);
  Tt() ? at(() => {
    Ha(a, n, {
      transform: {
        ltr: (A) => Ct(A)
      },
      direction: "ltr",
      immediate: !0
    }), Ha(l, r, {
      transform: {
        ltr: (A) => Ct(A)
      },
      direction: "ltr",
      immediate: !0
    }), S();
  }) : Fe(() => {
    S();
  });
  const S = () => {
    B.value = n.value ? Array.from(n.value.querySelectorAll(s)) : [], $.value = B.value.map((A) => ({
      id: A.id,
      el: A,
      visible: !1,
      text: A.textContent
    }));
  };
  let y = !0, _ = 0;
  const C = w(
    () => n.value && getComputedStyle(n.value).overflowY === "visible" ? null : n.value
  ), T = Tr(
    B,
    (A) => {
      var oe, F, z, D;
      const E = (oe = C.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : oe.scrollTop;
      y = E > _, _ = E, A.forEach((J) => {
        if (J.isIntersecting) {
          $.value.forEach((ie) => {
            ie.el === J.target && (ie.visible = !0);
          });
          return;
        }
        $.value.forEach((ie) => {
          ie.el === J.target && (ie.visible = !1);
        });
      });
      let K = null;
      y ? K = ((F = [...$.value].reverse().find((J) => J.visible)) == null ? void 0 : F.id) || null : K = ((z = $.value.find((J) => J.visible)) == null ? void 0 : z.id) || null, K !== null && (h.value = K), h.value || (h.value = ((D = $.value[0]) == null ? void 0 : D.id) || null);
    },
    {
      root: c ? Ct(c) : C,
      rootMargin: f,
      threshold: b
    }
  );
  ce(h, (A) => {
    var F;
    if (u)
      return;
    const E = (F = r.value) == null ? void 0 : F.querySelectorAll(i);
    if (E === void 0)
      return;
    let K = !1, oe = null;
    E.forEach((z) => {
      var J, ie, te, he, Oe, ve, ge, ke, Ce, M, X;
      const D = z.closest(".dropdown");
      if ((J = z.getAttribute("href")) != null && J.includes(`#${A}`)) {
        oe = z, z.classList.add("active"), D && ((ie = D == null ? void 0 : D.querySelector(".dropdown-toggle")) == null || ie.classList.add("active"), K = !0);
        let L = (te = z.closest(".nav")) == null ? void 0 : te.previousSibling;
        for (; (he = L == null ? void 0 : L.classList) != null && he.contains("nav-item"); )
          K = !0, (Oe = L.querySelector(".nav-link")) == null || Oe.classList.add("active"), L = (ve = L.closest(".nav")) == null ? void 0 : ve.previousSibling;
      } else if (z.classList.remove("active"), D && !K && ((ge = D == null ? void 0 : D.querySelector(".dropdown-toggle")) == null || ge.classList.remove("active")), !K) {
        let L = (ke = z.closest(".nav")) == null ? void 0 : ke.previousSibling;
        for (; (Ce = L == null ? void 0 : L.classList) != null && Ce.contains("nav-item"); )
          K = !0, L.querySelector(".nav-link") !== oe && ((M = L.querySelector(".nav-link")) == null || M.classList.remove("active")), L = (X = L.closest(".nav")) == null ? void 0 : X.previousSibling;
      }
    });
  });
  const k = m ? $r(
    n,
    () => {
      S();
    },
    {
      childList: !0
    }
  ) : { stop: () => {
  } }, N = (A, E = !1) => {
    var F, z;
    A.preventDefault();
    const K = (z = (F = A.target) == null ? void 0 : F.getAttribute) == null ? void 0 : z.call(F, "href"), oe = K ? document == null ? void 0 : document.querySelector(K) : null;
    oe && n.value && (n.value.scrollTo ? n.value.scrollTo({ top: oe.offsetTop, behavior: E ? "smooth" : "auto" }) : n.value.scrollTop = oe.offsetTop);
  }, V = () => {
    T.stop(), k.stop();
  };
  return {
    current: Ue(h),
    list: $,
    content: n,
    target: r,
    scrollIntoView: N,
    updateList: S,
    cleanup: V
  };
}, rn = () => ({ ...ze(ql) }), Dt = /* @__PURE__ */ q({
  __name: "BTransition",
  props: {
    appear: { type: [Boolean, String], default: !1 },
    mode: { default: void 0 },
    noFade: { type: [Boolean, String], default: !1 },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.appear), n = d(() => o.noFade), r = w(() => {
      const i = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, u = {
        ...i,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return n.value ? i : u;
    }), s = w(() => ({ mode: o.mode, css: !0, ...r.value }));
    return (i, u) => (g(), H(Mn, ee({ ...s.value, ...i.transProps }, {
      appear: p(l),
      onAfterAppear: u[0] || (u[0] = (c) => a("after-appear", c)),
      onAfterEnter: u[1] || (u[1] = (c) => a("after-enter", c)),
      onAfterLeave: u[2] || (u[2] = (c) => a("after-leave", c)),
      onAppear: u[3] || (u[3] = (c) => a("appear", c)),
      onBeforeAppear: u[4] || (u[4] = (c) => a("before-appear", c)),
      onBeforeEnter: u[5] || (u[5] = (c) => a("before-enter", c)),
      onBeforeLeave: u[6] || (u[6] = (c) => a("before-leave", c)),
      onEnter: u[7] || (u[7] = (c) => a("enter", c)),
      onAppearCancelled: u[8] || (u[8] = (c) => a("appear-cancelled", c)),
      onEnterCancelled: u[9] || (u[9] = (c) => a("enter-cancelled", c)),
      onLeave: u[10] || (u[10] = (c) => a("leave", c)),
      onLeaveCancelled: u[11] || (u[11] = (c) => a("leave-cancelled", c))
    }), {
      default: R(() => [
        O(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
}), Xr = ["type", "disabled", "aria-label"], jt = /* @__PURE__ */ q({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: [Boolean, String], default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.disabled);
    return (n, r) => (g(), I("button", {
      type: n.type,
      class: "btn-close",
      disabled: p(l),
      "aria-label": n.ariaLabel,
      onClick: r[0] || (r[0] = (s) => a("click", s))
    }, null, 8, Xr));
  }
}), Fo = "active", ft = /* @__PURE__ */ q({
  __name: "BLink",
  props: {
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = Zt(), n = d(() => o.active), r = d(() => o.icon);
    d(() => o.append);
    const s = d(() => o.disabled);
    d(() => o.replace);
    const i = ze(so, null), u = ze(ro, null), c = Tt(), f = w(() => {
      const v = o.routerComponentName.split("-").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join("");
      return !((c == null ? void 0 : c.appContext.app.component(v)) !== void 0) || s.value || !o.to ? "a" : o.routerComponentName;
    }), b = w(() => {
      const v = "#";
      if (o.href)
        return o.href;
      if (typeof o.to == "string")
        return o.to || v;
      const { to: S } = o;
      if (S !== void 0 && "path" in S) {
        const y = S.path || "", _ = S.query ? `?${Object.keys(S.query).map((T) => {
          var k;
          return `${T}=${(k = S.query) == null ? void 0 : k[T]}`;
        }).join("=")}` : "", C = !S.hash || S.hash.charAt(0) === "#" ? S.hash || "" : `#${S.hash}`;
        return `${y}${_}${C}` || v;
      }
      return v;
    }), m = w(() => ({
      [`link-${o.variant}`]: o.variant !== null,
      [`link-opacity-${o.opacity}`]: o.opacity !== void 0,
      [`link-opacity-${o.opacityHover}-hover`]: o.opacityHover !== void 0,
      [`link-underline-${o.underlineVariant}`]: o.underlineVariant !== null,
      [`link-offset-${o.underlineOffset}`]: o.underlineOffset !== void 0,
      [`link-offset-${o.underlineOffsetHover}-hover`]: o.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${o.underlineOpacity}`]: o.underlineOpacity !== void 0,
      [`link-underline-opacity-${o.underlineOpacityHover}-hover`]: o.underlineOpacityHover !== void 0,
      "icon-link": r.value === !0
    })), h = w(() => ({
      class: m.value,
      to: o.to,
      href: b.value,
      target: o.target,
      rel: o.target === "_blank" ? o.rel ?? "noopener" : void 0,
      tabindex: s.value ? "-1" : typeof l.tabindex > "u" ? null : l.tabindex,
      "aria-disabled": s.value ? !0 : null
    })), $ = w(() => ({
      [Fo]: n.value,
      disabled: s.value
    })), B = (v) => {
      var S, y, _;
      if (s.value) {
        v.preventDefault(), v.stopImmediatePropagation();
        return;
      }
      (((S = i == null ? void 0 : i.isNav) == null ? void 0 : S.value) === !0 && u === null || u !== null && ((y = u.autoClose) == null ? void 0 : y.value) === !0) && ((_ = i == null ? void 0 : i.close) == null || _.call(i)), a("click", v);
    };
    return (v, S) => f.value === "router-link" ? (g(), H(fe(f.value), ee({ key: 0 }, h.value, { custom: "" }), {
      default: R(({ href: y, navigate: _, isActive: C, isExactActive: T }) => [
        (g(), H(fe(v.routerTag), ee({
          href: y,
          class: {
            [Fo]: p(n),
            [v.activeClass]: C,
            [v.exactActiveClass]: T
          }
        }, v.$attrs, {
          onClick: (k) => {
            _(k), B(k);
          }
        }), {
          default: R(() => [
            O(v.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (g(), H(fe(f.value), ee({
      key: 1,
      class: $.value
    }, h.value, { onClick: B }), {
      default: R(() => [
        O(v.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Kr = ["aria-valuenow", "aria-valuemax"], un = /* @__PURE__ */ q({
  __name: "BProgressBar",
  props: {
    animated: { type: [Boolean, String], default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: [Boolean, String], default: !1 },
    showValue: { type: [Boolean, String], default: !1 },
    striped: { type: [Boolean, String], default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, o = ze(zl, null), a = d(() => t.animated), l = d(() => t.showProgress), n = d(() => t.showValue), r = d(() => t.striped), s = it(t), i = w(() => [
      s.value,
      {
        "progress-bar-animated": a.value || (o == null ? void 0 : o.animated.value),
        "progress-bar-striped": r.value || (o == null ? void 0 : o.striped.value) || a.value || (o == null ? void 0 : o.animated.value)
      }
    ]), u = Se(() => t.precision), c = Se(() => t.value), f = Se(() => t.max ?? NaN), b = Se(() => (o == null ? void 0 : o.max.value) ?? NaN), m = w(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || o != null && o.showValue.value ? c.value.toFixed(u.value) : l.value || o != null && o.showProgress.value ? (c.value * 100 / (f.value || 100)).toFixed(u.value) : t.label !== void 0 ? t.label : ""
    ), h = w(
      () => b.value ? `${c.value * 100 / b.value}%` : f.value ? `${c.value * 100 / f.value}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return ($, B) => (g(), I("div", {
      class: G(["progress-bar", i.value]),
      role: "progressbar",
      "aria-valuenow": $.value,
      "aria-valuemin": "0",
      "aria-valuemax": $.max,
      style: Me({ width: h.value })
    }, [
      O($.$slots, "default", {}, () => [
        de(ae(m.value), 1)
      ])
    ], 14, Kr));
  }
}), dn = /* @__PURE__ */ q({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: [Boolean, String], default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: [Boolean, String], default: void 0 },
    showValue: { type: [Boolean, String], default: void 0 },
    striped: { type: [Boolean, String], default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.animated), a = d(() => t.showProgress), l = d(() => t.showValue), n = d(() => t.striped);
    return dt(zl, {
      animated: o,
      max: P(() => t.max),
      showProgress: a,
      showValue: l,
      striped: n
    }), (r, s) => (g(), I("div", {
      class: "progress",
      style: Me({ height: r.height })
    }, [
      O(r.$slots, "default", {}, () => [
        ye(un, {
          animated: r.animated,
          max: r.max,
          precision: r.precision,
          "show-progress": r.showProgress,
          "show-value": r.showValue,
          striped: r.striped,
          value: r.value,
          variant: r.variant,
          "text-variant": r.textVariant,
          "bg-variant": r.bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), Yr = ["id", "role", "aria-live", "aria-atomic"], Zr = { class: "me-auto" }, cn = /* @__PURE__ */ q({
  __name: "BToast",
  props: {
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: [Boolean, String], default: !1 },
    modelValue: { type: [Boolean, Number], default: !1 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    progressProps: { default: void 0 },
    showOnPause: { type: [Boolean, String], default: !0 },
    solid: { type: [Boolean, String], default: !1 },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  },
  emits: ["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = W(null), r = lo(n), s = _e(a, "modelValue", l, { passive: !0 }), { computedLink: i, computedLinkProps: u } = At(a), c = d(() => a.isStatus), f = d(() => a.noCloseButton), b = d(() => a.noFade), m = d(() => a.noHoverPause), h = d(() => a.showOnPause), $ = Se(() => a.interval);
    d(() => a.solid);
    const B = it(a), v = P(() => typeof s.value == "boolean" ? 0 : s.value), {
      isActive: S,
      pause: y,
      restart: _,
      resume: C,
      stop: T,
      isPaused: k,
      value: N
    } = Yl(v, $, {
      immediate: typeof s.value == "number"
    });
    Yt(() => {
      l("close-countdown", N.value);
    });
    const V = P(() => i.value ? ft : "div"), A = P(
      () => typeof s.value == "boolean" ? s.value : S.value || h.value && k.value
    ), E = w(() => [
      B.value,
      {
        show: A.value
      }
    ]), K = () => {
      m.value || y();
    };
    ce(r, (te) => {
      if (te) {
        K();
        return;
      }
      C();
    });
    const oe = (te, he = {}) => new Vt(te, {
      cancelable: !1,
      target: n.value || null,
      relatedTarget: null,
      trigger: null,
      ...he,
      componentId: a.id
    }), F = () => {
      const te = oe("show", { cancelable: !0 });
      if (l("show", te), te.defaultPrevented) {
        s.value && (s.value = !1), l("show-prevented");
        return;
      }
      s.value || (s.value = !0);
    }, z = (te = "") => {
      const he = oe("hide", { cancelable: te !== "", trigger: te });
      if (l("hide", he), te === "close" && l("close", he), he.defaultPrevented) {
        l("hide-prevented"), s.value || (s.value = !0);
        return;
      }
      typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, T());
    }, D = () => {
      F();
    }, J = () => {
      l("shown", oe("shown"));
    }, ie = () => {
      l("hidden", oe("hidden"));
    };
    return ce(S, (te) => {
      te === !1 && k.value === !1 && s.value && z();
    }), Ga(T), t({
      pause: y,
      restart: _,
      resume: C,
      stop: T
    }), (te, he) => (g(), H(Dt, ee({ "no-fade": p(b) }, te.transProps, {
      onBeforeEnter: D,
      onAfterEnter: J,
      onAfterLeave: ie
    }), {
      default: R(() => [
        A.value ? (g(), I("div", {
          key: 0,
          id: te.id,
          ref_key: "element",
          ref: n,
          class: G(["toast", [te.toastClass, E.value]]),
          tabindex: "0",
          role: A.value ? p(c) ? "status" : "alert" : void 0,
          "aria-live": A.value ? p(c) ? "polite" : "assertive" : void 0,
          "aria-atomic": A.value ? !0 : void 0
        }, [
          te.$slots.title || te.title ? (g(), H(fe(te.headerTag), {
            key: 0,
            class: "toast-header"
          }, {
            default: R(() => [
              O(te.$slots, "title", { hide: z }, () => [
                le("strong", Zr, ae(te.title), 1)
              ]),
              p(f) ? se("", !0) : (g(), H(jt, {
                key: 0,
                onClick: he[0] || (he[0] = (Oe) => z("close"))
              }))
            ]),
            _: 3
          })) : se("", !0),
          te.$slots.default || te.body ? (g(), H(fe(V.value), ee({
            key: 1,
            class: ["toast-body", te.bodyClass],
            style: { display: "block" }
          }, p(u), {
            onClick: he[1] || (he[1] = (Oe) => p(i) ? z() : () => {
            })
          }), {
            default: R(() => [
              O(te.$slots, "default", { hide: z }, () => [
                de(ae(te.body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : se("", !0),
          typeof p(s) == "number" && te.progressProps !== void 0 ? (g(), H(dn, {
            key: 2,
            animated: te.progressProps.animated,
            precision: te.progressProps.precision,
            "show-progress": te.progressProps.showProgress,
            "show-value": te.progressProps.showValue,
            striped: te.progressProps.striped,
            variant: te.progressProps.variant,
            max: p(s),
            value: p(N),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : se("", !0)
        ], 10, Yr)) : se("", !0)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
}), Jr = "top-right", Qr = {
  install(e) {
    const t = kt([]), o = W(!1), a = (r) => {
      o.value = r;
    }, l = (r) => {
      const s = Symbol(), i = w(() => {
        const u = Le(r.props);
        return {
          component: Le(r.component) ?? cn,
          props: {
            ...u,
            pos: (u == null ? void 0 : u.pos) || Jr,
            _modelValue: (u == null ? void 0 : u.value) || 5e3,
            _self: s
          }
        };
      });
      return (i.value.props.appendToast !== void 0 ? i.value.props.appendToast : o.value) ? t.value = [...t.value, i] : t.value = [i, ...t.value], s;
    }, n = (r) => {
      t.value = t.value.filter((s) => s.value.props._self !== r);
    };
    e.provide(ql, {
      _setIsAppend: a,
      toasts: t,
      show: l,
      remove: n
    });
  }
}, ei = {
  install(e) {
    const t = W([]), o = () => {
      t.value.splice(0, t.value.length);
    };
    e.provide(Gl, { items: t, reset: o });
  }
}, ti = {
  key: 0,
  class: "visually-hidden"
}, Ca = /* @__PURE__ */ q({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: [Boolean, String], default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = je(), a = d(() => t.small), l = w(() => [
      `spinner-${t.type}`,
      {
        [`spinner-${t.type}-sm`]: a.value,
        [`text-${t.variant}`]: t.variant !== null
      }
    ]), n = P(() => !He(o.label));
    return (r, s) => (g(), H(fe(r.tag), {
      class: G(l.value),
      role: r.label || n.value ? r.role : null,
      "aria-hidden": r.label || n.value ? null : !0
    }, {
      default: R(() => [
        r.label || n.value ? (g(), I("span", ti, [
          O(r.$slots, "label", {}, () => [
            de(ae(r.label), 1)
          ])
        ])) : se("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), Bt = /* @__PURE__ */ q({
  __name: "BButton",
  props: {
    loading: { type: [Boolean, String], default: !1 },
    loadingFill: { type: [Boolean, String], default: !1 },
    loadingText: { default: "Loading..." },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: void 0 },
    size: { default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: [Boolean, String], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = _e(o, "pressed", a), n = d(() => o.active), r = d(() => o.disabled), s = d(() => o.pill), i = d(() => o.pressed), u = d(() => o.squared), c = d(() => o.loading), f = d(() => o.loadingFill), { computedLink: b, computedLinkProps: m } = At(o, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), h = P(() => typeof i.value == "boolean"), $ = P(
      () => o.tag === "button" && o.href === void 0 && o.to === void 0
    ), B = P(() => o.to !== void 0), v = P(() => o.href !== void 0 ? !1 : !$.value), S = w(() => B.value ? m.value : []), y = w(() => [
      [`btn-${o.size}`],
      {
        [`btn-${o.variant}`]: o.variant !== null,
        active: n.value || i.value,
        "rounded-pill": s.value,
        "rounded-0": u.value,
        disabled: r.value
      }
    ]), _ = P(() => B.value ? ft : o.href ? "a" : o.tag), C = (T) => {
      if (r.value) {
        T.preventDefault(), T.stopPropagation();
        return;
      }
      a("click", T), h.value && (l.value = !i.value);
    };
    return (T, k) => (g(), H(fe(_.value), ee({ class: "btn" }, S.value, {
      class: y.value,
      "aria-disabled": v.value ? p(r) : null,
      "aria-pressed": h.value ? p(i) : null,
      autocomplete: h.value ? "off" : null,
      disabled: $.value ? p(r) : null,
      href: T.href,
      rel: p(b) ? T.rel : null,
      role: v.value || p(b) ? "button" : null,
      target: p(b) ? T.target : null,
      type: $.value ? T.type : null,
      to: $.value ? null : T.to,
      append: p(b) ? T.append : null,
      onClick: C
    }), {
      default: R(() => [
        p(c) ? O(T.$slots, "loading", { key: 0 }, () => [
          p(f) ? se("", !0) : (g(), I(me, { key: 0 }, [
            de(ae(T.loadingText), 1)
          ], 64)),
          O(T.$slots, "loading-spinner", {}, () => [
            ye(Ca, {
              small: T.size !== "lg",
              label: p(f) ? T.loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : O(T.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to", "append"]));
  }
}), ka = /* @__PURE__ */ q({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: [Boolean, String], default: !1 },
    noCenter: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noSpinner: { type: [Boolean, String], default: !1 },
    noWrap: { type: [Boolean, String], default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: [Boolean, String], default: !1 },
    spinnerSmall: { type: [Boolean, String], default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [String, Number, Boolean], default: !1 },
    roundedTop: { type: [String, Number, Boolean], default: void 0 },
    roundedBottom: { type: [String, Number, Boolean], default: void 0 },
    roundedStart: { type: [String, Number, Boolean], default: void 0 },
    roundedEnd: { type: [String, Number, Boolean], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = { top: 0, left: 0, bottom: 0, right: 0 }, n = d(() => o.fixed), r = d(() => o.noSpinner), s = d(() => o.noCenter), i = d(() => o.noWrap), u = d(() => o.show), c = d(() => o.spinnerSmall), f = d(() => o.rounded), b = d(() => o.roundedTop), m = d(() => o.roundedBottom), h = d(() => o.roundedStart), $ = d(() => o.roundedEnd), B = co(() => ({
      rounded: f.value,
      roundedTop: b.value,
      roundedBottom: m.value,
      roundedStart: h.value,
      roundedEnd: $.value
    })), v = P(
      () => o.variant !== null && !o.bgColor ? `bg-${o.variant}` : ""
    ), S = P(() => u.value ? !0 : null), y = w(() => ({
      type: o.spinnerType,
      variant: o.spinnerVariant,
      small: c.value
    })), _ = w(() => ({
      ...l,
      zIndex: o.zIndex || 10
    })), C = w(() => ({
      "position-absolute": !i.value || !n.value,
      "position-fixed": i.value && n.value
    })), T = w(() => [v.value, B.value]), k = w(() => ({
      ...l,
      opacity: o.opacity,
      backgroundColor: o.bgColor || void 0,
      backdropFilter: o.blur ? `blur(${o.blur})` : void 0
    })), N = w(
      () => s.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (V, A) => (g(), H(fe(V.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": S.value
    }, {
      default: R(() => [
        O(V.$slots, "default"),
        ye(Dt, {
          "no-fade": V.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: A[1] || (A[1] = (E) => a("shown")),
          onAfterLeave: A[2] || (A[2] = (E) => a("hidden"))
        }, {
          default: R(() => [
            p(u) ? (g(), H(fe(V.overlayTag), {
              key: 0,
              class: G(["b-overlay", C.value]),
              style: Me(_.value),
              onClick: A[0] || (A[0] = (E) => a("click", E))
            }, {
              default: R(() => [
                le("div", {
                  class: G(["position-absolute", T.value]),
                  style: Me(k.value)
                }, null, 6),
                le("div", {
                  class: "position-absolute",
                  style: Me(N.value)
                }, [
                  O(V.$slots, "overlay", we(Ae(y.value)), () => [
                    p(r) ? se("", !0) : (g(), H(Ca, we(ee({ key: 0 }, y.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : se("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), ai = ["id", "aria-labelledby", "aria-describedby"], oi = ["id"], Lo = 1056, li = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BModal",
  props: {
    autoFocus: { type: [Boolean, String], default: !0 },
    autoFocusButton: { default: void 0 },
    body: { default: void 0 },
    backdropVariant: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: [Boolean, String], default: !1 },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: [Boolean, String], default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: [Boolean, String], default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: [Boolean, String], default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: [Boolean, String], default: !1 },
    hideFooter: { type: [Boolean, String], default: !1 },
    hideHeader: { type: [Boolean, String], default: !1 },
    hideHeaderClose: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    lazy: { type: [Boolean, String], default: !1 },
    modalClass: { default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    noCloseOnBackdrop: { type: [Boolean, String], default: !1 },
    noCloseOnEsc: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    okDisabled: { type: [Boolean, String], default: !1 },
    okOnly: { type: [Boolean, String], default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: [Boolean, String], default: !1 },
    size: { default: "md" },
    teleportDisabled: { type: [Boolean, String], default: !1 },
    teleportTo: { default: "body" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: [Boolean, String], default: !1 },
    titleTag: { default: "h5" },
    transProps: { default: void 0 }
  },
  emits: ["cancel", "close", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = Pe(() => a.id, "modal"), s = _e(a, "modelValue", l, { passive: !0 }), i = d(() => a.busy), u = d(() => a.lazy), c = d(() => a.cancelDisabled), f = d(() => a.centered), b = d(() => a.hideBackdrop), m = d(() => a.hideFooter), h = d(() => a.hideHeader), $ = d(() => a.hideHeaderClose), B = d(s), v = d(() => a.noCloseOnBackdrop), S = d(() => a.noCloseOnEsc), y = d(() => a.noFade), _ = d(() => a.autoFocus), C = d(() => a.okDisabled), T = d(() => a.okOnly), k = d(() => a.scrollable), N = d(() => a.titleSrOnly), V = d(() => a.teleportDisabled), A = d(() => a.bodyScrolling), E = d(() => a.fullscreen), K = W(null), oe = W(null), F = W(null), z = W(null), D = W(B.value), J = W(!1);
    Ge(
      "Escape",
      () => {
        U("esc");
      },
      { target: K }
    ), nn(B, A);
    const { focused: ie } = De(K, {
      initialValue: B.value && a.autoFocusButton === void 0
    }), { focused: te } = De(oe, {
      initialValue: B.value && a.autoFocusButton === "ok"
    }), { focused: he } = De(F, {
      initialValue: B.value && a.autoFocusButton === "cancel"
    }), { focused: Oe } = De(z, {
      initialValue: B.value && a.autoFocusButton === "close"
    }), ve = w(() => [
      a.modalClass,
      {
        fade: !y.value,
        show: D.value
      }
    ]), ge = P(
      () => u.value === !1 || u.value === !0 && J.value === !0 || u.value === !0 && B.value === !0
    ), ke = P(
      () => a.backdropVariant !== void 0 ? a.backdropVariant : b.value ? "transparent" : "dark"
    ), Ce = P(() => !He(n["header-close"])), M = w(() => [
      a.dialogClass,
      {
        "modal-fullscreen": E.value === !0,
        [`modal-fullscreen-${E.value}-down`]: typeof E.value == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": f.value,
        "modal-dialog-scrollable": k.value
      }
    ]), X = it(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), L = w(() => [a.bodyClass, X.value]), j = it(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), Q = w(() => [
      a.headerClass,
      j.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), Z = w(() => ({
      variant: Ce.value ? a.headerCloseVariant : void 0,
      class: a.headerCloseClass
    })), Y = it(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), pe = w(() => [
      a.footerClass,
      Y.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), ne = w(() => [
      a.titleClass,
      {
        "visually-hidden": N.value
      }
    ]), Be = P(() => c.value || i.value), ue = P(() => C.value || i.value), x = (be, Ie = {}) => new Vt(be, {
      cancelable: !1,
      target: K.value || null,
      relatedTarget: null,
      trigger: null,
      ...Ie,
      componentId: r.value
    });
    ce(B, (be, Ie) => {
      be !== Ie && (be === !0 ? re() : U());
    });
    const U = (be = "") => {
      if (be === "backdrop" && v.value || be === "esc" && S.value) {
        l("hide-prevented");
        return;
      }
      const Ie = x("hide", { cancelable: be !== "", trigger: be });
      if (be === "ok" && l(be, Ie), be === "cancel" && l(be, Ie), be === "close" && l(be, Ie), l("hide", Ie), Ie.defaultPrevented) {
        l("hide-prevented"), s.value || (s.value = !0);
        return;
      }
      s.value && (s.value = !1);
    }, re = () => {
      if (D.value)
        return;
      const be = x("show", { cancelable: !0 });
      if (l("show", be), be.defaultPrevented) {
        s.value && (s.value = !1), l("show-prevented");
        return;
      }
      s.value || (s.value = !0);
    }, Te = () => {
      _.value !== !1 && (a.autoFocusButton === "ok" ? te.value = !0 : a.autoFocusButton === "close" ? Oe.value = !0 : a.autoFocusButton === "cancel" ? he.value = !0 : ie.value = !0);
    }, $e = () => {
      re();
    }, Ve = () => {
      D.value = !0, Te(), l("shown", x("shown")), u.value === !0 && (J.value = !0);
    }, ot = () => {
      D.value = !1;
    }, lt = () => {
      l("hidden", x("hidden")), u.value === !0 && (J.value = !1);
    }, { activePosition: qt, activeModalCount: Ta } = Wr(D), Fn = w(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": D.value ? Lo - (((Ta == null ? void 0 : Ta.value) ?? 0) - ((qt == null ? void 0 : qt.value) ?? 0)) : Lo
    }));
    Ne(K, "bv-toggle", () => {
      B.value ? U() : re();
    });
    const Et = w(() => ({
      cancel: () => {
        U("cancel");
      },
      close: () => {
        U("close");
      },
      hide: U,
      ok: () => {
        U("ok");
      },
      visible: B.value
    }));
    return t({
      hide: U,
      id: r,
      show: re
    }), (be, Ie) => {
      var bo;
      return g(), H(_t, {
        to: be.teleportTo,
        disabled: p(V)
      }, [
        ye(Dt, ee({ "no-fade": !0 }, be.transProps, {
          "trans-props": { enterToClass: "show", ...(bo = be.transProps) == null ? void 0 : bo.transProps },
          onBeforeEnter: $e,
          onAfterEnter: Ve,
          onLeave: ot,
          onAfterLeave: lt
        }), {
          default: R(() => [
            wt(le("div", ee({
              id: p(r),
              ref_key: "element",
              ref: K,
              class: ["modal", ve.value],
              role: "dialog",
              "aria-labelledby": p(h) ? void 0 : `${p(r)}-label`,
              "aria-describedby": `${p(r)}-body`,
              tabindex: "-1"
            }, be.$attrs, { style: Fn.value }), [
              le("div", {
                class: G(["modal-dialog", M.value])
              }, [
                ge.value ? (g(), I("div", {
                  key: 0,
                  class: G(["modal-content", be.contentClass])
                }, [
                  p(h) ? se("", !0) : (g(), I("div", {
                    key: 0,
                    class: G(["modal-header", Q.value])
                  }, [
                    O(be.$slots, "header", we(Ae(Et.value)), () => [
                      (g(), H(fe(be.titleTag), {
                        id: `${p(r)}-label`,
                        class: G(["modal-title", ne.value])
                      }, {
                        default: R(() => [
                          O(be.$slots, "title", we(Ae(Et.value)), () => [
                            de(ae(be.title), 1)
                          ], !0)
                        ]),
                        _: 3
                      }, 8, ["id", "class"])),
                      p($) ? se("", !0) : (g(), I(me, { key: 0 }, [
                        Ce.value ? (g(), H(Bt, ee({ key: 0 }, Z.value, {
                          onClick: Ie[0] || (Ie[0] = (ea) => U("close"))
                        }), {
                          default: R(() => [
                            O(be.$slots, "header-close", {}, void 0, !0)
                          ]),
                          _: 3
                        }, 16)) : (g(), H(jt, ee({
                          key: 1,
                          "aria-label": be.headerCloseLabel
                        }, Z.value, {
                          onClick: Ie[1] || (Ie[1] = (ea) => U("close"))
                        }), null, 16, ["aria-label"]))
                      ], 64))
                    ], !0)
                  ], 2)),
                  le("div", {
                    id: `${p(r)}-body`,
                    class: G(["modal-body", L.value])
                  }, [
                    O(be.$slots, "default", we(Ae(Et.value)), () => [
                      de(ae(be.body), 1)
                    ], !0)
                  ], 10, oi),
                  p(m) ? se("", !0) : (g(), I("div", {
                    key: 1,
                    class: G(["modal-footer", pe.value])
                  }, [
                    O(be.$slots, "footer", we(Ae(Et.value)), () => [
                      O(be.$slots, "cancel", we(Ae(Et.value)), () => [
                        p(T) ? se("", !0) : (g(), H(Bt, {
                          key: 0,
                          ref_key: "cancelButton",
                          ref: F,
                          disabled: Be.value,
                          size: be.buttonSize,
                          variant: be.cancelVariant,
                          onClick: Ie[2] || (Ie[2] = (ea) => U("cancel"))
                        }, {
                          default: R(() => [
                            de(ae(be.cancelTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"]))
                      ], !0),
                      O(be.$slots, "ok", we(Ae(Et.value)), () => [
                        ye(Bt, {
                          ref_key: "okButton",
                          ref: oe,
                          disabled: ue.value,
                          size: be.buttonSize,
                          variant: be.okVariant,
                          onClick: Ie[3] || (Ie[3] = (ea) => U("ok"))
                        }, {
                          default: R(() => [
                            de(ae(be.okTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"])
                      ], !0)
                    ], !0)
                  ], 2))
                ], 2)) : se("", !0)
              ], 2),
              O(be.$slots, "backdrop", {}, () => [
                ye(ka, {
                  variant: ke.value,
                  show: p(B),
                  "no-spinner": "",
                  fixed: "",
                  "no-wrap": "",
                  blur: null,
                  onClick: Ie[4] || (Ie[4] = (ea) => U("backdrop"))
                }, null, 8, ["variant", "show"])
              ], !0)
            ], 16, ai), [
              [ba, p(B)]
            ])
          ]),
          _: 3
        }, 16, ["trans-props"])
      ], 8, ["to", "disabled"]);
    };
  }
}), $a = (e, t) => {
  const o = e.__vccOpts || e;
  for (const [a, l] of t)
    o[a] = l;
  return o;
}, Ra = /* @__PURE__ */ $a(li, [["__scopeId", "data-v-e2619669"]]), ni = {
  install(e) {
    const t = kt([]), o = () => {
      let r = () => {
      };
      return {
        value: new Promise((i) => {
          r = i;
        }),
        resolve: r
      };
    }, a = (r) => {
      const s = o(), i = Symbol();
      return t.value = [
        ...t.value,
        w(() => ({
          component: Le(r.component) ?? Ra,
          props: { ...Le(r.props), _isConfirm: !1, _promise: s, _self: i, _modelValue: !0 }
        }))
      ], s.value;
    }, l = (r) => {
      const s = o(), i = Symbol();
      return t.value = [
        ...t.value,
        w(() => ({
          component: Le(r.component) ?? Ra,
          props: { ...Le(r.props), _isConfirm: !0, _promise: s, _self: i, _modelValue: !0 }
        }))
      ], s.value;
    }, n = (r) => {
      t.value = t.value.filter((s) => s.value.props._self !== r);
    };
    e.provide(Ul, {
      modals: t,
      remove: n,
      show: a,
      confirm: l
    });
  }
}, si = {
  install(e) {
    const t = kt([]), o = P(() => t.value.length), a = P(() => t.value[t.value.length - 1]), l = (u) => {
      t.value = [...t.value, u];
    }, n = (u) => {
      t.value = t.value.filter((c) => c.uid !== u.uid);
    }, r = kt([]), s = (u) => {
      r.value = [...r.value, u];
    }, i = (u) => {
      r.value = r.value.filter((c) => c.uid !== u.uid);
    };
    e.provide(Xl, {
      stack: t,
      countStack: o,
      lastStack: a,
      registry: r,
      pushStack: l,
      removeStack: n,
      pushRegistry: s,
      removeRegistry: i
    });
  }
}, ri = {
  install(e, t) {
    var i, u;
    const l = typeof (t == null ? void 0 : t.rtl) == "boolean" ? !1 : ((i = t == null ? void 0 : t.rtl) == null ? void 0 : i.rtlInitial) ?? !1, n = typeof (t == null ? void 0 : t.rtl) == "boolean" ? void 0 : ((u = t == null ? void 0 : t.rtl) == null ? void 0 : u.localeInitial) ?? void 0, r = W(l), s = W(n);
    e.provide(Wl, { isRtl: r, locale: s });
  }
}, ii = ["id"], ui = /* @__PURE__ */ q({
  __name: "BAccordion",
  props: {
    flush: { type: [Boolean, String], default: !1 },
    free: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = e, l = _e(o, "modelValue", t, { passive: !0 }), n = Pe(() => o.id, "accordion"), r = d(() => o.flush), s = d(() => o.free), i = w(() => ({
      "accordion-flush": r.value
    }));
    return dt(xl, {
      openItem: Ue(l),
      free: s,
      setOpenItem: (u) => {
        l.value = u;
      }
    }), (u, c) => (g(), I("div", {
      id: p(n),
      class: G(["accordion", i.value])
    }, [
      O(u.$slots, "default")
    ], 10, ii));
  }
}), fn = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: {
    horizontal: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    isNav: { type: [Boolean, String], default: !1 },
    modelValue: { type: [Boolean, String], default: !1 },
    skipAnimation: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    toggle: { type: [Boolean, String], default: !1 },
    visible: { type: [Boolean, String], default: !1 }
  },
  emits: ["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = (E, K = {}) => new Vt(E, {
      cancelable: !1,
      target: h.value || null,
      relatedTarget: null,
      trigger: null,
      ...K,
      componentId: m.value
    }), r = _e(a, "modelValue", l, { passive: !0 }), s = d(r), i = d(() => a.toggle), u = d(() => a.horizontal), c = d(() => a.isNav), f = d(() => a.visible), b = d(() => a.skipAnimation), m = Pe(() => a.id, "collapse"), h = W(null), $ = W(!1), B = W(s.value), v = w(() => ({
      show: B.value,
      "navbar-collapse": c.value,
      collapsing: $.value,
      closing: B.value && !s.value,
      "collapse-horizontal": u.value
    })), S = () => {
      r.value = !1;
    }, y = () => {
      r.value = !0;
    }, _ = () => {
      r.value = !s.value;
    }, C = w(() => ({
      toggle: _,
      open: y,
      close: S,
      id: m.value,
      visible: s.value
    }));
    let T, k, N = b.value;
    const V = () => {
      const E = n("show", { cancelable: !0 });
      if (l("show", E), E.defaultPrevented) {
        l("show-prevented");
        return;
      }
      clearTimeout(k), clearTimeout(T), B.value = !0, !N && ($.value = !0, Fe(() => {
        h.value !== null && (u.value ? h.value.style.width = `${h.value.scrollWidth}px` : h.value.style.height = `${h.value.scrollHeight}px`, T = setTimeout(() => {
          $.value = !1, l("shown"), h.value !== null && (h.value.style.height = "", h.value.style.width = "");
        }, Na(h.value)));
      }));
    }, A = () => {
      const E = n("hide", { cancelable: !0 });
      if (l("hide", E), E.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      if (clearTimeout(T), clearTimeout(k), h.value !== null) {
        if (N) {
          B.value = !1;
          return;
        }
        $.value ? (h.value.style.height = "", h.value.style.width = "") : u.value ? h.value.style.width = `${h.value.scrollWidth}px` : h.value.style.height = `${h.value.scrollHeight}px`, h.value.offsetHeight, $.value = !0, Fe(() => {
          h.value !== null && (h.value.style.height = "", h.value.style.width = "", k = setTimeout(() => {
            B.value = !1, $.value = !1, l("hidden");
          }, Na(h.value)));
        });
      }
    };
    return ce(r, () => {
      s.value ? V() : A();
    }), at(() => {
      h.value !== null && !s.value && i.value && Fe(() => {
        r.value = !0;
      });
    }), ce(b, (E) => {
      N = E;
    }), f.value && (N = !0, r.value = !0, Fe(() => {
      N = b.value;
    })), ce(f, (E) => {
      N = !0, E ? y() : S(), Fe(() => {
        N = b.value;
      });
    }), Ne(h, "bv-toggle", () => {
      r.value = !s.value;
    }), t({
      close: S,
      isNav: c,
      open: y,
      toggle: _,
      visible: Ue(B)
    }), dt(so, {
      id: m,
      close: S,
      open: y,
      toggle: _,
      visible: Ue(B),
      isNav: c
    }), (E, K) => (g(), I(me, null, [
      O(E.$slots, "header", we(Ae(C.value))),
      (g(), H(fe(E.tag), ee({
        id: p(m),
        ref_key: "element",
        ref: h,
        class: ["collapse", v.value],
        "is-nav": p(c)
      }, E.$attrs), {
        default: R(() => [
          O(E.$slots, "default", we(Ae(C.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      O(E.$slots, "footer", we(Ae(C.value)))
    ], 64));
  }
}), di = ["aria-expanded", "aria-controls", "onClick"], ci = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: {
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: [Boolean, String], default: void 0 },
    id: { default: void 0 },
    isNav: { type: [Boolean, String], default: void 0 },
    modelValue: { type: Boolean, default: !1 },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: [Boolean, String], default: void 0 },
    visible: { type: [Boolean, String], default: !1 },
    wrapperAttrs: { default: void 0 }
  },
  emits: ["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "update:modelValue"],
  setup(e, { emit: t }) {
    const { class: o, ...a } = Zt(), l = e, n = t, r = _e(l, "modelValue", n, { passive: !0 }), s = ze(xl, null), i = Pe(() => l.id, "accordion_item");
    return at(() => {
      r.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(i.value)), !r.value && (s == null ? void 0 : s.openItem.value) === i.value && (r.value = !0);
    }), ce(
      () => s == null ? void 0 : s.openItem.value,
      () => r.value = (s == null ? void 0 : s.openItem.value) === i.value && !(s != null && s.free.value)
    ), ce(r, () => {
      r.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(i.value));
    }), (u, c) => (g(), I("div", ee({ class: "accordion-item" }, u.wrapperAttrs, { class: p(o) }), [
      ye(fn, ee({
        id: p(i),
        modelValue: p(r),
        "onUpdate:modelValue": c[0] || (c[0] = (f) => tl(r) ? r.value = f : null),
        class: ["accordion-collapse", u.collapseClass],
        "aria-labelledby": `${p(i)}-heading`
      }, a, {
        tag: u.tag,
        toggle: u.toggle,
        horizontal: u.horizontal,
        visible: u.visible,
        "is-nav": u.isNav,
        onShow: c[1] || (c[1] = (f) => n("show", f)),
        onShown: c[2] || (c[2] = (f) => n("shown")),
        onHide: c[3] || (c[3] = (f) => n("hide", f)),
        onHidden: c[4] || (c[4] = (f) => n("hidden")),
        onHidePrevented: c[5] || (c[5] = (f) => n("hide-prevented")),
        onShowPrevented: c[6] || (c[6] = (f) => n("show-prevented"))
      }), {
        header: R(({ visible: f, toggle: b }) => [
          (g(), H(fe(u.headerTag), ee({
            id: `${p(i)}-heading`,
            class: ["accordion-header", u.headerClass]
          }, u.headerAttrs), {
            default: R(() => [
              le("button", ee({ class: "accordion-button" }, u.buttonAttrs, {
                class: [{ collapsed: !f }, u.buttonClass],
                type: "button",
                "aria-expanded": f ? "true" : "false",
                "aria-controls": p(i),
                onClick: b
              }), [
                O(u.$slots, "title", {}, () => [
                  de(ae(u.title), 1)
                ])
              ], 16, di)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: R(() => [
          le("div", ee({ class: "accordion-body" }, u.bodyAttrs, { class: u.bodyClass }), [
            O(u.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
}), fi = /* @__PURE__ */ q({
  __name: "BAlert",
  props: {
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: [Boolean, String], default: !1 },
    fade: { type: [Boolean, String], default: !1 },
    immediate: { type: [Boolean, String], default: !0 },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    showOnPause: { type: [Boolean, String], default: !0 },
    variant: { default: "info" }
  },
  emits: ["close", "close-countdown", "closed", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = W(null), s = _e(a, "modelValue", l), i = lo(r), u = d(() => a.dismissible), c = d(() => a.fade), f = d(() => a.immediate), b = d(() => a.showOnPause), m = d(() => a.noHoverPause), h = Se(() => a.interval), $ = P(() => !He(n.close)), B = P(() => typeof s.value == "boolean" ? 0 : s.value), v = w(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": u.value
    })), S = w(() => [a.closeClass, { "btn-close-custom": $.value }]), {
      isActive: y,
      pause: _,
      restart: C,
      resume: T,
      stop: k,
      isPaused: N,
      value: V
    } = Yl(B, h, {
      immediate: typeof s.value == "number" && f.value
    }), A = P(
      () => typeof s.value == "boolean" ? s.value : y.value || b.value && N.value
    ), E = w(() => ({
      variant: $.value ? a.closeVariant : void 0,
      class: S.value
    }));
    Yt(() => {
      l("close-countdown", V.value);
    });
    const K = () => {
      l("close"), typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, k()), l("closed");
    }, oe = () => {
      m.value || _();
    };
    return ce(i, (F) => {
      if (F) {
        oe();
        return;
      }
      T();
    }), Ga(k), t({
      pause: _,
      restart: C,
      resume: T,
      stop: k
    }), (F, z) => (g(), H(Dt, {
      "no-fade": !p(c),
      "trans-props": { enterToClass: "show" }
    }, {
      default: R(() => [
        A.value ? (g(), I("div", {
          key: 0,
          ref_key: "element",
          ref: r,
          class: G(["alert", v.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          O(F.$slots, "default", {}, void 0, !0),
          p(u) ? (g(), I(me, { key: 0 }, [
            $.value || F.closeContent ? (g(), H(Bt, ee({ key: 0 }, E.value, { onClick: K }), {
              default: R(() => [
                O(F.$slots, "close", {}, () => [
                  de(ae(F.closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (g(), H(jt, ee({
              key: 1,
              "aria-label": F.closeLabel
            }, E.value, { onClick: K }), null, 16, ["aria-label"]))
          ], 64)) : se("", !0)
        ], 2)) : se("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), vi = /* @__PURE__ */ $a(fi, [["__scopeId", "data-v-80abc89a"]]), pi = {
  key: 0,
  class: "b-avatar-custom"
}, mi = {
  key: 1,
  class: "b-avatar-img"
}, gi = ["src", "alt"], zo = 0.4, bi = /* @__PURE__ */ q({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeBgVariant: { default: null },
    badgeOffset: { default: void 0 },
    badgeStart: { type: [Boolean, String], default: !1 },
    badgeTextVariant: { default: null },
    badgeTop: { type: [Boolean, String], default: !1 },
    badgeVariant: { default: "primary" },
    button: { type: [Boolean, String], default: !1 },
    buttonType: { default: "button" },
    icon: { type: [String, Boolean], default: void 0 },
    size: { default: void 0 },
    square: { type: [Boolean, String], default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [String, Number, Boolean], default: !1 },
    roundedTop: { type: [String, Number, Boolean], default: void 0 },
    roundedBottom: { type: [String, Number, Boolean], default: void 0 },
    roundedStart: { type: [String, Number, Boolean], default: void 0 },
    roundedEnd: { type: [String, Number, Boolean], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = je(), { computedLink: n, computedLinkProps: r } = At(o), s = ze(Rl, null), i = ["sm", null, "lg"], u = zo * 0.7, c = d(() => o.badgeStart), f = d(() => o.badgeTop), b = d(() => o.button), m = d(() => o.disabled), h = d(() => o.square), $ = d(() => o.rounded), B = d(() => o.roundedTop), v = d(() => o.roundedBottom), S = d(() => o.roundedStart), y = d(() => o.roundedEnd), _ = P(() => !He(l.default)), C = P(() => !He(l.badge)), T = P(() => !!o.badge || o.badge === "" || C.value), k = P(() => (s == null ? void 0 : s.size.value) ?? h.value), N = Pa(() => o.size), V = Pa(() => s == null ? void 0 : s.size.value), A = w(() => V.value ?? N.value), E = P(() => (s == null ? void 0 : s.variant.value) ?? o.variant), K = P(() => (s == null ? void 0 : s.rounded.value) ?? $.value), oe = P(() => (s == null ? void 0 : s.roundedTop.value) ?? B.value), F = P(
      () => (s == null ? void 0 : s.roundedBottom.value) ?? v.value
    ), z = P(
      () => (s == null ? void 0 : s.roundedStart.value) ?? S.value
    ), D = P(() => (s == null ? void 0 : s.roundedEnd.value) ?? y.value), J = co(() => ({
      rounded: K.value,
      roundedTop: oe.value,
      roundedBottom: F.value,
      roundedStart: z.value,
      roundedEnd: D.value
    })), ie = it(() => ({
      variant: o.badgeVariant,
      bgVariant: o.badgeBgVariant,
      textVariant: o.badgeTextVariant
    })), te = P(() => o.badge === !0 ? "" : o.badge), he = P(() => (s == null ? void 0 : s.textVariant.value) ?? o.textVariant), Oe = P(() => (s == null ? void 0 : s.bgVariant.value) ?? o.bgVariant), ve = it(() => ({
      bgVariant: Oe.value,
      textVariant: he.value,
      variant: E.value
    })), ge = w(() => [
      ve.value,
      // Square overwrites all else
      k.value === !0 ? void 0 : J.value,
      {
        [`b-avatar-${o.size}`]: !!o.size && i.indexOf(N.value) !== -1,
        [`btn-${E.value}`]: b.value ? E.value !== null : !1,
        badge: !b.value && E.value !== null && _.value,
        btn: b.value,
        // Square is the same as rounded-0 class
        "rounded-0": k.value === !0
      }
    ]), ke = w(() => {
      const Z = o.badgeOffset || "0px";
      return {
        fontSize: (i.indexOf(A.value || null) === -1 ? `calc(${A.value} * ${u})` : "") || "",
        top: f.value ? Z : "",
        bottom: f.value ? "" : Z,
        left: c.value ? Z : "",
        right: c.value ? "" : Z
      };
    }), Ce = w(() => {
      const Z = i.indexOf(A.value || null) === -1 ? `calc(${A.value} * ${zo})` : null;
      return Z ? { fontSize: Z } : {};
    }), M = w(() => {
      var pe;
      const Z = ((pe = s == null ? void 0 : s.overlapScale) == null ? void 0 : pe.value) || 0, Y = A.value && Z ? `calc(${A.value} * -${Z})` : null;
      return Y ? { marginLeft: Y, marginRight: Y } : {};
    }), X = P(
      () => n.value ? ft : b.value ? "button" : "span"
    ), L = w(() => ({
      ...M.value,
      width: A.value ?? void 0,
      height: A.value ?? void 0
    })), j = (Z) => {
      !m.value && (n.value || b.value) && a("click", Z);
    }, Q = (Z) => {
      a("img-error", Z);
    };
    return (Z, Y) => (g(), H(fe(X.value), ee({
      class: ["b-avatar", ge.value],
      style: L.value
    }, p(r), {
      type: p(b) && !p(n) ? o.buttonType : void 0,
      disabled: p(m) || null,
      onClick: j
    }), {
      default: R(() => [
        _.value ? (g(), I("span", pi, [
          O(Z.$slots, "default")
        ])) : Z.src ? (g(), I("span", mi, [
          le("img", {
            src: Z.src,
            alt: Z.alt,
            onError: Q
          }, null, 40, gi)
        ])) : Z.text ? (g(), I("span", {
          key: 2,
          class: "b-avatar-text",
          style: Me(Ce.value)
        }, ae(Z.text), 5)) : se("", !0),
        T.value ? (g(), I("span", {
          key: 3,
          class: G(["b-avatar-badge", p(ie)]),
          style: Me(ke.value)
        }, [
          O(Z.$slots, "badge", {}, () => [
            de(ae(te.value), 1)
          ])
        ], 6)) : se("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), yi = /* @__PURE__ */ q({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [String, Number, Boolean], default: !1 },
    roundedTop: { type: [String, Number, Boolean], default: void 0 },
    roundedBottom: { type: [String, Number, Boolean], default: void 0 },
    roundedStart: { type: [String, Number, Boolean], default: void 0 },
    roundedEnd: { type: [String, Number, Boolean], default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.square), a = d(() => t.rounded), l = d(() => t.roundedTop), n = d(() => t.roundedBottom), r = d(() => t.roundedStart), s = d(() => t.roundedEnd), i = Se(() => t.overlap), u = Pa(() => t.size), c = P(() => Math.min(Math.max(i.value, 0), 1) / 2), f = w(() => {
      const b = u.value ? `calc(${u.value} * ${c.value})` : null;
      return b ? { paddingLeft: b, paddingRight: b } : {};
    });
    return dt(Rl, {
      overlapScale: c,
      size: P(() => t.size),
      square: o,
      rounded: a,
      roundedTop: l,
      roundedBottom: n,
      roundedStart: r,
      roundedEnd: s,
      variant: P(() => t.variant),
      bgVariant: P(() => t.bgVariant),
      textVariant: P(() => t.textVariant)
    }), (b, m) => (g(), H(fe(b.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: R(() => [
        le("div", {
          class: "b-avatar-group-inner",
          style: Me(f.value)
        }, [
          O(b.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), hi = /* @__PURE__ */ q({
  __name: "BBadge",
  props: {
    dotIndicator: { type: [Boolean, String], default: !1 },
    pill: { type: [Boolean, String], default: !1 },
    tag: { default: "span" },
    textIndicator: { type: [Boolean, String], default: !1 },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, o = d(() => t.pill), a = d(() => t.textIndicator), l = d(() => t.dotIndicator), n = d(() => t.active), r = d(() => t.disabled), s = it(t), { computedLink: i, computedLinkProps: u } = At(t, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), c = P(() => i.value ? ft : t.tag), f = w(() => [
      s.value,
      {
        active: n.value,
        disabled: r.value,
        "rounded-pill": o.value,
        "position-absolute top-0 start-100 translate-middle": a.value || l.value,
        "p-2 border border-light rounded-circle": l.value,
        "text-decoration-none": i.value
      }
    ]);
    return (b, m) => (g(), H(fe(c.value), ee({
      class: ["badge", f.value]
    }, p(u)), {
      default: R(() => [
        O(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vn = /* @__PURE__ */ q({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: [Boolean, String], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.active), n = d(() => o.disabled), r = w(() => ({
      active: l.value
    })), s = P(() => l.value ? "span" : ft), i = P(() => l.value ? o.ariaCurrent : void 0), u = w(
      () => s.value !== "span" ? io(o, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), c = (f) => {
      if (n.value || l.value) {
        f.preventDefault(), f.stopImmediatePropagation();
        return;
      }
      n.value || a("click", f);
    };
    return (f, b) => (g(), I("li", {
      class: G(["breadcrumb-item", r.value])
    }, [
      (g(), H(fe(s.value), ee({ "aria-current": i.value }, u.value, { onClick: c }), {
        default: R(() => [
          O(f.$slots, "default", {}, () => [
            de(ae(f.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), Bi = { "aria-label": "breadcrumb" }, Si = { class: "breadcrumb" }, wi = /* @__PURE__ */ q({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, o = Kl(), a = w(() => {
      var s;
      const l = t.items || ((s = o.items) == null ? void 0 : s.value) || [];
      let n = !1;
      return l.map((i, u) => (typeof i == "string" && (i = { text: i }, u < l.length - 1 && (i.href = "#")), i.active && (n = !0), !i.active && !n && (i.active = u + 1 === l.length), i));
    });
    return (l, n) => (g(), I("nav", Bi, [
      le("ol", Si, [
        O(l.$slots, "prepend"),
        (g(!0), I(me, null, Ee(a.value, (r, s) => (g(), H(vn, ee({ key: s }, r), {
          default: R(() => [
            de(ae(r.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        O(l.$slots, "default"),
        O(l.$slots, "append")
      ])
    ]));
  }
}), Ci = /* @__PURE__ */ q({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.vertical), a = w(() => ({
      "btn-group": !o.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": o.value
    }));
    return (l, n) => (g(), H(fe(l.tag), {
      class: G(a.value),
      role: "group",
      "aria-label": l.ariaLabel
    }, {
      default: R(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), ki = ["role", "aria-label"], $i = /* @__PURE__ */ q({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: [Boolean, String], default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const t = e, o = d(() => t.justify), a = w(() => ({
      "justify-content-between": o.value
    }));
    return (l, n) => (g(), I("div", {
      class: G([a.value, "btn-toolbar"]),
      role: l.role,
      "aria-label": l.ariaLabel
    }, [
      O(l.$slots, "default")
    ], 10, ki));
  }
}), Ti = ["src", "width", "height", "srcset", "sizes", "loading"], fo = /* @__PURE__ */ q({
  __name: "BImg",
  props: {
    blank: { type: [Boolean, String], default: !1 },
    blankColor: { default: "transparent" },
    block: { type: [Boolean, String], default: !1 },
    center: { type: [Boolean, String], default: !1 },
    end: { type: [Boolean, String], default: !1 },
    fluid: { type: [Boolean, String], default: !1 },
    fluidGrow: { type: [Boolean, String], default: !1 },
    height: { default: void 0 },
    lazy: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: [Boolean, String], default: !1 },
    thumbnail: { type: [Boolean, String], default: !1 },
    width: { default: void 0 },
    rounded: { type: [String, Number, Boolean], default: !1 },
    roundedTop: { type: [String, Number, Boolean], default: void 0 },
    roundedBottom: { type: [String, Number, Boolean], default: void 0 },
    roundedStart: { type: [String, Number, Boolean], default: void 0 },
    roundedEnd: { type: [String, Number, Boolean], default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.lazy), a = d(() => t.blank), l = d(() => t.block), n = d(() => t.center), r = d(() => t.fluid), s = d(() => t.fluidGrow), i = d(() => t.start), u = d(() => t.end), c = d(() => t.thumbnail), f = Se(() => t.height ?? NaN), b = Se(() => t.width ?? NaN), m = d(() => t.rounded), h = d(() => t.roundedTop), $ = d(() => t.roundedBottom), B = d(() => t.roundedStart), v = d(() => t.roundedEnd), S = co(() => ({
      rounded: m.value,
      roundedTop: h.value,
      roundedBottom: $.value,
      roundedStart: B.value,
      roundedEnd: v.value
    })), y = w(
      () => typeof t.srcset == "string" ? t.srcset.split(",").filter((A) => A).join(",") : Array.isArray(t.srcset) ? t.srcset.filter((A) => A).join(",") : void 0
    ), _ = w(
      () => typeof t.sizes == "string" ? t.sizes.split(",").filter((A) => A).join(",") : Array.isArray(t.sizes) ? t.sizes.filter((A) => A).join(",") : void 0
    ), C = w(() => {
      const A = Number.isNaN(b.value) ? void 0 : b.value, E = Number.isNaN(f.value) ? void 0 : f.value;
      return a.value ? A !== void 0 && E === void 0 ? { height: A, width: A } : A === void 0 && E !== void 0 ? { height: E, width: E } : { height: 1, width: 1 } : {
        width: A,
        height: E
      };
    }), T = P(
      () => V(C.value.width, C.value.height, t.blankColor)
    ), k = P(
      () => i.value ? "float-start" : u.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), N = w(() => [
      S.value,
      {
        "img-thumbnail": c.value,
        "img-fluid": r.value || s.value,
        "w-100": s.value,
        [`${k.value}`]: k.value !== void 0,
        "d-block": l.value || n.value
      }
    ]), V = (A, E, K) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${A}" height="${E}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${A} ${E}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${K};"></rect>
    </svg>`)}`;
    return (A, E) => (g(), I("img", {
      class: G(N.value),
      src: p(a) ? T.value : A.src,
      width: C.value.width || void 0,
      height: C.value.height || void 0,
      srcset: p(a) ? void 0 : y.value,
      sizes: p(a) ? void 0 : _.value,
      loading: p(o) ? "lazy" : "eager"
    }, null, 10, Ti));
  }
}), vo = /* @__PURE__ */ q({
  __name: "BCardImg",
  props: {
    bottom: { type: [Boolean, String], default: !1 },
    top: { type: [Boolean, String], default: !1 },
    blank: { type: [Boolean, String], default: void 0 },
    blankColor: { default: void 0 },
    block: { type: [Boolean, String], default: void 0 },
    center: { type: [Boolean, String], default: void 0 },
    end: { type: [Boolean, String], default: void 0 },
    fluid: { type: [Boolean, String], default: void 0 },
    fluidGrow: { type: [Boolean, String], default: void 0 },
    height: { default: void 0 },
    lazy: { type: [Boolean, String], default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: [Boolean, String], default: void 0 },
    thumbnail: { type: [Boolean, String], default: void 0 },
    width: { default: void 0 },
    rounded: { type: [String, Number, Boolean], default: void 0 },
    roundedTop: { type: [String, Number, Boolean], default: void 0 },
    roundedBottom: { type: [String, Number, Boolean], default: void 0 },
    roundedStart: { type: [String, Number, Boolean], default: void 0 },
    roundedEnd: { type: [String, Number, Boolean], default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.bottom), a = d(() => t.end), l = d(() => t.start), n = d(() => t.top), r = P(
      () => n.value ? "card-img-top" : a.value ? "card-img-right" : o.value ? "card-img-bottom" : l.value ? "card-img-left" : "card-img"
    ), s = w(() => wa(t, ["bottom", "top", "end", "start"]));
    return (i, u) => (g(), H(fo, ee(s.value, { class: r.value }), null, 16, ["class"]));
  }
}), _i = ["innerHTML"], pn = /* @__PURE__ */ q({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, o = it(t), a = w(() => [
      o.value,
      {
        [`border-${t.borderVariant}`]: t.borderVariant !== null
      }
    ]);
    return (l, n) => (g(), H(fe(l.tag), {
      class: G(a.value)
    }, {
      default: R(() => [
        l.html ? (g(), I("div", {
          key: 0,
          innerHTML: l.html
        }, null, 8, _i)) : O(l.$slots, "default", { key: 1 }, () => [
          de(ae(l.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), mn = /* @__PURE__ */ q({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (o, a) => (g(), H(pn, ee({ class: "card-header" }, t), {
      default: R(() => [
        O(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gn = /* @__PURE__ */ q({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, o) => (g(), H(fe(t.tag), { class: "card-title" }, {
      default: R(() => [
        O(t.$slots, "default", {}, () => [
          de(ae(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), bn = /* @__PURE__ */ q({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null
    }));
    return (a, l) => (g(), H(fe(a.tag), {
      class: G(["card-subtitle mb-2", o.value])
    }, {
      default: R(() => [
        O(a.$slots, "default", {}, () => [
          de(ae(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), yn = /* @__PURE__ */ q({
  __name: "BCardBody",
  props: {
    overlay: { type: [Boolean, String], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, o = je(), a = d(() => t.overlay), l = it(t), n = P(() => !He(o.title)), r = P(() => !He(o.subtitle)), s = w(() => [
      l.value,
      {
        "card-img-overlay": a.value
      }
    ]);
    return (i, u) => (g(), H(fe(i.tag), {
      class: G(["card-body", s.value])
    }, {
      default: R(() => [
        i.title || n.value ? (g(), H(gn, {
          key: 0,
          tag: i.titleTag
        }, {
          default: R(() => [
            O(i.$slots, "title", {}, () => [
              de(ae(i.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : se("", !0),
        i.subtitle || r.value ? (g(), H(bn, {
          key: 1,
          tag: i.subtitleTag,
          "text-variant": i.subtitleTextVariant
        }, {
          default: R(() => [
            O(i.$slots, "subtitle", {}, () => [
              de(ae(i.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : se("", !0),
        O(i.$slots, "default", {}, () => [
          de(ae(i.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), hn = /* @__PURE__ */ q({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (o, a) => (g(), H(pn, ee({ class: "card-footer" }, t), {
      default: R(() => [
        O(o.$slots, "default", {}, () => [
          de(ae(o.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), Bn = /* @__PURE__ */ q({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgBottom: { type: [Boolean, String], default: !1 },
    imgEnd: { type: [Boolean, String], default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: [Boolean, String], default: !1 },
    imgTop: { type: [Boolean, String], default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    overlay: { type: [Boolean, String], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, o = je(), a = d(() => t.imgBottom), l = d(() => t.imgEnd), n = d(() => t.imgStart), r = d(() => t.noBody), s = P(() => !He(o.header)), i = P(() => !He(o.footer)), u = it(t), c = w(() => [
      u.value,
      {
        [`text-${t.align}`]: t.align !== void 0,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "flex-row": n.value,
        "flex-row-reverse": l.value
      }
    ]), f = w(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    })), b = pa();
    return (m, h) => (g(), H(fe(m.tag), {
      class: G(["card", c.value])
    }, {
      default: R(() => [
        ye(p(b).define, null, {
          default: R(() => [
            O(m.$slots, "img", {}, () => [
              m.imgSrc ? (g(), H(vo, we(ee({ key: 0 }, f.value)), null, 16)) : se("", !0)
            ])
          ]),
          _: 3
        }),
        p(a) ? se("", !0) : (g(), H(p(b).reuse, { key: 0 })),
        m.header || s.value || m.headerHtml ? (g(), H(mn, {
          key: 1,
          "bg-variant": m.headerBgVariant,
          variant: m.headerVariant,
          "border-variant": m.headerBorderVariant,
          html: m.headerHtml,
          tag: m.headerTag,
          "text-variant": m.headerTextVariant,
          class: G(m.headerClass)
        }, {
          default: R(() => [
            O(m.$slots, "header", {}, () => [
              de(ae(m.header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : se("", !0),
        p(r) ? O(m.$slots, "default", { key: 3 }, () => [
          de(ae(m.bodyText), 1)
        ]) : (g(), H(yn, {
          key: 2,
          overlay: m.overlay,
          "bg-variant": m.bodyBgVariant,
          tag: m.bodyTag,
          "text-variant": m.bodyTextVariant,
          subtitle: m.subtitle,
          "subtitle-tag": m.subtitleTag,
          "subtitle-text-variant": m.subtitleTextVariant,
          title: m.title,
          "title-tag": m.titleTag,
          class: G(m.bodyClass)
        }, {
          default: R(() => [
            O(m.$slots, "default", {}, () => [
              de(ae(m.bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        m.footer || i.value || m.footerHtml ? (g(), H(hn, {
          key: 4,
          "bg-variant": m.footerBgVariant,
          "border-variant": m.footerBorderVariant,
          variant: m.footerVariant,
          html: m.footerHtml,
          tag: m.footerTag,
          "text-variant": m.footerTextVariant,
          class: G(m.footerClass)
        }, {
          default: R(() => [
            O(m.$slots, "footer", {}, () => [
              de(ae(m.footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : se("", !0),
        p(a) ? (g(), H(p(b).reuse, { key: 5 })) : se("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Vi = /* @__PURE__ */ q({
  __name: "BCardGroup",
  props: {
    columns: { type: [Boolean, String], default: !1 },
    deck: { type: [Boolean, String], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, o = d(() => t.columns), a = d(() => t.deck), l = P(
      () => a.value ? "card-deck" : o.value ? "card-columns" : "card-group"
    );
    return (n, r) => (g(), H(fe(n.tag), {
      class: G(l.value)
    }, {
      default: R(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ai = /* @__PURE__ */ q({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, o) => (g(), H(fe(t.tag), { class: "card-text" }, {
      default: R(() => [
        O(t.$slots, "default", {}, () => [
          de(ae(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Oi = ["id"], Ei = {
  key: 0,
  class: "carousel-indicators"
}, Pi = ["aria-current", "aria-label", "onClick"], Ni = /* @__PURE__ */ le("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Ii = { class: "visually-hidden" }, Fi = /* @__PURE__ */ le("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Li = { class: "visually-hidden" }, zi = /* @__PURE__ */ q({
  __name: "BCarousel",
  props: {
    background: { default: void 0 },
    controls: { type: [Boolean, String], default: !1 },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: [Boolean, String], default: !1 },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: [Boolean, String], default: !0 },
    modelValue: { default: 0 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    noTouch: { type: [Boolean, String], default: !1 },
    noWrap: { type: [Boolean, String], default: !1 },
    ride: { type: [Boolean, String], default: !1 },
    rideReverse: { type: [Boolean, String], default: !1 },
    touchThreshold: { default: 50 }
  },
  emits: ["slide", "slid", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = Pe(() => a.id, "carousel"), s = _e(a, "modelValue", l, { passive: !0 }), i = d(() => a.keyboard), u = d(() => a.rideReverse), c = d(() => a.noHoverPause), f = d(() => a.fade), b = d(() => a.controls), m = d(() => a.indicators), h = d(() => a.noTouch), $ = d(() => a.noWrap), B = Se(() => a.touchThreshold), v = Se(() => a.interval), S = d(() => a.ride), y = W(!1), _ = W(!1), C = W(!0), T = W(null), k = W(null), N = W(s.value), V = lo(k), A = P(
      () => `carousel-item carousel-item-${C.value ? "prev" : "next"} carousel-item-${C.value ? "end" : "start"}`
    ), E = P(
      () => `carousel-item active carousel-item-${C.value ? "start" : "end"}`
    ), { pause: K, resume: oe } = Al(
      () => {
        u.value ? te() : he();
      },
      v,
      { immediate: S.value === "carousel" }
    ), F = P(
      () => S.value === !0 && _.value === !0 || S.value === "carousel"
    ), z = w(() => Hr(n.default, "BCarouselSlide")), D = w(() => ({ "carousel-fade": f.value })), J = (L) => {
      var j;
      return new nl(L, {
        componentId: r.value,
        cancelable: !1,
        target: k.value,
        direction: C.value ? "right" : "left",
        from: N.value,
        to: s.value,
        relatedTarget: ((j = T.value) == null ? void 0 : j.children[s.value]) ?? null
      });
    }, ie = (L) => {
      if (y.value !== !0) {
        if (S.value === !0 && (_.value = !0), F.value === !0 && oe(), C.value = !(L < s.value), L >= z.value.length) {
          if ($.value)
            return;
          s.value = 0;
          return;
        }
        if (L < 0) {
          if ($.value)
            return;
          s.value = z.value.length - 1;
          return;
        }
        N.value = s.value, s.value = L;
      }
    }, te = () => {
      ie(s.value - 1);
    }, he = () => {
      ie(s.value + 1);
    }, Oe = (L) => {
      i.value !== !1 && L();
    }, ve = () => {
      c.value || K();
    }, ge = () => {
      F.value && oe();
    }, { lengthX: ke } = Er(k, {
      passive: !0,
      onSwipeStart() {
        h.value !== !0 && K();
      },
      onSwipeEnd() {
        if (h.value === !0)
          return;
        const L = () => {
          F.value !== !1 && oe();
        };
        if (ke.value >= B.value) {
          he(), L();
          return;
        }
        ke.value <= -B.value && (te(), L());
      }
    }), Ce = () => {
      l("slide", J("slide")), y.value = !0;
    }, M = () => {
      l("slid", J("slid")), y.value = !1;
    }, X = (L) => {
      s.value !== 0 && L.classList.add("carousel-item");
    };
    return Ge(
      "ArrowLeft",
      () => {
        Oe(te);
      },
      { target: k }
    ), Ge(
      "ArrowRight",
      () => {
        Oe(he);
      },
      { target: k }
    ), ce(S, () => {
      _.value = !1;
    }), ce(V, (L) => {
      if (L) {
        ve();
        return;
      }
      ge();
    }), t({
      next: he,
      pause: K,
      prev: te,
      resume: oe
    }), dt(Fl, {
      background: P(() => a.background),
      width: P(() => a.imgWidth),
      height: P(() => a.imgHeight)
    }), (L, j) => (g(), I("div", {
      id: p(r),
      ref_key: "element",
      ref: k,
      class: G(["carousel slide pointer-event", D.value])
    }, [
      p(m) ? (g(), I("div", Ei, [
        (g(!0), I(me, null, Ee(z.value.length, (Q, Z) => (g(), I("button", {
          key: Z,
          type: "button",
          "data-bs-target": "",
          class: G(Z === p(s) ? "active" : ""),
          "aria-current": Z === p(s) ? !0 : void 0,
          "aria-label": `${L.indicatorsButtonLabel} ${Z}`,
          onClick: (Y) => ie(Z)
        }, null, 10, Pi))), 128))
      ])) : se("", !0),
      le("div", {
        ref_key: "relatedTarget",
        ref: T,
        class: "carousel-inner"
      }, [
        ye(al, {
          "enter-from-class": A.value,
          "enter-active-class": A.value,
          "enter-to-class": A.value,
          "leave-from-class": E.value,
          "leave-active-class": E.value,
          "leave-to-class": E.value,
          onBeforeLeave: Ce,
          onAfterLeave: M,
          onAfterEnter: X
        }, {
          default: R(() => [
            (g(!0), I(me, null, Ee(z.value, (Q, Z) => wt((g(), H(fe(Q), {
              key: Z,
              class: G({ active: Z === p(s) && y.value === !1 })
            }, null, 8, ["class"])), [
              [ba, Z === p(s)]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      p(b) ? (g(), I(me, { key: 1 }, [
        le("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: te
        }, [
          Ni,
          le("span", Ii, ae(L.controlsPrevText), 1)
        ]),
        le("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: he
        }, [
          Fi,
          le("span", Li, ae(L.controlsNextText), 1)
        ])
      ], 64)) : se("", !0)
    ], 10, Oi));
  }
}), Hi = ["innerHTML"], Ri = { key: 1 }, xi = ["innerHTML"], Mi = { key: 1 }, Di = /* @__PURE__ */ q({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: [Boolean, String], default: !1 },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, o = je(), a = ze(Fl, null), l = P(() => t.text || t.textHtml || !He(o.text)), n = P(() => t.caption || t.captionHtml || !He(o.caption)), r = P(() => l.value || n.value || !He(o.default)), s = w(() => ({
      background: `${t.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), i = w(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (u, c) => (g(), I("div", {
      class: "carousel-item",
      style: Me(s.value)
    }, [
      O(u.$slots, "img", {}, () => {
        var f, b;
        return [
          ye(fo, {
            class: "d-block w-100",
            alt: u.imgAlt,
            srcset: u.imgSrcset,
            src: u.imgSrc,
            width: u.imgWidth || ((f = p(a)) == null ? void 0 : f.width.value),
            height: u.imgHeight || ((b = p(a)) == null ? void 0 : b.height.value),
            blank: u.imgBlank,
            "blank-color": u.imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      r.value ? (g(), H(fe(u.contentTag), {
        key: 0,
        class: G(["carousel-caption", i.value])
      }, {
        default: R(() => [
          n.value ? (g(), H(fe(u.captionTag), { key: 0 }, {
            default: R(() => [
              O(u.$slots, "caption", {}, () => [
                u.captionHtml ? (g(), I("span", {
                  key: 0,
                  innerHTML: u.captionHtml
                }, null, 8, Hi)) : (g(), I("span", Ri, ae(u.caption), 1))
              ])
            ]),
            _: 3
          })) : se("", !0),
          l.value ? (g(), H(fe(u.textTag), { key: 1 }, {
            default: R(() => [
              O(u.$slots, "text", {}, () => [
                u.textHtml ? (g(), I("span", {
                  key: 0,
                  innerHTML: u.textHtml
                }, null, 8, xi)) : (g(), I("span", Mi, ae(u.text), 1))
              ])
            ]),
            _: 3
          })) : se("", !0),
          O(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : se("", !0)
    ], 4));
  }
}), Ho = Sa("", [], { type: [Boolean, String, Number], default: !1 }), Ro = Sa("offset", [""], { type: [String, Number], default: null }), xo = Sa("order", [""], { type: [String, Number], default: null }), ji = q({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Ho,
    offset: { type: [String, Number], default: null },
    ...Ro,
    order: { type: [String, Number], default: null },
    ...xo,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Ho, propPrefix: "cols", classPrefix: "col" },
      { content: Ro, propPrefix: "offset" },
      { content: xo, propPrefix: "order" }
    ], o = d(() => e.col), a = w(
      () => t.flatMap((n) => Il(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: w(() => [
        a.value,
        {
          col: o.value || !a.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function qi(e, t, o, a, l, n) {
  return g(), H(fe(e.tag), {
    class: G(e.computedClasses)
  }, {
    default: R(() => [
      O(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Ut = /* @__PURE__ */ $a(ji, [["render", qi]]), Wi = /* @__PURE__ */ q({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: !1 },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, o = Se(() => t.gutterX ?? NaN, { method: "parseInt" }), a = Se(() => t.gutterY ?? NaN, { method: "parseInt" }), l = d(() => t.fluid), n = w(() => ({
      container: l.value === !1,
      "container-fluid": l.value === !0,
      [`container-${l.value}`]: typeof l.value == "string",
      [`gx-${o.value}`]: !Number.isNaN(o.value),
      [`gy-${a.value}`]: !Number.isNaN(a.value)
    }));
    return (r, s) => (g(), H(fe(r.tag), {
      class: G(n.value)
    }, {
      default: R(() => [
        O(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Gi = { class: "visually-hidden" }, Ui = ["aria-labelledby", "role"], Sn = /* @__PURE__ */ q({
  __name: "BDropdown",
  props: {
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: [Boolean, String], default: !1 },
    container: { default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    dropend: { type: [Boolean, String], default: !1 },
    dropstart: { type: [Boolean, String], default: !1 },
    dropup: { type: [Boolean, String], default: !1 },
    end: { type: [Boolean, String], default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: [Boolean, String], default: !1 },
    lazy: { type: [Boolean, String], default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    noCaret: { type: [Boolean, String], default: !1 },
    noFlip: { type: [Boolean, String], default: !1 },
    noShift: { type: [Boolean, String], default: !1 },
    noSize: { type: [Boolean, String], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: [Boolean, String], default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: [Boolean, String], default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" }
  },
  emits: ["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = Pe(() => a.id, "dropdown"), r = _e(a, "modelValue", l, { passive: !0 }), s = d(r), i = d(() => a.dropup), u = d(() => a.dropend), c = d(() => a.isNav), f = d(() => a.dropstart), b = d(() => a.center), m = d(() => a.end), h = d(() => a.split), $ = d(() => a.noCaret), B = d(() => a.noFlip), v = d(() => a.noShift), S = d(() => a.noSize), y = d(() => a.lazy), _ = d(() => a.splitDisabled), C = P(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), T = Se(C), k = W(null), N = W(null), V = W(null), A = W(null), E = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), K = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), oe = P(() => h.value ? N.value : V.value);
    Ge(
      "Escape",
      () => {
        r.value = !s;
      },
      { target: oe }
    ), Ge(
      "Escape",
      () => {
        r.value = !s;
      },
      { target: k }
    );
    const F = (L, j) => {
      var Z, Y, pe, ne;
      if (L.preventDefault(), !s.value) {
        M(), Fe(() => F(L, j));
        return;
      }
      const Q = (Z = k.value) == null ? void 0 : Z.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (Q)
        if ((Y = k.value) != null && Y.contains(document.activeElement)) {
          const Be = k.value.querySelector(".dropdown-item:focus"), ue = Array.prototype.indexOf.call(Q, Be) + j;
          ue >= 0 && ue < (Q == null ? void 0 : Q.length) && ((pe = Q[ue]) == null || pe.focus());
        } else
          (ne = Q[j === -1 ? Q.length - 1 : 0]) == null || ne.focus();
    };
    Ge("ArrowUp", (L) => F(L, -1), { target: oe }), Ge("ArrowDown", (L) => F(L, 1), { target: oe }), Ge("ArrowUp", (L) => F(L, -1), { target: k }), Ge("ArrowDown", (L) => F(L, 1), { target: k });
    const z = w(
      () => Lr({
        top: i.value,
        start: f.value,
        end: u.value,
        alignCenter: b.value,
        alignEnd: m.value
      })
    ), D = W({}), J = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const L = typeof a.offset == "string" || typeof a.offset == "number" ? T.value : a.offset, j = [dl(L)];
      return B.value === !1 && j.push(
        Sl({
          boundary: E.value,
          rootBoundary: K.value,
          padding: a.boundaryPadding
        })
      ), v.value === !1 && j.push(
        Bl({
          boundary: E.value,
          rootBoundary: K.value,
          padding: a.boundaryPadding
        })
      ), S.value === !1 && j.push(
        wl({
          boundary: E.value,
          rootBoundary: K.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: Q, availableHeight: Z }) {
            D.value = {
              maxHeight: Z && s.value ? `${Z}px` : void 0,
              maxWidth: Q && s.value ? `${Q}px` : void 0
            };
          }
        })
      ), j;
    }), { update: ie, floatingStyles: te } = kl(oe, k, {
      placement: z,
      middleware: J,
      strategy: P(() => a.strategy),
      whileElementsMounted: hl
    }), he = w(() => ({
      dropup: i.value,
      dropend: u.value,
      dropstart: f.value,
      "position-static": a.boundary !== "clippingAncestors" && !c.value
    })), Oe = w(() => [
      h.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": c.value,
        "dropdown-toggle": !h.value,
        "dropdown-toggle-no-caret": $.value && !h.value,
        show: h.value ? void 0 : s.value
      }
    ]), ve = () => {
      X();
    }, ge = (L) => {
      h.value ? l("click", L) : ve();
    };
    Ol(
      k,
      () => {
        s.value && (a.autoClose === !0 || a.autoClose === "outside") && X();
      },
      { ignore: [N, V] }
    );
    const ke = () => {
      s.value && (a.autoClose === !0 || a.autoClose === "inside") && X();
    }, Ce = () => {
      r.value && X();
    }, M = () => {
      r.value || X();
    }, X = () => {
      var Q;
      l("toggle");
      const L = s.value, j = new Vt(L ? "hide" : "show");
      if (l(L ? "hide" : "show", j), j.defaultPrevented) {
        l(L ? "hide-prevented" : "show-prevented");
        return;
      }
      r.value = !L, l(L ? "hidden" : "shown"), (Q = A.value) == null || Q.dispatchEvent(new Event("forceHide"));
    };
    return ce(s, () => {
      ie();
    }), t({
      close: Ce,
      open: M,
      toggle: X
    }), dt(jl, {
      id: n,
      open: M,
      close: Ce,
      toggle: X,
      visible: s,
      isNav: c
    }), (L, j) => (g(), I("div", {
      ref_key: "wrapper",
      ref: A,
      class: G([he.value, "btn-group"])
    }, [
      ye(Bt, {
        id: p(n),
        ref_key: "splitButton",
        ref: V,
        variant: L.splitVariant || L.variant,
        size: L.size,
        class: G(Oe.value),
        disabled: p(_) || L.disabled,
        type: L.splitButtonType,
        "aria-label": L.ariaLabel,
        "aria-expanded": p(h) ? void 0 : p(s),
        "aria-haspopup": p(h) ? void 0 : "menu",
        href: p(h) ? L.splitHref : void 0,
        to: p(h) && L.splitTo ? L.splitTo : void 0,
        onClick: ge
      }, {
        default: R(() => [
          O(L.$slots, "button-content", {}, () => [
            de(ae(L.text), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
      p(h) ? (g(), H(Bt, {
        key: 0,
        ref_key: "button",
        ref: N,
        variant: L.variant,
        size: L.size,
        disabled: L.disabled,
        class: G([[L.toggleClass, { show: p(s) }], "dropdown-toggle-split dropdown-toggle"]),
        "aria-expanded": p(s),
        "aria-haspopup": "menu",
        onClick: ve
      }, {
        default: R(() => [
          le("span", Gi, [
            O(L.$slots, "toggle-text", {}, () => [
              de(ae(L.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : se("", !0),
      (g(), H(_t, {
        to: L.container || "body",
        disabled: !L.container
      }, [
        !p(y) || p(s) ? wt((g(), I("ul", {
          key: 0,
          ref_key: "floating",
          ref: k,
          style: Me([p(te), D.value]),
          class: G(["dropdown-menu overflow-auto", [L.menuClass, { show: p(s) }]]),
          "aria-labelledby": p(n),
          role: L.role,
          onClick: ke
        }, [
          O(L.$slots, "default", {
            hide: Ce,
            show: M
          })
        ], 14, Ui)), [
          [ba, p(y) || p(s)]
        ]) : se("", !0)
      ], 8, ["to", "disabled"]))
    ], 2));
  }
}), Xi = { role: "presentation" }, Ki = /* @__PURE__ */ q({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, o) => (g(), I("li", Xi, [
      (g(), H(fe(t.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Yi = { role: "presentation" }, Zi = /* @__PURE__ */ q({
  __name: "BDropdownForm",
  setup(e) {
    return (t, o) => (g(), I("li", Yi, [
      le("form", ee({ class: "dropdown-item-text" }, t.$attrs), [
        O(t.$slots, "default")
      ], 16)
    ]));
  }
}), Ji = { role: "presentation" }, Qi = ["id", "aria-describedby"], eu = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(e) {
    const t = e, o = P(() => t.id ? `${t.id}_group_dd_header` : void 0), a = P(() => t.headerTag === "header" ? void 0 : "heading"), l = w(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== null
      }
    ]);
    return (n, r) => (g(), I("li", Ji, [
      (g(), H(fe(n.headerTag), {
        id: o.value,
        class: G(["dropdown-header", l.value]),
        role: a.value
      }, {
        default: R(() => [
          O(n.$slots, "header", {}, () => [
            de(ae(n.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      le("ul", ee({
        id: n.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": n.ariaDescribedby || o.value
      }), [
        O(n.$slots, "default")
      ], 16, Qi)
    ]));
  }
}), tu = { class: "dropdown-header" }, au = /* @__PURE__ */ q({
  __name: "BDropdownHeader",
  setup(e) {
    return (t, o) => (g(), I("li", null, [
      le("h6", tu, [
        O(t.$slots, "default")
      ])
    ]));
  }
}), ou = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, { class: l, ...n } = Zt(), r = d(() => o.active), s = d(() => o.disabled), { computedLink: i, computedLinkProps: u } = At(o), c = w(() => [
      o.linkClass,
      {
        active: r.value,
        disabled: s.value,
        [`text-${o.variant}`]: o.variant !== null
      }
    ]), f = P(() => i.value ? ft : o.href ? "a" : "button"), b = ze(so, null), m = ze(jl, null), h = ze(ro, null), $ = (B) => {
      var v, S, y;
      a("click", B), h !== null && ((v = h == null ? void 0 : h.autoClose) == null ? void 0 : v.value) === !0 && ((S = b == null ? void 0 : b.close) == null || S.call(b)), (y = m == null ? void 0 : m.close) == null || y.call(m);
    };
    return (B, v) => (g(), I("li", ee({
      role: "presentation",
      class: p(l)
    }, B.wrapperAttrs), [
      (g(), H(fe(f.value), ee({
        class: ["dropdown-item", c.value],
        disabled: p(s),
        "aria-disabled": p(s) ? !0 : null,
        "aria-current": p(r) ? !0 : null,
        href: f.value === "a" ? B.href : null,
        rel: B.rel,
        role: "menuitem",
        type: f.value === "button" ? "button" : null,
        target: B.target
      }, { ...p(u), ...n }, { onClick: $ }), {
        default: R(() => [
          O(B.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
}), lu = { role: "presentation" }, nu = ["disabled"], su = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    active: { type: [Boolean, String], default: !1 },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.active), n = d(() => o.disabled), r = w(() => [
      o.buttonClass,
      {
        [o.activeClass]: l.value,
        disabled: n.value,
        [`text-${o.variant}`]: o.variant !== null
      }
    ]), s = (i) => {
      a("click", i);
    };
    return (i, u) => (g(), I("li", lu, [
      le("button", {
        role: "menu",
        type: "button",
        class: G(["dropdown-item", r.value]),
        disabled: p(n),
        onClick: s
      }, [
        O(i.$slots, "default")
      ], 10, nu)
    ]));
  }
}), ru = { role: "presentation" }, iu = /* @__PURE__ */ q({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, o) => (g(), I("li", ru, [
      le("span", ee({ class: "dropdown-item-text" }, t.$attrs), [
        O(t.$slots, "default", {}, () => [
          de(ae(t.text), 1)
        ])
      ], 16)
    ]));
  }
}), uu = ["id", "novalidate"], wn = /* @__PURE__ */ q({
  __name: "BForm",
  props: {
    floating: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    novalidate: { type: [Boolean, String], default: !1 },
    validated: { type: [Boolean, String], default: !1 }
  },
  emits: ["submit"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = W(null), r = d(() => a.floating), s = d(() => a.novalidate), i = d(() => a.validated), u = w(() => ({
      "form-floating": r.value,
      "was-validated": i.value
    })), c = (f) => {
      l("submit", f);
    };
    return t({
      element: n
    }), (f, b) => (g(), I("form", {
      id: f.id,
      ref_key: "element",
      ref: n,
      novalidate: p(s),
      class: G(u.value),
      onSubmit: ht(c, ["prevent"])
    }, [
      O(f.$slots, "default")
    ], 42, uu));
  }
}), du = { class: "form-floating" }, cu = ["for"], fu = /* @__PURE__ */ q({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, o) => (g(), I("div", du, [
      O(t.$slots, "default", {}, () => [
        de(ae(t.text), 1)
      ]),
      le("label", { for: t.labelFor }, [
        O(t.$slots, "label", {}, () => [
          de(ae(t.label), 1)
        ])
      ], 8, cu)
    ]));
  }
}), xa = /* @__PURE__ */ q({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.forceShow), a = d(() => t.state), l = d(() => t.tooltip), n = P(() => o.value === !0 || a.value === !1), r = w(() => ({
      "d-block": n.value,
      "invalid-feedback": !l.value,
      "invalid-tooltip": l.value
    }));
    return (s, i) => (g(), H(fe(s.tag), {
      id: s.id,
      role: s.role,
      "aria-live": s.ariaLive,
      "aria-atomic": s.ariaLive ? !0 : void 0,
      class: G(r.value)
    }, {
      default: R(() => [
        O(s.$slots, "default", {}, () => [
          de(ae(s.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), ua = /* @__PURE__ */ q({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, o) => (g(), H(fe(t.tag), { class: "row d-flex flex-wrap" }, {
      default: R(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Ma = /* @__PURE__ */ q({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: [Boolean, String], default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(e) {
    const t = e, o = d(() => t.inline), a = w(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      "form-text": !o.value
    }));
    return (l, n) => (g(), H(fe(l.tag), {
      id: l.id,
      class: G(a.value)
    }, {
      default: R(() => [
        O(l.$slots, "default", {}, () => [
          de(ae(l.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Da = /* @__PURE__ */ q({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.forceShow), a = d(() => t.state), l = d(() => t.tooltip), n = P(() => o.value === !0 || a.value === !0), r = w(() => ({
      "d-block": n.value,
      "valid-feedback": !l.value,
      "valid-tooltip": l.value
    }));
    return (s, i) => (g(), H(fe(s.tag), {
      id: s.id,
      role: s.role,
      "aria-live": s.ariaLive,
      "aria-atomic": s.ariaLive ? !0 : void 0,
      class: G(r.value)
    }, {
      default: R(() => [
        O(s.$slots, "default", {}, () => [
          de(ae(s.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Cn = q({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, { slots: t, attrs: o }) {
    return () => {
      var a, l, n;
      return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === "Teleport" ? Re(_t, { to: e.to }, [(l = t.default) == null ? void 0 : l.call(t)]) : Re(e.tag, { ...o }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
}), vu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"], pu = ["for"], kn = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    button: { type: [Boolean, String], default: !1 },
    buttonGroup: { type: [Boolean, String], default: !1 },
    buttonVariant: { default: null },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: [Boolean, String], default: !1 },
    inline: { type: [Boolean, String], default: !1 },
    modelValue: { type: [Boolean, String, Object, Number, null], default: void 0 },
    name: { default: void 0 },
    plain: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: void 0 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    switch: { type: [Boolean, String], default: !1 },
    uncheckedValue: { type: [Boolean, String, Object, Number, null], default: !1 },
    value: { type: [Boolean, String, Object, Number, null], default: !0 }
  },
  emits: ["update:modelValue", "update:indeterminate"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = _e(a, "modelValue", l, { passive: !0 }), s = _e(a, "indeterminate", l), i = Pe(() => a.id, "form-check"), u = d(() => a.indeterminate), c = d(() => a.autofocus), f = d(() => a.plain), b = d(() => a.button), m = d(() => a.buttonGroup), h = d(() => a.switch), $ = d(() => a.disabled), B = d(() => a.inline), v = d(() => a.required), S = d(() => a.state), y = ze(Ml, null), _ = W(null), { focused: C } = De(_, {
      initialValue: c.value
    }), T = P(() => !He(n.default)), k = w({
      get: () => (y == null ? void 0 : y.modelValue.value) ?? r.value,
      set: (F) => {
        if (F !== void 0) {
          if (s.value = !1, y !== null && Array.isArray(F)) {
            y.modelValue.value = F;
            return;
          }
          r.value = F;
        }
      }
    }), N = P(
      () => !!(a.name ?? (y == null ? void 0 : y.name.value)) && (v.value || (y == null ? void 0 : y.required.value))
    ), V = P(() => m.value || ((y == null ? void 0 : y.buttons.value) ?? !1)), A = w(() => ({
      plain: f.value || ((y == null ? void 0 : y.plain.value) ?? !1),
      button: b.value || ((y == null ? void 0 : y.buttons.value) ?? !1),
      inline: B.value || ((y == null ? void 0 : y.inline.value) ?? !1),
      switch: h.value || ((y == null ? void 0 : y.switch.value) ?? !1),
      state: S.value || (y == null ? void 0 : y.state.value),
      size: a.size ?? (y == null ? void 0 : y.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant ?? (y == null ? void 0 : y.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), E = Zl(A), K = Jl(A), oe = Ql(A);
    return t({
      blur: () => {
        C.value = !1;
      },
      element: _,
      focus: () => {
        C.value = !0;
      }
    }), (F, z) => (g(), H(Cn, {
      skip: V.value,
      class: G(p(E))
    }, {
      default: R(() => {
        var D, J, ie;
        return [
          wt(le("input", ee({ id: p(i) }, F.$attrs, {
            ref_key: "input",
            ref: _,
            "onUpdate:modelValue": z[0] || (z[0] = (te) => k.value = te),
            class: p(K),
            type: "checkbox",
            disabled: p($) || ((D = p(y)) == null ? void 0 : D.disabled.value),
            required: N.value || void 0,
            name: F.name || ((J = p(y)) == null ? void 0 : J.name.value),
            form: F.form || ((ie = p(y)) == null ? void 0 : ie.form.value),
            "aria-label": F.ariaLabel,
            "aria-labelledby": F.ariaLabelledby,
            "aria-required": N.value || void 0,
            value: F.value,
            "true-value": F.value,
            "false-value": F.uncheckedValue,
            indeterminate: p(u)
          }), null, 16, vu), [
            [Dn, k.value]
          ]),
          T.value || p(f) === !1 ? (g(), I("label", {
            key: 0,
            for: p(i),
            class: G(p(oe))
          }, [
            O(F.$slots, "default")
          ], 10, pu)) : se("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), mu = ["id"], gu = ["innerHTML"], bu = /* @__PURE__ */ q({
  __name: "BFormCheckboxGroup",
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: "md" },
    stacked: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String, null], default: null },
    switches: { type: [Boolean, String], default: !1 },
    textField: { default: "text" },
    validated: { type: [Boolean, String], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["change", "input", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = _e(a, "modelValue", l, { passive: !0 }), r = Pe(() => a.id, "checkbox"), s = Pe(() => a.name, "checkbox"), i = d(() => a.autofocus), u = d(() => a.buttons), c = d(() => a.disabled), f = d(() => a.plain), b = d(() => a.required), m = d(() => a.stacked), h = d(() => a.state), $ = d(() => a.switches), B = d(() => a.validated), v = W(null), { focused: S } = De(v, {
      initialValue: i.value
    });
    dt(Ml, {
      modelValue: n,
      switch: $,
      buttonVariant: P(() => a.buttonVariant),
      form: P(() => a.form),
      name: s,
      state: h,
      plain: f,
      size: P(() => a.size),
      inline: P(() => !m.value),
      required: b,
      buttons: u,
      disabled: c
    }), ce(n, (k) => {
      l("input", [...k]), Fe(() => {
        l("change", [...k]);
      });
    });
    const y = w(
      () => a.options.map(
        (k, N) => typeof k == "string" || typeof k == "number" ? {
          props: {
            value: k,
            disabled: c.value
          },
          text: k.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${N}`)
        } : {
          props: {
            value: k[a.valueField],
            disabled: k[a.disabledField],
            ...k.props ? k.props : {}
          },
          text: k[a.textField],
          html: k[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${N}`)
        }
      )
    ), _ = w(() => ({
      required: b.value,
      ariaInvalid: a.ariaInvalid,
      state: h.value,
      validated: B.value,
      buttons: u.value,
      stacked: m.value,
      size: a.size
    })), C = en(_), T = tn(_);
    return t({
      blur: () => {
        S.value = !1;
      },
      focus: () => {
        S.value = !0;
      }
    }), (k, N) => (g(), I("div", ee(p(C), {
      id: p(r),
      ref_key: "element",
      ref: v,
      role: "group",
      class: [p(T), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      O(k.$slots, "first"),
      (g(!0), I(me, null, Ee(y.value, (V) => (g(), H(kn, ee({
        key: V.self
      }, V.props), {
        default: R(() => [
          V.html ? (g(), I("span", {
            key: 0,
            innerHTML: V.html
          }, null, 8, gu)) : (g(), I(me, { key: 1 }, [
            de(ae(V.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      O(k.$slots, "default")
    ], 16, mu));
  }
}), yu = ["for"], hu = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-required", "directory", "webkitdirectory"], Bu = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: {
    accept: { default: "" },
    autofocus: { type: [Boolean, String], default: !1 },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: { default: null },
    multiple: { type: [Boolean, String], default: !1 },
    name: { default: void 0 },
    noDrop: { type: [Boolean, String], default: !1 },
    noTraverse: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = je(), l = e, r = _e(l, "modelValue", o, { passive: !0 }), s = Pe(() => l.id), i = d(() => l.autofocus), u = d(() => l.directory), c = d(() => l.disabled), f = d(() => l.multiple), b = d(() => l.noDrop);
    d(() => l.noTraverse);
    const m = d(() => l.required), h = d(() => l.state), $ = d(() => l.capture), B = Ot(h), v = W(null), { focused: S } = De(v, { initialValue: i.value }), y = P(() => !He(a.label)), _ = P(
      () => typeof l.accept == "string" ? l.accept : l.accept.join(",")
    ), C = w(() => [
      B.value,
      {
        [`form-control-${l.size}`]: l.size !== void 0
      }
    ]), T = () => {
      var A, E;
      const V = ((A = v.value) == null ? void 0 : A.files) === null || ((E = v.value) == null ? void 0 : E.files) === void 0 ? null : [...v.value.files];
      r.value = V === null ? null : f.value === !0 ? V : V[0];
    }, k = (V) => {
      b.value === !0 && V.preventDefault();
    }, N = () => {
      r.value = null;
    };
    return ce(r, (V) => {
      V === null && v.value !== null && (v.value.value = "");
    }), t({
      blur: () => {
        S.value = !1;
      },
      element: v,
      focus: () => {
        S.value = !0;
      },
      reset: N
    }), (V, A) => (g(), I(me, null, [
      y.value || V.label ? (g(), I("label", {
        key: 0,
        for: p(s),
        class: G(["form-label", V.labelClass])
      }, [
        O(V.$slots, "label", {}, () => [
          de(ae(V.label), 1)
        ])
      ], 10, yu)) : se("", !0),
      le("input", ee({ id: p(s) }, V.$attrs, {
        ref_key: "input",
        ref: v,
        type: "file",
        class: ["form-control", C.value],
        form: V.form,
        name: V.name,
        multiple: p(f),
        disabled: p(c),
        capture: p($),
        accept: _.value || void 0,
        required: p(m) || void 0,
        "aria-required": p(m) || void 0,
        directory: p(u),
        webkitdirectory: p(u),
        onChange: T,
        onDrop: k
      }), null, 16, hu)
    ], 64));
  }
}), $n = ["input", "select", "textarea"], Su = $n.map((e) => `${e}:not([disabled])`).join(), wu = [...$n, "a", "button", "label"], Cu = "label", ku = "invalid-feedback", $u = "valid-feedback", Tu = "description", _u = "default", Vu = q({
  components: { BCol: Ut, BFormInvalidFeedback: xa, BFormRow: ua, BFormText: Ma, BFormValidFeedback: Da },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = d(() => e.disabled), o = d(() => e.labelSrOnly), a = d(() => e.state), l = d(() => e.tooltip), n = d(() => e.validated), r = d(() => e.floating), s = null, i = ["xs", "sm", "md", "lg", "xl"], u = (_, C) => i.reduce((T, k) => {
      const N = Io(k === "xs" ? "" : k, `${C}Align`), V = _[N] || null;
      return V && (k === "xs" ? T.push(`text-${V}`) : T.push(`text-${k}-${V}`)), T;
    }, []), c = (_, C) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i.reduce((T, k) => {
        const N = Io(k === "xs" ? "" : k, `${C}Cols`);
        let V = _[N];
        if (V = V === "" ? !0 : V || !1, typeof V != "boolean" && V !== "auto") {
          const A = Number.parseInt(V);
          V = Number.isNaN(A) ? 0 : A, V = V > 0 ? V : !1;
        }
        return V && (k === "xs" ? T[typeof V == "boolean" ? "col" : "cols"] = V : T[k || (typeof V == "boolean" ? "col" : "cols")] = V), T;
      }, {})
    ), f = W(null), b = (_, C = null) => {
      if (Xa && e.labelFor && f.value !== null) {
        const T = f.value.querySelector(`#${CSS.escape(e.labelFor)}`);
        if (T) {
          const k = "aria-describedby", N = (_ || "").split(ra), V = (C || "").split(ra), A = (T.getAttribute(k) || "").split(ra).filter((E) => !V.includes(E)).concat(N).filter((E, K, oe) => oe.indexOf(E) === K).filter((E) => E).join(" ").trim();
          A ? T.setAttribute(k, A) : T.removeAttribute(k);
        }
      }
    }, m = w(() => c(e, "content")), h = w(() => u(e, "label")), $ = w(() => c(e, "label")), B = w(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(m.value).length > 0 || Object.keys($.value).length > 0
      )
    ), v = Ot(a), S = ya(() => e.ariaInvalid, a);
    return ce(
      () => s,
      (_, C) => {
        _ !== C && b(_, C);
      }
    ), at(() => {
      Fe(() => {
        b(s);
      });
    }), {
      disabledBoolean: t,
      labelSrOnlyBoolean: o,
      stateBoolean: a,
      tooltipBoolean: l,
      validatedBoolean: n,
      floatingBoolean: r,
      ariaDescribedby: s,
      computedAriaInvalid: S,
      contentColProps: m,
      isHorizontal: B,
      labelAlignClasses: h,
      labelColProps: $,
      onLegendClick: (_) => {
        if (e.labelFor || f.value === null)
          return;
        const { target: C } = _, T = C ? C.tagName : "";
        if (wu.indexOf(T) !== -1)
          return;
        const k = [...f.value.querySelectorAll(Su)].filter(ts), [N] = k;
        k.length === 1 && N instanceof HTMLElement && es(N);
      },
      stateClass: v
    };
  },
  render() {
    const e = this.$props, t = this.$slots, o = Pe(), a = !e.labelFor;
    let l = null;
    const n = Wt(Cu, {}, t) || e.label, r = n ? Gt("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const _ = a ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (l = Re(
          _,
          {
            class: "visually-hidden",
            id: r,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? l = Re(Ut, this.labelColProps, { default: () => l }) : l = Re("div", {}, [l]);
      else {
        const C = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? _ : null,
          id: r,
          for: e.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? l = Re(Ut, C, { default: () => n }) : l = Re(_, C, n);
      }
    }
    let s = null;
    const i = Wt(ku, {}, t) || this.invalidFeedback, u = i ? Gt("_BV_feedback_invalid_") : void 0;
    i && (s = Re(
      xa,
      {
        ariaLive: e.feedbackAriaLive,
        id: u,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => i }
    ));
    let c = null;
    const f = Wt($u, {}, t) || this.validFeedback, b = f ? Gt("_BV_feedback_valid_") : void 0;
    f && (c = Re(
      Da,
      {
        ariaLive: e.feedbackAriaLive,
        id: b,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => f }
      // validFeedbackContent
    ));
    let m = null;
    const h = Wt(Tu, {}, t) || this.description, $ = h ? Gt("_BV_description_") : void 0;
    h && (m = Re(
      Ma,
      {
        id: $
      },
      { default: () => h }
    ));
    const B = this.ariaDescribedby = [
      $,
      this.stateBoolean === !1 ? u : null,
      this.stateBoolean === !0 ? b : null
    ].filter((_) => _).join(" ") || null, v = [
      Wt(_u, { ariaDescribedby: B, descriptionId: $, id: o, labelId: r }, t) || "",
      s,
      c,
      m
    ];
    !this.isHorizontal && this.floatingBoolean && v.push(l);
    let S = Re(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      v
    );
    this.isHorizontal && (S = Re(Ut, { ref: "content", ...this.contentColProps }, { default: () => v }));
    const y = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: Pe(() => e.id).value,
      disabled: a ? this.disabledBoolean : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !a ? Re(ua, y, { default: () => [l, S] }) : Re(
      a ? "fieldset" : "div",
      y,
      this.isHorizontal && a ? [Re(ua, null, { default: () => [l, S] })] : this.isHorizontal || !this.floatingBoolean ? [l, S] : [S]
    );
  }
}), Au = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Ou = /* @__PURE__ */ q({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [Boolean, String], default: !1 },
    lazyFormatter: { type: [Boolean, String], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [Boolean, String], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [Boolean, String], default: !1 },
    readonly: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    trim: { type: [Boolean, String], default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, { input: n, computedId: r, computedAriaInvalid: s, onInput: i, onChange: u, onBlur: c, focus: f, blur: b } = an(a, l), m = d(() => a.disabled), h = d(() => a.required), $ = d(() => a.readonly), B = d(() => a.plaintext), v = d(() => a.state), S = Ot(v), y = W(!1), _ = w(() => {
      const C = a.type === "range", T = a.type === "color";
      return [
        S.value,
        {
          "form-control-highlighted": y.value,
          "form-range": C,
          "form-control": T || !B.value && !C,
          "form-control-color": T,
          "form-control-plaintext": B.value && !C && !T,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return t({
      blur: b,
      element: n,
      focus: f
    }), (C, T) => (g(), I("input", {
      id: p(r),
      ref_key: "input",
      ref: n,
      value: C.modelValue,
      class: G(_.value),
      name: C.name || void 0,
      form: C.form || void 0,
      type: C.type,
      disabled: p(m),
      placeholder: C.placeholder,
      required: p(h) || void 0,
      autocomplete: C.autocomplete || void 0,
      readonly: p($) || p(B),
      min: C.min,
      max: C.max,
      step: C.step,
      list: C.type !== "password" ? C.list : void 0,
      "aria-required": p(h) || void 0,
      "aria-invalid": p(s),
      onInput: T[0] || (T[0] = (k) => p(i)(k)),
      onChange: T[1] || (T[1] = (k) => p(u)(k)),
      onBlur: T[2] || (T[2] = (k) => p(c)(k))
    }, null, 42, Au));
  }
}), Eu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Pu = ["for"], Tn = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    button: { type: [Boolean, String], default: !1 },
    buttonGroup: { type: [Boolean, String], default: !1 },
    buttonVariant: { default: null },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: [Boolean, String], default: !1 },
    modelValue: { type: [String, Boolean, Object, Number, null], default: void 0 },
    name: { default: void 0 },
    plain: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    value: { type: [String, Boolean, Object, Number, null], default: !0 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = _e(a, "modelValue", l, { passive: !0 }), s = Pe(() => a.id, "form-check"), i = d(() => a.autofocus), u = d(() => a.plain), c = d(() => a.button), f = d(() => a.buttonGroup), b = d(() => a.disabled), m = d(() => a.inline), h = d(() => a.required), $ = d(() => a.state), B = ze(Dl, null), v = W(null), { focused: S } = De(v, {
      initialValue: i.value
    }), y = P(() => !He(n.default)), _ = w({
      get: () => (B == null ? void 0 : B.modelValue.value) ?? r.value,
      set: (E) => {
        if (E !== void 0) {
          if (B !== null) {
            B.modelValue.value = E;
            return;
          }
          r.value = E;
        }
      }
    }), C = P(
      () => !!(a.name ?? (B == null ? void 0 : B.name.value)) && (h.value || (B == null ? void 0 : B.required.value))
    ), T = P(() => f.value || ((B == null ? void 0 : B.buttons.value) ?? !1)), k = w(() => ({
      plain: u.value || ((B == null ? void 0 : B.plain.value) ?? !1),
      button: c.value || ((B == null ? void 0 : B.buttons.value) ?? !1),
      inline: m.value || ((B == null ? void 0 : B.inline.value) ?? !1),
      state: $.value || (B == null ? void 0 : B.state.value),
      size: a.size ?? (B == null ? void 0 : B.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant ?? (B == null ? void 0 : B.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), N = Zl(k), V = Jl(k), A = Ql(k);
    return t({
      blur: () => {
        S.value = !1;
      },
      element: v,
      focus: () => {
        S.value = !0;
      }
    }), (E, K) => (g(), H(Cn, {
      skip: T.value,
      class: G(p(N))
    }, {
      default: R(() => {
        var oe, F, z;
        return [
          wt(le("input", ee({ id: p(s) }, E.$attrs, {
            ref_key: "input",
            ref: v,
            "onUpdate:modelValue": K[0] || (K[0] = (D) => _.value = D),
            class: p(V),
            type: "radio",
            disabled: p(b) || ((oe = p(B)) == null ? void 0 : oe.disabled.value),
            required: C.value || void 0,
            name: E.name || ((F = p(B)) == null ? void 0 : F.name.value),
            form: E.form || ((z = p(B)) == null ? void 0 : z.form.value),
            "aria-label": E.ariaLabel,
            "aria-labelledby": E.ariaLabelledby,
            value: E.value,
            "aria-required": C.value || void 0
          }), null, 16, Eu), [
            [jn, _.value]
          ]),
          y.value || p(u) === !1 ? (g(), I("label", {
            key: 0,
            for: p(s),
            class: G(p(A))
          }, [
            O(E.$slots, "default")
          ], 10, Pu)) : se("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Nu = ["id"], Iu = ["innerHTML"], Fu = /* @__PURE__ */ q({
  __name: "BFormRadioGroup",
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [String, Boolean, Object, Number, null], default: null },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: "md" },
    stacked: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String, null], default: null },
    textField: { default: "text" },
    validated: { type: [Boolean, String], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["change", "input", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = _e(a, "modelValue", l, { passive: !0 }), r = Pe(() => a.id, "radio"), s = Pe(() => a.name, "checkbox"), i = d(() => a.autofocus), u = d(() => a.buttons), c = d(() => a.disabled), f = d(() => a.plain), b = d(() => a.required), m = d(() => a.stacked), h = d(() => a.state), $ = d(() => a.validated), B = W(null), { focused: v } = De(B, {
      initialValue: i.value
    });
    dt(Dl, {
      modelValue: n,
      buttonVariant: P(() => a.buttonVariant),
      form: P(() => a.form),
      name: s,
      buttons: u,
      state: h,
      plain: f,
      size: P(() => a.size),
      inline: P(() => !m.value),
      required: b,
      disabled: c
    }), ce(n, (T) => {
      l("input", T), Fe(() => {
        l("change", T);
      });
    });
    const S = w(
      () => a.options.map(
        (T, k) => typeof T == "string" || typeof T == "number" ? {
          value: T,
          disabled: c.value,
          text: T.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${k}`)
        } : {
          value: T[a.valueField],
          disabled: T[a.disabledField],
          ...T.props ? T.props : {},
          text: T[a.textField],
          html: T[a.htmlField],
          self: Symbol(`radioGroupOptionItem${k}`)
        }
      )
    ), y = w(() => ({
      required: b.value,
      ariaInvalid: a.ariaInvalid,
      state: h.value,
      validated: $.value,
      buttons: u.value,
      stacked: m.value,
      size: a.size
    })), _ = en(y), C = tn(y);
    return t({
      blur: () => {
        v.value = !1;
      },
      focus: () => {
        v.value = !0;
      }
    }), (T, k) => (g(), I("div", ee(p(_), {
      id: p(r),
      ref_key: "element",
      ref: B,
      role: "radiogroup",
      class: [p(C), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      O(T.$slots, "first"),
      (g(!0), I(me, null, Ee(S.value, (N) => (g(), H(Tn, {
        key: N.self,
        disabled: N.disabled,
        value: N.value
      }, {
        default: R(() => [
          N.html ? (g(), I("span", {
            key: 0,
            innerHTML: N.html
          }, null, 8, Iu)) : (g(), I(me, { key: 1 }, [
            de(ae(N.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      O(T.$slots, "default")
    ], 16, Nu));
  }
}), Lu = ["value", "disabled"], po = /* @__PURE__ */ q({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: [Boolean, String], default: !1 },
    value: { default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.disabled);
    return (a, l) => (g(), I("option", {
      value: a.value,
      disabled: p(o)
    }, [
      O(a.$slots, "default")
    ], 8, Lu));
  }
}), zu = ["label"], Hu = ["innerHTML"], _n = /* @__PURE__ */ q({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, { normalizedOptions: o } = on(() => t.options, t), a = w(() => o.value);
    return (l, n) => (g(), I("optgroup", { label: l.label }, [
      O(l.$slots, "first"),
      (g(!0), I(me, null, Ee(a.value, (r, s) => (g(), H(po, ee({
        key: s,
        disabled: r.disabled,
        value: r.value
      }, l.$attrs), {
        default: R(() => [
          r.html ? (g(), I("span", {
            key: 0,
            innerHTML: r.html
          }, null, 8, Hu)) : (g(), I(me, { key: 1 }, [
            de(ae(r.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      O(l.$slots, "default")
    ], 8, zu));
  }
}), Ru = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], xu = ["innerHTML"], Mu = /* @__PURE__ */ q({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [String, Object, Number, Boolean, null], default: "" },
    multiple: { type: [Boolean, String], default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, String, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, n = _e(a, "modelValue", o, { passive: !0 }), r = Pe(() => a.id, "input"), s = d(() => a.autofocus), i = d(() => a.disabled), u = d(() => a.multiple), c = d(() => a.plain), f = d(() => a.required), b = d(() => a.state), m = Se(() => a.selectSize), h = Ot(b), $ = W(null), { focused: B } = De($, {
      initialValue: s.value
    }), v = w(() => [
      h.value,
      {
        "form-control": c.value,
        [`form-control-${a.size}`]: a.size !== "md" && c.value,
        "form-select": !c.value,
        [`form-select-${a.size}`]: a.size !== "md" && !c.value
      }
    ]), S = P(
      () => m.value || c.value ? m.value : void 0
    ), y = ya(() => a.ariaInvalid, b), { normalizedOptions: _, isComplex: C } = on(() => a.options, a), T = w(
      () => _.value
    ), k = w({
      get: () => n.value,
      set: (N) => {
        n.value = N;
      }
    });
    return t({
      blur: () => {
        B.value = !1;
      },
      element: $,
      focus: () => {
        B.value = !0;
      }
    }), (N, V) => wt((g(), I("select", {
      id: p(r),
      ref_key: "input",
      ref: $,
      "onUpdate:modelValue": V[0] || (V[0] = (A) => k.value = A),
      class: G(v.value),
      name: N.name,
      form: N.form || void 0,
      multiple: p(u) || void 0,
      size: S.value,
      disabled: p(i),
      required: p(f) || void 0,
      "aria-required": p(f) || void 0,
      "aria-invalid": p(y)
    }, [
      O(N.$slots, "first"),
      (g(!0), I(me, null, Ee(T.value, (A, E) => (g(), I(me, { key: E }, [
        p(C)(A) ? (g(), H(_n, {
          key: 0,
          label: A.label,
          options: A.options,
          "value-field": N.valueField,
          "text-field": N.textField,
          "html-field": N.htmlField,
          "disabled-field": N.disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (g(), H(po, {
          key: 1,
          value: A.value,
          disabled: A.disabled
        }, {
          default: R(() => [
            A.html ? (g(), I("span", {
              key: 0,
              innerHTML: A.html
            }, null, 8, xu)) : (g(), I(me, { key: 1 }, [
              de(ae(A.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      O(N.$slots, "default")
    ], 10, Ru)), [
      [qn, k.value]
    ]);
  }
}), Oa = "ArrowDown", Mo = "End", Do = "Home", jo = "PageDown", qo = "PageUp", Ea = "ArrowUp", Du = ["lang", "tabindex", "title"], ju = ["name", "form", "value"], qu = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"], We = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
}, Wu = /* @__PURE__ */ q({
  __name: "BFormSpinbutton",
  props: {
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: [Boolean, String], default: !1 },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: We.max },
    min: { default: We.min },
    modelValue: { default: null },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: [Boolean, String], default: !1 },
    repeatDelay: { default: We.repeatDelay },
    repeatInterval: { default: We.repeatInterval },
    repeatStepMultiplier: { default: We.repeatMultiplier },
    repeatThreshold: { default: We.repeatThreshold },
    required: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    step: { default: We.step },
    vertical: { type: [Boolean, String], default: !1 },
    wrap: { type: [Boolean, String], default: !1 }
  },
  emits: ["change", "update:modelValue"],
  setup(e, { emit: t }) {
    const o = [Ea, Oa, Do, Mo, qo, jo], a = e, l = t, n = _e(a, "modelValue", l, { passive: !0 }), r = W(null), { focused: s } = De(r), i = Pe(() => a.id, "spinbutton"), u = d(() => a.disabled), c = d(() => a.inline), f = d(() => a.readonly), b = d(() => a.vertical), m = d(() => a.required), h = d(() => a.wrap), $ = d(() => a.state), B = w(() => ({
      disabled: u.value,
      readonly: f.value,
      focus: s.value,
      "d-inline-flex": c.value || b.value,
      "d-flex": !c.value && !b.value,
      "align-items-stretch": !b.value,
      "flex-column": b.value,
      [`form-control-${a.size}`]: a.size !== void 0
    })), v = w(() => ({
      "d-flex": b.value,
      "align-self-center": !b.value,
      "align-items-center": b.value,
      "border-top": b.value,
      "border-bottom": b.value,
      "border-start": !b.value,
      "border-end": !b.value
    }));
    let S, y, _ = !1;
    const C = Se(() => a.step), T = P(
      () => Number.isNaN(C.value) ? We.step : C.value
    ), k = Se(() => a.min), N = P(
      () => Number.isNaN(k.value) ? We.min : k.value
    ), V = Se(() => a.max), A = P(() => {
      const x = T.value, U = N.value;
      return Math.floor((V.value - U) / x) * x + U;
    }), E = Se(() => a.repeatDelay, {
      nanToZero: !0,
      method: "parseInt"
    }), K = P(
      () => E.value > 0 ? E.value : We.repeatDelay
    ), oe = Se(() => a.repeatInterval, {
      nanToZero: !0,
      method: "parseInt"
    }), F = P(
      () => oe.value > 0 ? oe.value : We.repeatInterval
    ), z = Se(() => a.repeatThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), D = P(
      () => Math.max(
        Number.isNaN(z.value) ? We.repeatThreshold : z.value,
        1
      )
    ), J = Se(() => a.repeatStepMultiplier, {
      nanToZero: !0,
      method: "parseInt"
    }), ie = P(
      () => Math.max(
        Number.isNaN(J.value) ? We.repeatMultiplier : J.value,
        1
      )
    ), te = P(() => {
      const x = T.value;
      return Math.floor(x) === x ? 0 : (x.toString().split(".")[1] || "").length;
    }), he = P(() => Math.pow(10, te.value || 0)), Oe = P(
      () => n.value === null ? "" : n.value.toFixed(te.value)
    ), { isRtl: ve, locale: ge } = Ur(), ke = w(() => {
      const U = [(a.locale ?? (ge == null ? void 0 : ge.value)) || "locale"];
      return new Intl.NumberFormat(U).resolvedOptions().locale;
    }), Ce = () => new Intl.NumberFormat(ke.value, {
      style: "decimal",
      useGrouping: !1,
      minimumIntegerDigits: 1,
      minimumFractionDigits: te.value,
      maximumFractionDigits: te.value,
      notation: "standard"
    }).format, M = P(() => a.formatterFn ?? Ce()), X = (x) => {
      let { value: U } = n;
      if (!u.value && U !== null) {
        const re = T.value * x, Te = N.value, $e = A.value, Ve = he.value, { wrap: ot } = a;
        U = Math.round((U - Te) / re) * re + Te + re, U = Math.round(U * Ve) / Ve, n.value = U > $e ? ot ? Te : $e : U < Te ? ot ? $e : Te : U;
      }
    }, L = (x = 1) => {
      if (n.value === null) {
        n.value = N.value;
        return;
      }
      X(1 * x);
    }, j = (x = 1) => {
      if (n.value === null) {
        n.value = h.value ? A.value : N.value;
        return;
      }
      X(-1 * x);
    }, Q = (x) => {
      x.preventDefault(), x.stopImmediatePropagation();
    };
    Ge(
      o,
      (x) => {
        const { code: U, altKey: re, ctrlKey: Te, metaKey: $e } = x;
        if (!(u.value || f.value || re || Te || $e) && (Q(x), !_)) {
          if (Be(), [Ea, Oa].includes(U)) {
            if (_ = !0, U === Ea) {
              Z(x, L);
              return;
            }
            U === Oa && Z(x, j);
            return;
          }
          if (U === qo) {
            L(ie.value);
            return;
          }
          if (U === jo) {
            j(ie.value);
            return;
          }
          if (U === Do) {
            n.value = N.value;
            return;
          }
          U === Mo && (n.value = A.value);
        }
      },
      { target: r, eventName: "keydown" }
    ), Ge(
      o,
      (x) => {
        const { altKey: U, ctrlKey: re, metaKey: Te } = x;
        u.value || f.value || U || re || Te || (Q(x), Be(), _ = !1, l("change", n.value));
      },
      { target: r, eventName: "keyup" }
    );
    const Z = (x, U) => {
      const { type: re } = x || {};
      if (!u.value && !f.value) {
        if (Y(x) && re === "mousedown" && x.button)
          return;
        Be(), U(1);
        const Te = D.value, $e = ie.value, Ve = K.value, ot = F.value;
        S = setTimeout(() => {
          let lt = 0;
          y = setInterval(() => {
            U(lt < Te ? 1 : $e), lt++;
          }, ot);
        }, Ve);
      }
    }, Y = (x) => x.type === "mouseup" || x.type === "mousedown", pe = (x) => {
      Y(x) && x.type === "mouseup" && x.button || (Q(x), Be(), ne(!1), l("change", n.value));
    }, ne = (x) => {
      try {
        ho(x, [document.body, "mouseup", pe, !1]), ho(x, [document.body, "touchend", pe, !1]);
      } catch {
      }
    }, Be = () => {
      clearTimeout(S), clearInterval(y), S = void 0, y = void 0;
    }, ue = w(() => {
      const x = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, U = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, re = {
        class: [{ "py-0": !b.value }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: u.value || f.value,
        "aria-disabled": u.value || f.value ? !0 : void 0,
        "aria-controls": i.value
      }, Te = {
        "aria-hidden": !0,
        scale: s.value ? 1.5 : 1.25
      }, $e = (lt, qt) => {
        !u.value && !f.value && (Q(lt), ne(!0), s.value = !0, Z(lt, qt));
      }, Ve = {
        button: {
          ...re,
          "aria-label": a.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...Te,
          ...x.svg
        },
        path: {
          ...x.path
        },
        slot: {
          name: "increment"
        },
        handler: (lt) => $e(lt, L)
      }, ot = {
        button: {
          ...re,
          "aria-label": a.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...Te,
          ...U.svg
        },
        path: {
          ...U.path
        },
        slot: {
          name: "decrement"
        },
        handler: (lt) => $e(lt, j)
      };
      return {
        top: {
          ...b.value ? Ve : ot
        },
        bottom: {
          ...b.value ? ot : Ve
        }
      };
    });
    return (x, U) => (g(), I("div", {
      ref_key: "element",
      ref: r,
      class: G(["b-form-spinbutton form-control", B.value]),
      role: "group",
      lang: ke.value,
      tabindex: p(u) ? void 0 : "-1",
      title: x.ariaLabel,
      onClick: U[4] || (U[4] = (re) => s.value = !0)
    }, [
      O(x.$slots, ue.value.top.slot.name, { hasFocus: p(s) }, () => [
        le("button", ee(ue.value.top.button, {
          onMousedown: U[0] || (U[0] = //@ts-ignore
          (...re) => ue.value.top.handler && ue.value.top.handler(...re)),
          onTouchstart: U[1] || (U[1] = //@ts-ignore
          (...re) => ue.value.top.handler && ue.value.top.handler(...re))
        }), [
          (g(), I("svg", we(Ae(ue.value.top.svg)), [
            le("path", we(Ae(ue.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      x.name && !p(u) ? (g(), I("input", {
        key: "hidden",
        type: "hidden",
        name: x.name,
        form: x.form,
        value: Oe.value
      }, null, 8, ju)) : se("", !0),
      le("output", {
        id: p(i),
        key: "output",
        class: G(["flex-grow-1", v.value]),
        dir: p(ve) ?? !1 ? "rtl" : "ltr",
        tabindex: p(u) ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": x.ariaLabel || void 0,
        "aria-invalid": p($) === !1 || !p(n) !== null && p(m) ? !0 : void 0,
        "aria-required": p(m) ? !0 : void 0,
        "aria-valuemin": N.value,
        "aria-valuemax": A.value,
        "aria-valuenow": p(n) !== null ? p(n) : void 0,
        "aria-valuetext": p(n) !== null ? M.value(p(n)) : void 0
      }, [
        le("bdi", null, ae((p(n) !== null ? M.value(p(n)) : x.placeholder) || ""), 1)
      ], 10, qu),
      O(x.$slots, ue.value.bottom.slot.name, { hasFocus: p(s) }, () => [
        le("button", ee(ue.value.bottom.button, {
          onMousedown: U[2] || (U[2] = //@ts-ignore
          (...re) => ue.value.bottom.handler && ue.value.bottom.handler(...re)),
          onTouchstart: U[3] || (U[3] = //@ts-ignore
          (...re) => ue.value.bottom.handler && ue.value.bottom.handler(...re))
        }), [
          (g(), I("svg", we(Ae(ue.value.bottom.svg)), [
            le("path", we(Ae(ue.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, Du));
  }
}), Gu = ["id"], Vn = /* @__PURE__ */ q({
  __name: "BFormTag",
  props: {
    disabled: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    noRemove: { type: [Boolean, String], default: !1 },
    pill: { type: [Boolean, String], default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = je(), n = Pe(() => o.id), r = d(() => o.disabled), s = d(() => o.noRemove), i = d(() => o.pill), u = w(
      () => {
        var b;
        return ((((b = l.default) == null ? void 0 : b.call(l, {})[0].children) ?? "").toString() || o.title) ?? "";
      }
    ), c = P(() => `${n.value}taglabel__`), f = w(() => ({
      [`text-bg-${o.variant}`]: o.variant !== null,
      "rounded-pill": i.value,
      disabled: r.value
    }));
    return (b, m) => (g(), H(fe(b.tag), {
      id: p(n),
      title: u.value,
      class: G(["badge b-form-tag d-inline-flex align-items-center mw-100", f.value]),
      "aria-labelledby": c.value
    }, {
      default: R(() => [
        le("span", {
          id: c.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          O(b.$slots, "default", {}, () => [
            de(ae(u.value), 1)
          ])
        ], 8, Gu),
        !p(r) && !p(s) ? (g(), H(jt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": b.removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": c.value,
          "aria-controls": b.id,
          onClick: m[0] || (m[0] = (h) => a("remove", u.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : se("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Uu = ["id"], Xu = ["id", "for", "aria-live"], Ku = ["id", "aria-live"], Yu = ["id"], Zu = ["aria-controls"], Ju = {
  role: "group",
  class: "d-flex"
}, Qu = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], ed = ["disabled"], td = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, ad = {
  key: 0,
  class: "d-block invalid-feedback"
}, od = {
  key: 1,
  class: "form-text text-body-secondary"
}, ld = {
  key: 2,
  class: "form-text text-body-secondary"
}, nd = ["name", "value"], sd = /* @__PURE__ */ q({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: [Boolean, String], default: !1 },
    autofocus: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { type: [Boolean, String], default: !1 },
    noOuterFocus: { type: [Boolean, String], default: !1 },
    noTagRemove: { type: [Boolean, String], default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, String, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: [Boolean, String], default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["blur", "focus", "focusin", "focusout", "input", "tag-state", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = _e(a, "modelValue", l), r = Pe(), s = d(() => a.addOnChange), i = d(() => a.autofocus), u = d(() => a.disabled), c = d(() => a.noAddOnEnter), f = d(() => a.noOuterFocus), b = d(() => a.noTagRemove), m = d(() => a.removeOnDelete), h = d(() => a.required), $ = d(() => a.state), B = d(() => a.tagPills), v = Se(() => a.limit ?? NaN), S = Ot($), y = W(null), { focused: _ } = De(y, {
      initialValue: i.value
    }), C = P(() => a.inputId || `${r.value}input__`), T = W([...n.value]), k = W(""), N = W(n.value.length > 0), V = W(""), A = W([]), E = W([]), K = W([]);
    Ha(n, T, {
      direction: "ltr",
      transform: {
        ltr: (j) => [...j]
      }
    });
    const oe = w(() => [
      S.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: u.value,
        focus: _.value
      }
    ]), F = w(() => T.value.includes(k.value)), z = w(
      () => k.value === "" ? !1 : !a.tagValidator(k.value)
    ), D = P(() => T.value.length === v.value), J = P(() => !z.value && !F.value), ie = w(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: X,
      disableAddButton: J.value,
      disabled: u.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: K.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: u.value,
        form: a.form,
        id: C,
        value: k
      },
      inputHandlers: {
        input: ve,
        keydown: ke,
        change: ge
      },
      inputId: C,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: E.value,
      isDuplicate: F.value,
      isInvalid: z.value,
      isLimitReached: D.value,
      limitTagsText: a.limitTagsText,
      limit: v.value,
      noTagRemove: b.value,
      placeholder: a.placeholder,
      removeTag: L,
      required: h.value,
      separator: a.separator,
      size: a.size,
      state: $.value,
      tagClass: a.tagClass,
      tagPills: B.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: T.value
    })), te = (j) => {
      if (u.value) {
        j.target.blur();
        return;
      }
      l("focusin", j);
    }, he = (j) => {
      u.value || f.value || (_.value = !0, l("focus", j));
    }, Oe = (j) => {
      _.value = !1, l("blur", j);
    }, ve = (j) => {
      var Z, Y;
      const Q = typeof j == "string" ? j : j.target.value;
      if (N.value = !1, (Z = a.separator) != null && Z.includes(Q.charAt(0)) && Q.length > 0) {
        y.value && (y.value.value = "");
        return;
      }
      if (k.value = Q, (Y = a.separator) != null && Y.includes(Q.charAt(Q.length - 1))) {
        X(Q.slice(0, Q.length - 1));
        return;
      }
      A.value = a.tagValidator(Q) && !F.value ? [Q] : [], E.value = a.tagValidator(Q) ? [] : [Q], K.value = F.value ? [Q] : [], l("tag-state", A.value, E.value, K.value);
    }, ge = (j) => {
      s.value && (ve(j), F.value || X(k.value));
    }, ke = (j) => {
      if (j.key === "Enter" && !c.value) {
        X(k.value);
        return;
      }
      (j.key === "Backspace" || j.key === "Delete") && m.value && k.value === "" && N.value && T.value.length > 0 ? L(T.value[T.value.length - 1]) : N.value = !0;
    };
    Ge(ke, { target: y });
    const Ce = w(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), M = w(() => {
      if (Ce.value)
        return new RegExp(`[${Mr(Ce.value)}]+`);
    }), X = (j) => {
      j = (j ?? k.value).trim();
      const Q = M.value ? j.split(M.value).map((pe) => pe.trim()) : [j], Z = [];
      for (const pe of Q)
        if (!(pe === "" || F.value || !a.tagValidator(pe))) {
          if (v.value && D.value)
            break;
          Z.push(pe);
        }
      const Y = [...n.value, ...Z];
      k.value = "", N.value = !0, n.value = Y, l("input", Y), _.value = !0;
    }, L = (j) => {
      const Q = T.value.indexOf((j == null ? void 0 : j.toString()) ?? "");
      Q !== -1 && (V.value = T.value.splice(Q, 1).toString(), n.value = T.value);
    };
    return t({
      blur: () => {
        _.value = !1;
      },
      element: y,
      focus: () => {
        _.value = !0;
      }
    }), (j, Q) => (g(), I("div", {
      id: p(r),
      class: G(["b-form-tags form-control h-auto", oe.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: te,
      onFocusout: Q[1] || (Q[1] = (Z) => l("focusout", Z))
    }, [
      le("output", {
        id: `${p(r)}selected_tags__`,
        class: "visually-hidden",
        for: C.value,
        "aria-live": p(_) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, ae(T.value.join(", ")), 9, Xu),
      le("div", {
        id: `${p(r)}removed_tags__`,
        role: "status",
        "aria-live": p(_) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + ae(j.tagRemovedLabel) + ") " + ae(V.value), 9, Ku),
      O(j.$slots, "default", we(Ae(ie.value)), () => [
        le("ul", {
          id: `${p(r)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (g(!0), I(me, null, Ee(T.value, (Z, Y) => O(j.$slots, "tag", {
            key: Y,
            tag: Z,
            tagClass: j.tagClass,
            tagVariant: j.tagVariant,
            tagPills: p(B),
            removeTag: L
          }, () => [
            (g(), H(Vn, {
              key: Z,
              class: G(j.tagClass),
              tag: "li",
              variant: j.tagVariant,
              pill: j.tagPills,
              onRemove: L
            }, {
              default: R(() => [
                de(ae(Z), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          le("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${p(r)}tag_list__`
          }, [
            le("div", Ju, [
              le("input", ee({
                id: C.value,
                ref_key: "input",
                ref: y,
                disabled: p(u),
                value: k.value,
                type: j.inputType,
                placeholder: j.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, j.inputAttrs, {
                form: j.form,
                required: p(h) || void 0,
                "aria-required": p(h) || void 0,
                onInput: ve,
                onChange: ge,
                onFocus: he,
                onBlur: Oe
              }), null, 16, Qu),
              J.value ? (g(), I("button", {
                key: 0,
                type: "button",
                class: G(["btn b-form-tags-button py-0", [
                  j.inputClass,
                  {
                    [`btn-${j.addButtonVariant}`]: j.addButtonVariant !== null,
                    "disabled invisible": k.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: p(u) || k.value.length === 0 || D.value,
                onClick: Q[0] || (Q[0] = (Z) => X(k.value))
              }, [
                O(j.$slots, "add-button-text", {}, () => [
                  de(ae(j.addButtonText), 1)
                ])
              ], 10, ed)) : se("", !0)
            ])
          ], 8, Zu)
        ], 8, Yu),
        le("div", td, [
          z.value ? (g(), I("div", ad, ae(j.invalidTagText) + ": " + ae(k.value), 1)) : se("", !0),
          F.value ? (g(), I("small", od, ae(j.duplicateTagText) + ": " + ae(k.value), 1)) : se("", !0),
          T.value.length === j.limit ? (g(), I("small", ld, "Tag limit reached")) : se("", !0)
        ])
      ]),
      j.name ? (g(!0), I(me, { key: 0 }, Ee(T.value, (Z, Y) => (g(), I("input", {
        key: Y,
        type: "hidden",
        name: j.name,
        value: Z
      }, null, 8, nd))), 128)) : se("", !0)
    ], 42, Uu));
  }
}), rd = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], id = /* @__PURE__ */ q({
  __name: "BFormTextarea",
  props: {
    noResize: { type: [Boolean, String], default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [Boolean, String], default: !1 },
    lazyFormatter: { type: [Boolean, String], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [Boolean, String], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [Boolean, String], default: !1 },
    readonly: { type: [Boolean, String], default: !1 },
    required: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, String, null], default: null },
    trim: { type: [Boolean, String], default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, { input: n, computedId: r, computedAriaInvalid: s, onInput: i, onChange: u, onBlur: c, focus: f, blur: b } = an(a, l), m = d(() => a.disabled), h = d(() => a.required), $ = d(() => a.readonly), B = d(() => a.plaintext), v = d(() => a.noResize), S = d(() => a.state), y = Ot(S), _ = w(() => [
      y.value,
      B.value ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${a.size}`]: !!a.size
      }
    ]), C = w(() => ({
      resize: v.value ? "none" : void 0
    }));
    return t({
      blur: b,
      element: n,
      focus: f
    }), (T, k) => (g(), I("textarea", {
      id: p(r),
      ref_key: "input",
      ref: n,
      class: G(_.value),
      name: T.name || void 0,
      form: T.form || void 0,
      value: T.modelValue ?? void 0,
      disabled: p(m),
      placeholder: T.placeholder,
      required: p(h) || void 0,
      autocomplete: T.autocomplete || void 0,
      readonly: p($) || p(B),
      "aria-required": T.required || void 0,
      "aria-invalid": p(s),
      rows: T.rows,
      style: Me(C.value),
      wrap: T.wrap || void 0,
      onInput: k[0] || (k[0] = (N) => p(i)(N)),
      onChange: k[1] || (k[1] = (N) => p(u)(N)),
      onBlur: k[2] || (k[2] = (N) => p(c)(N))
    }, null, 46, rd));
  }
}), ud = {
  key: 0,
  class: "input-group-text"
}, dd = ["innerHTML"], cd = { key: 1 }, fd = {
  key: 0,
  class: "input-group-text"
}, vd = ["innerHTML"], pd = { key: 1 }, md = /* @__PURE__ */ q({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), a = P(() => !!t.append || !!t.appendHtml), l = P(() => !!t.prepend || !!t.prependHtml);
    return (n, r) => (g(), H(fe(n.tag), {
      id: n.id,
      class: G(["input-group", o.value]),
      role: "group"
    }, {
      default: R(() => [
        O(n.$slots, "prepend", {}, () => [
          l.value ? (g(), I("span", ud, [
            n.prependHtml ? (g(), I("span", {
              key: 0,
              innerHTML: n.prependHtml
            }, null, 8, dd)) : (g(), I("span", cd, ae(n.prepend), 1))
          ])) : se("", !0)
        ]),
        O(n.$slots, "default"),
        O(n.$slots, "append", {}, () => [
          a.value ? (g(), I("span", fd, [
            n.appendHtml ? (g(), I("span", {
              key: 0,
              innerHTML: n.appendHtml
            }, null, 8, vd)) : (g(), I("span", pd, ae(n.append), 1))
          ])) : se("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), An = /* @__PURE__ */ q({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, o) => (g(), H(fe(t.tag), { class: "input-group-text" }, {
      default: R(() => [
        O(t.$slots, "default", {}, () => [
          de(ae(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), mo = /* @__PURE__ */ q({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.isText);
    return (a, l) => p(o) ? (g(), H(An, { key: 0 }, {
      default: R(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    })) : O(a.$slots, "default", { key: 1 });
  }
}), gd = /* @__PURE__ */ q({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    return (t, o) => (g(), H(mo, we(Ae(t.$props)), {
      default: R(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bd = /* @__PURE__ */ q({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    return (t, o) => (g(), H(mo, we(Ae(t.$props)), {
      default: R(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yd = /* @__PURE__ */ q({
  __name: "BListGroup",
  props: {
    flush: { type: [Boolean, String], default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: [Boolean, String], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, o = d(() => t.flush), a = d(() => t.numbered), l = d(() => t.horizontal), n = w(() => {
      const s = o.value ? !1 : l.value;
      return {
        "list-group-flush": o.value,
        "list-group-horizontal": s === !0,
        [`list-group-horizontal-${s}`]: typeof s == "string",
        "list-group-numbered": a.value
      };
    }), r = P(() => a.value === !0 ? "ol" : t.tag);
    return dt(Hl, {
      numbered: a
    }), (s, i) => (g(), H(fe(r.value), {
      class: G(["list-group", n.value])
    }, {
      default: R(() => [
        O(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), hd = /* @__PURE__ */ q({
  __name: "BListGroupItem",
  props: {
    action: { type: [Boolean, String], default: !1 },
    button: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    active: { type: [Boolean, String], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, o = Zt(), a = ze(Hl, null), l = d(() => t.action), n = d(() => t.active), r = d(() => t.button), s = d(() => t.disabled), { computedLink: i } = At(t), u = P(() => !r.value && i.value), c = P(
      () => a != null && a.numbered.value ? "li" : r.value ? "button" : u.value ? ft : t.tag
    ), f = w(
      () => l.value || u.value || r.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), b = w(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== null && t.variant !== void 0,
      "list-group-item-action": f.value,
      active: n.value,
      disabled: s.value
    })), m = w(() => {
      const h = {};
      return r.value && ((!o || !o.type) && (h.type = "button"), s.value && (h.disabled = !0)), h;
    });
    return (h, $) => (g(), H(fe(c.value), ee({
      class: ["list-group-item", b.value],
      "aria-current": p(n) ? !0 : void 0,
      "aria-disabled": p(s) ? !0 : void 0,
      target: u.value ? h.target : void 0,
      href: p(r) ? void 0 : h.href,
      to: p(r) ? void 0 : h.to
    }, m.value), {
      default: R(() => [
        O(h.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Bd = { id: "__BVID__modal-container" }, Sd = /* @__PURE__ */ q({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { type: [Boolean, String], default: !1 },
    teleportTo: { default: "body" }
  },
  setup(e, { expose: t }) {
    const o = e, a = d(() => o.teleportDisabled), { modals: l, remove: n, show: r, confirm: s } = ln(), i = (u) => wa(u, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return t({
      modals: l,
      show: r,
      confirm: s
    }), (u, c) => (g(), H(_t, {
      to: u.teleportTo,
      disabled: p(a)
    }, [
      le("div", Bd, [
        (g(!0), I(me, null, Ee(p(l), (f, b) => (g(), H(fe(f.value.component), ee({
          key: b,
          modelValue: f.value.props._modelValue,
          "onUpdate:modelValue": (m) => f.value.props._modelValue = m
        }, i(f.value.props), {
          "teleport-disabled": !0,
          onHide: (m) => {
            if (f.value.props._isConfirm === !0) {
              if (m.trigger === "ok") {
                f.value.props._promise.resolve(!0);
                return;
              }
              if (m.trigger === "cancel") {
                f.value.props._promise.resolve(!1);
                return;
              }
              f.value.props._promise.resolve(null);
            }
            f.value.props._promise.resolve(!0);
          },
          onHidden: (m) => {
            var h;
            return (h = p(n)) == null ? void 0 : h(f.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), wd = /* @__PURE__ */ q({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: [Boolean, String], default: !1 },
    fill: { type: [Boolean, String], default: !1 },
    justified: { type: [Boolean, String], default: !1 },
    pills: { type: [Boolean, String], default: !1 },
    small: { type: [Boolean, String], default: !1 },
    tabs: { type: [Boolean, String], default: !1 },
    tag: { default: "ul" },
    underline: { type: [Boolean, String], default: !1 },
    vertical: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.cardHeader), a = d(() => t.fill), l = d(() => t.justified), n = d(() => t.pills), r = d(() => t.small), s = d(() => t.tabs), i = d(() => t.vertical), u = Jt(() => t.align), c = d(() => t.underline), f = w(() => ({
      "nav-tabs": s.value,
      "nav-pills": n.value && !s.value,
      "card-header-tabs": !i.value && o.value && s.value,
      "card-header-pills": !i.value && o.value && n.value && !s.value,
      "flex-column": i.value,
      "nav-fill": !i.value && a.value,
      "nav-justified": !i.value && l.value,
      [u.value]: !i.value && t.align !== void 0,
      small: r.value,
      "nav-underline": c.value
    }));
    return (b, m) => (g(), H(fe(b.tag), {
      class: G(["nav", f.value])
    }, {
      default: R(() => [
        O(b.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Cd = { class: "d-flex flex-row align-items-center flex-wrap" }, kd = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: [Boolean, String], default: void 0 },
    id: { default: void 0 },
    novalidate: { type: [Boolean, String], default: void 0 },
    validated: { type: [Boolean, String], default: void 0 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const o = t, a = (l) => {
      o("submit", l);
    };
    return (l, n) => (g(), I("li", Cd, [
      ye(wn, ee(l.$attrs, {
        id: l.id,
        floating: l.floating,
        role: l.role,
        novalidate: l.novalidate,
        validated: l.validated,
        class: "d-flex",
        onSubmit: ht(a, ["prevent"])
      }), {
        default: R(() => [
          O(l.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
}), $d = { class: "nav-item" }, Td = /* @__PURE__ */ q({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.disabled), n = w(
      () => io(o, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return n.value.activeClass, (r, s) => (g(), I("li", $d, [
      ye(ft, ee({
        class: ["nav-link", r.linkClass],
        tabindex: p(l) ? -1 : void 0,
        "aria-disabled": p(l) ? !0 : void 0
      }, { ...n.value, ...r.linkAttrs }, {
        onClick: s[0] || (s[0] = (i) => a("click", i))
      }), {
        default: R(() => [
          O(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
}), _d = { class: "nav-item dropdown" }, Vd = /* @__PURE__ */ q({
  __name: "BNavItemDropdown",
  props: {
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: [Boolean, String], default: !1 },
    container: { default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    dropend: { type: [Boolean, String], default: !1 },
    dropstart: { type: [Boolean, String], default: !1 },
    dropup: { type: [Boolean, String], default: !1 },
    end: { type: [Boolean, String], default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: [Boolean, String], default: !0 },
    lazy: { type: [Boolean, String], default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    noCaret: { type: [Boolean, String], default: !1 },
    noFlip: { type: [Boolean, String], default: !1 },
    noShift: { type: [Boolean, String], default: !1 },
    noSize: { type: [Boolean, String], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: [Boolean, String], default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: [Boolean, String], default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" }
  },
  emits: ["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = W(null), r = () => {
      var u;
      (u = n.value) == null || u.close();
    }, s = () => {
      var u;
      (u = n.value) == null || u.open();
    };
    return t({
      close: r,
      open: s,
      toggle: () => {
        var u;
        (u = n.value) == null || u.toggle();
      }
    }), (u, c) => (g(), I("li", _d, [
      ye(Sn, ee({
        ref_key: "dropdown",
        ref: n
      }, a, {
        "is-nav": "",
        onShow: c[0] || (c[0] = (f) => l("show", f)),
        onShown: c[1] || (c[1] = (f) => l("shown")),
        onHide: c[2] || (c[2] = (f) => l("hide", f)),
        onHidden: c[3] || (c[3] = (f) => l("hidden")),
        onHidePrevented: c[4] || (c[4] = (f) => l("hide-prevented")),
        onShowPrevented: c[5] || (c[5] = (f) => l("show-prevented")),
        onClick: c[6] || (c[6] = (f) => l("click", f)),
        onToggle: c[7] || (c[7] = (f) => l("toggle")),
        "onUpdate:modelValue": c[8] || (c[8] = (f) => l("update:modelValue", f))
      }), {
        "button-content": R(() => [
          O(u.$slots, "button-content")
        ]),
        "toggle-text": R(() => [
          O(u.$slots, "toggle-text")
        ]),
        default: R(() => [
          O(u.$slots, "default", {
            hide: r,
            show: s
          })
        ]),
        _: 3
      }, 16)
    ]));
  }
}), Ad = { class: "navbar-text" }, Od = /* @__PURE__ */ q({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, o) => (g(), I("li", Ad, [
      O(t.$slots, "default", {}, () => [
        de(ae(t.text), 1)
      ])
    ]));
  }
}), Ed = /* @__PURE__ */ q({
  __name: "BNavbar",
  props: {
    autoClose: { type: [Boolean, String], default: !0 },
    container: { type: [String, Boolean], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: [Boolean, String], default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = d(() => t.container), a = d(() => t.autoClose), l = d(() => t.print), n = d(() => t.toggleable), r = P(() => t.tag === "nav" ? void 0 : "navigation"), s = qr(o), i = w(() => ({
      "d-print": l.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      "navbar-expand": n.value === !1,
      [`navbar-expand-${n.value}`]: typeof n.value == "string"
    }));
    return dt(ro, {
      tag: P(() => t.tag),
      autoClose: a
    }), (u, c) => (g(), H(fe(u.tag), {
      class: G(["navbar", i.value]),
      role: r.value
    }, {
      default: R(() => [
        u.container !== !1 ? (g(), I("div", {
          key: 0,
          class: G(p(s))
        }, [
          O(u.$slots, "default")
        ], 2)) : O(u.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Pd = /* @__PURE__ */ q({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: [Boolean, String], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [Boolean, String], default: void 0 },
    disabled: { type: [Boolean, String], default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: [Boolean, String], default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [Boolean, String], default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, { computedLink: o, computedLinkProps: a } = At(t, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), l = P(() => o.value ? ft : t.tag);
    return (n, r) => (g(), H(fe(l.value), ee({ class: "navbar-brand" }, p(a)), {
      default: R(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Nd = /* @__PURE__ */ q({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: [Boolean, String], default: !1 },
    justified: { type: [Boolean, String], default: !1 },
    small: { type: [Boolean, String], default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, o = d(() => t.fill), a = d(() => t.justified), l = d(() => t.small), n = Jt(() => t.align), r = w(() => ({
      "nav-fill": o.value,
      "nav-justified": a.value,
      [n.value]: t.align !== void 0,
      small: l.value
    }));
    return (s, i) => (g(), I("ul", {
      class: G(["navbar-nav", r.value])
    }, [
      O(s.$slots, "default")
    ], 2));
  }
}), Wo = (e, t) => e.setAttribute("data-bs-theme", t), Id = {
  mounted(e, t) {
    Wo(e, t.value);
  },
  updated(e, t) {
    Wo(e, t.value);
  }
}, Fd = (e, t) => {
  const { modifiers: o, arg: a, value: l } = e, n = Object.keys(o || {}), r = typeof l == "string" ? l.split(ra) : l;
  if (t.tagName.toLowerCase() === "a") {
    const s = t.getAttribute("href") || "";
    Zn.test(s) && n.push(s.replace(Yn, ""));
  }
  return Array.prototype.concat.apply([], [a, r]).forEach((s) => typeof s == "string" && n.push(s)), n.filter((s, i, u) => s && u.indexOf(s) === i);
}, Ld = (e, t) => {
  e.forEach((o) => {
    const a = document.getElementById(o);
    a !== null && a.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => On(e, t), 50);
}, On = (e, t) => {
  let o = !1;
  e.forEach((a) => {
    const l = document.getElementById(a);
    l != null && l.classList.contains("show") && (o = !0), l != null && l.classList.contains("closing") && (o = !1);
  }), t.setAttribute("aria-expanded", o ? "true" : "false"), t.classList.remove(o ? "collapsed" : "not-collapsed"), t.classList.add(o ? "not-collapsed" : "collapsed");
}, Go = (e, t) => {
  const o = Fd(t, e);
  o.length !== 0 && (e.__toggle && e.removeEventListener("click", e.__toggle), e.__toggle = () => Ld(o, e), e.addEventListener("click", e.__toggle), e.setAttribute("aria-controls", o.join(" ")), On(o, e));
}, ja = {
  mounted: Go,
  updated: Go,
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, zd = {
  mounted(e, t) {
    if (!Kt(t.value))
      return;
    const a = ma(t.value, e);
    !a.content && !a.title || (e.$__state = W({
      ...zt(t, e),
      ...a
    }), ga(e, t));
  },
  updated(e, t) {
    if (!Kt(t.value))
      return;
    const a = ma(t.value, e);
    if (!(!a.content && !a.title)) {
      if (!e.$__state) {
        e.$__state = W({
          ...zt(t, e),
          ...a
        }), ga(e, t);
        return;
      }
      e.$__state.value = {
        ...zt(t, e),
        ...a
      };
    }
  },
  beforeUnmount(e) {
    Pl(e);
  }
}, Uo = (e, t) => {
  e.$__scrollspy && e.$__scrollspy.cleanup();
  const { arg: o, value: a } = t, l = typeof a == "object" && a !== null, n = o || (typeof a == "string" ? a : l ? a.content || a.element : null);
  e.$__scrollspy = sn(n, e, l ? wa(a, ["content", "element"]) : {});
}, Hd = {
  mounted: Uo,
  updated: Uo,
  beforeUnmount(e) {
    e.$__scrollspy && e.$__scrollspy.cleanup();
  }
}, Rd = {
  mounted(e, t) {
    const o = Kt(t.value);
    if (!o)
      return;
    const a = ma(t.value, e);
    !a.content && !a.title || (e.$__state = W({
      noninteractive: !0,
      ...zt(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: o
    }), ga(e, t));
  },
  updated(e, t) {
    const o = Kt(t.value);
    if (!o)
      return;
    const a = ma(t.value, e);
    if (!(!a.content && !a.title)) {
      if (!e.$__state) {
        e.$__state = W({
          noninteractive: !0,
          ...zt(t, e),
          title: a.title ?? a.content ?? "",
          tooltip: o
        }), ga(e, t);
        return;
      }
      e.$__state.value = {
        noninteractive: !0,
        ...zt(t, e),
        title: a.title ?? a.content ?? "",
        tooltip: o
      };
    }
  },
  beforeUnmount(e) {
    Pl(e);
  }
}, Xo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Id,
  vBModal: ja,
  vBPopover: zd,
  vBScrollspy: Hd,
  vBToggle: ja,
  vBTooltip: Rd
}, Symbol.toStringTag, { value: "Module" })), xd = ["disabled", "aria-label"], Md = /* @__PURE__ */ le("span", { class: "navbar-toggler-icon" }, null, -1), Dd = /* @__PURE__ */ q({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: [Boolean, String], default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.disabled), n = w(() => ({
      disabled: l.value
    })), r = (s) => {
      l.value || a("click", s);
    };
    return (s, i) => wt((g(), I("button", {
      class: G(["navbar-toggler", n.value]),
      type: "button",
      disabled: p(l),
      "aria-label": s.label,
      onClick: r
    }, [
      O(s.$slots, "default", {}, () => [
        Md
      ])
    ], 10, xd)), [
      [p(ja), p(l) ? void 0 : s.target]
    ]);
  }
}), jd = ["id", "aria-labelledby"], qd = ["id"], Wd = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: {
    backdrop: { type: [Boolean, String], default: !0 },
    backdropVariant: { default: "dark" },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: [Boolean, String], default: !1 },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: [Boolean, String], default: !1 },
    modelValue: { type: [Boolean, String], default: !1 },
    noCloseOnBackdrop: { type: [Boolean, String], default: !1 },
    noCloseOnEsc: { type: [Boolean, String], default: !1 },
    noFocus: { type: [Boolean, String], default: !1 },
    noHeader: { type: [Boolean, String], default: !1 },
    noHeaderClose: { type: [Boolean, String], default: !1 },
    placement: { default: "start" },
    teleportDisabled: { type: [Boolean, String], default: !1 },
    teleportTo: { default: "body" },
    title: { default: void 0 }
  },
  emits: ["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "update:modelValue"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = je(), r = _e(a, "modelValue", l, { passive: !0 }), s = d(r), i = d(() => a.bodyScrolling), u = d(() => a.backdrop), c = d(() => a.noHeaderClose), f = d(() => a.noHeader), b = d(() => a.noFocus), m = d(() => a.noCloseOnBackdrop), h = d(() => a.noCloseOnEsc), $ = d(() => a.lazy), B = d(() => a.teleportDisabled), v = Pe(() => a.id, "offcanvas");
    nn(s, i);
    const S = W(null);
    Ge(
      "Escape",
      () => {
        z("esc");
      },
      { target: S }
    );
    const { focused: y } = De(S, {
      initialValue: s.value && b.value === !1
    }), _ = W(s.value), C = W(!1), T = P(() => u.value === !0 && s.value === !0), k = P(
      () => $.value === !1 || $.value === !0 && C.value === !0 || $.value === !0 && s.value === !0
    ), N = P(() => !He(n["header-close"])), V = w(() => [
      { "text-reset": !N.value },
      a.headerCloseClass
    ]), A = w(() => ({
      variant: N.value ? a.headerCloseVariant : void 0,
      class: V.value
    })), E = P(() => !He(n.footer)), K = w(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: s.value && _.value === !0
      }
    ]), oe = w(() => ({
      visible: s.value,
      placement: a.placement,
      hide: z
    })), F = (ve, ge = {}) => new Vt(ve, {
      cancelable: !1,
      target: S.value || null,
      relatedTarget: null,
      trigger: null,
      ...ge,
      componentId: v.value
    }), z = (ve = "") => {
      if (ve === "backdrop" && m.value || ve === "esc" && h.value) {
        l("hide-prevented");
        return;
      }
      const ge = F("hide", { cancelable: ve !== "", trigger: ve });
      if (ve === "close" && l(ve, ge), ve === "esc" && l(ve, ge), l("hide", ge), ge.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      r.value = !1;
    }, D = () => {
      const ve = F("show", { cancelable: !0 });
      if (l("show", ve), ve.defaultPrevented) {
        r.value = !1, l("show-prevented");
        return;
      }
      r.value = !0;
    }, J = () => {
      Fe(() => {
        b.value === !1 && (y.value = !0);
      });
    }, ie = () => D(), te = () => {
      _.value = !0, J(), l("shown", F("shown")), $.value === !0 && (C.value = !0);
    }, he = () => {
      _.value = !1;
    }, Oe = () => {
      l("hidden", F("hidden")), $.value === !0 && (C.value = !1);
    };
    return Ne(S, "bv-toggle", () => {
      s.value ? z() : D();
    }), t({
      hide: z,
      show: D
    }), (ve, ge) => (g(), H(_t, {
      to: ve.teleportTo,
      disabled: p(B)
    }, [
      ye(Dt, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: ie,
        onAfterEnter: te,
        onLeave: he,
        onAfterLeave: Oe
      }, {
        default: R(() => [
          wt(le("div", ee({
            id: p(v),
            ref_key: "element",
            ref: S,
            "aria-modal": "true",
            role: "dialog",
            class: K.value,
            tabindex: "-1",
            "aria-labelledby": `${p(v)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, ve.$attrs), [
            k.value ? (g(), I(me, { key: 0 }, [
              p(f) ? se("", !0) : (g(), I("div", {
                key: 0,
                class: G(["offcanvas-header", ve.headerClass])
              }, [
                O(ve.$slots, "header", we(Ae(oe.value)), () => [
                  le("h5", {
                    id: `${p(v)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    O(ve.$slots, "title", we(Ae(oe.value)), () => [
                      de(ae(ve.title), 1)
                    ])
                  ], 8, qd),
                  p(c) ? se("", !0) : (g(), I(me, { key: 0 }, [
                    N.value ? (g(), H(Bt, ee({ key: 0 }, A.value, {
                      onClick: ge[0] || (ge[0] = (ke) => z("close"))
                    }), {
                      default: R(() => [
                        O(ve.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (g(), H(jt, ee({
                      key: 1,
                      "aria-label": ve.headerCloseLabel
                    }, A.value, {
                      onClick: ge[1] || (ge[1] = (ke) => z("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              le("div", {
                class: G(["offcanvas-body", ve.bodyClass])
              }, [
                O(ve.$slots, "default", we(Ae(oe.value)))
              ], 2),
              E.value ? (g(), I("div", {
                key: 1,
                class: G(ve.footerClass)
              }, [
                O(ve.$slots, "footer", we(Ae(oe.value)))
              ], 2)) : se("", !0)
            ], 64)) : se("", !0)
          ], 16, jd), [
            [ba, p(r)]
          ])
        ]),
        _: 3
      }),
      O(ve.$slots, "backdrop", {}, () => [
        ye(ka, {
          variant: ve.backdropVariant,
          show: T.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: ge[2] || (ge[2] = (ke) => z("backdrop"))
        }, null, 8, ["variant", "show"])
      ])
    ], 8, ["to", "disabled"]));
  }
}), Gd = ["aria-disabled", "aria-label"], Ko = 20, Yo = 0, Ud = /* @__PURE__ */ q({
  __name: "BPagination",
  props: {
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "" },
    firstClass: { default: void 0 },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { default: "" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { default: "" },
    limit: { default: 5 },
    modelValue: { default: 1 },
    nextClass: { default: void 0 },
    nextText: { default: "" },
    pageClass: { default: void 0 },
    perPage: { default: Ko },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { default: void 0 },
    prevText: { default: "" },
    size: { default: void 0 },
    totalRows: { default: Yo }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t }) {
    const i = e, u = t, c = _e(i, "modelValue", u), f = d(() => i.disabled), b = d(() => i.firstNumber), m = d(() => i.hideEllipsis), h = d(() => i.hideGotoEndButtons), $ = d(() => i.lastNumber), B = d(() => i.pills), v = Se(() => i.limit, { nanToZero: !0, method: "parseInt" }), S = Se(() => i.perPage, { nanToZero: !0, method: "parseInt" }), y = Se(() => i.totalRows, { nanToZero: !0, method: "parseInt" }), _ = Se(c, { nanToZero: !0, method: "parseInt" }), C = P(() => Math.max(S.value || Ko, 1)), T = P(() => Math.max(y.value || Yo, 0)), k = P(() => Math.ceil(T.value / C.value)), N = P(() => i.align === "fill"), V = P(() => i.align === "fill" ? "start" : i.align), A = Jt(V), E = (Y) => Y === _.value, K = (Y) => f.value ? null : E(Y) ? "0" : "-1", oe = (Y) => f.value || E(Y) || _.value < 1 || // Check if the number is out of bounds
    Y < 1 || Y > k.value, F = w(() => oe(1)), z = w(() => oe(_.value - 1)), D = w(() => oe(k.value)), J = w(() => oe(_.value + 1)), ie = ({
      page: Y,
      classVal: pe,
      dis: ne,
      slotName: Be,
      textValue: ue,
      tabIndex: x,
      label: U,
      position: re,
      isActive: Te,
      role: $e,
      hidden: Ve
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: Te,
            disabled: ne,
            "flex-fill": N.value,
            "d-flex": N.value && !ne
          },
          pe
        ],
        role: $e,
        "aria-hidden": Ve
      },
      button: {
        is: ne ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !ne && N.value }],
        "aria-label": U,
        "aria-controls": i.ariaControls || void 0,
        "aria-disabled": ne ? !0 : void 0,
        "aria-posinset": re,
        "aria-setsize": re ? k.value : void 0,
        role: "menuitem",
        type: ne ? void 0 : "button",
        tabindex: ne ? void 0 : x
      },
      text: {
        name: Be,
        active: Te,
        value: ue ?? Y,
        page: Y,
        disabled: ne,
        index: Y - 1,
        content: ue ? void 0 : Y
      },
      clickHandler: (ot) => Q(ot, Y)
    }), te = ({
      page: Y,
      classVal: pe,
      dis: ne,
      slotName: Be,
      textValue: ue,
      label: x
    }) => ie({ page: Y, classVal: pe, dis: ne, slotName: Be, textValue: ue, label: x, tabIndex: "-1" }), he = (Y) => ie({
      page: Y,
      dis: f.value,
      classVal: i.pageClass,
      slotName: "page",
      label: i.labelPage ? `${i.labelPage} ${Y}` : void 0,
      tabIndex: K(Y) ?? void 0,
      position: Y,
      isActive: E(Y)
    }), Oe = w(
      () => te({
        page: 1,
        dis: F.value,
        classVal: i.firstClass,
        slotName: "first-text",
        textValue: i.firstText,
        label: i.labelFirstPage
      })
    ), ve = w(
      () => te({
        page: Math.max(_.value - 1, 1),
        dis: z.value,
        classVal: i.prevClass,
        slotName: "prev-text",
        textValue: i.prevText,
        label: i.labelPrevPage
      })
    ), ge = w(
      () => te({
        page: Math.min(_.value + 1, k.value),
        dis: J.value,
        classVal: i.nextClass,
        slotName: "next-text",
        textValue: i.nextText,
        label: i.labelNextPage
      })
    ), ke = w(
      () => te({
        page: k.value,
        dis: D.value,
        classVal: i.lastClass,
        slotName: "last-text",
        textValue: i.lastText,
        label: i.labelLastPage
      })
    ), Ce = pa(), M = pa(), X = w(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          N.value ? "flex-fill" : "",
          i.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), L = w(() => [
      A.value,
      {
        [`pagination-${i.size}`]: i.size !== void 0,
        "b-pagination-pills": B.value
      }
    ]), j = w(() => ({
      pageSize: C.value,
      totalRows: y.value,
      numberOfPages: k.value
    })), Q = (Y, pe) => {
      if (pe === _.value)
        return;
      const ne = new vt("page-click", {
        cancelable: !0,
        target: Y.target
      });
      u("page-click", ne, pe), !ne.defaultPrevented && (c.value = pe);
    };
    ce(_, (Y) => {
      const ne = ((Be, ue) => {
        const x = Be || 1;
        return x > ue ? ue : x < 1 ? 1 : x;
      })(Y, k.value);
      ne !== c.value && (c.value = ne);
    }), ce(j, (Y, pe) => {
      (pe.pageSize !== Y.pageSize && pe.totalRows === Y.totalRows || pe.numberOfPages !== Y.numberOfPages && _.value > pe.numberOfPages) && (c.value = 1);
    });
    const Z = w(() => {
      const Y = k.value, { value: pe } = _, ne = v.value, Be = b.value ? 1 : 0, ue = $.value ? 1 : 0, x = m.value || ne <= 3, U = h.value ? 1 : 0;
      if (Y < ne + Be + ue)
        return [
          !Be && !U ? -1 : null,
          -2,
          ...Array.from({ length: Y }, ($e, Ve) => Ve + 1),
          -3,
          !ue && !U ? -4 : null
        ].filter(($e) => $e !== null);
      const re = Array.from({ length: ne + 4 - U * 2 });
      U ? (re[0] = -2, re[re.length - 1] = -3) : (Be ? (re[0] = -2, re[1] = 1) : (re[0] = -1, re[1] = -2), ue ? (re[re.length - 1] = -3, re[re.length - 2] = Y) : (re[re.length - 1] = -4, re[re.length - 2] = -3));
      const Te = Math.floor(ne / 2);
      if (pe <= Te + Be) {
        for (let $e = 1; $e <= ne; $e++)
          re[$e + 1 - U] = $e + Be;
        x || (re[re.length - 3] = -5);
      }
      if (pe > Y - Te - ue) {
        const $e = Y - (ne - 1) - ue;
        for (let Ve = 0; Ve < ne; Ve++)
          re[Ve + 2 - U] = $e + Ve;
        x || (re[2] = -5);
      }
      if (!re[2]) {
        const $e = pe - Math.floor(ne / 2);
        for (let Ve = 0; Ve < ne; Ve++)
          re[Ve + 2 - U] = $e + Ve;
        x || (re[2] = -5, re[re.length - 3] = -5);
      }
      return re;
    });
    return (Y, pe) => (g(), I("ul", {
      class: G(["pagination", L.value]),
      role: "menubar",
      "aria-disabled": p(f),
      "aria-label": Y.ariaLabel || void 0
    }, [
      ye(p(Ce).define, null, {
        default: R(({ button: ne, li: Be, text: ue, clickHandler: x }) => [
          le("li", we(Ae(Be)), [
            (g(), H(fe(ne.is), ee(ne, { onClick: x }), {
              default: R(() => [
                O(Y.$slots, ue.name, {
                  disabled: ue.disabled,
                  page: ue.page,
                  index: ue.index,
                  active: ue.active,
                  content: ue.value
                }, () => [
                  de(ae(ue.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      ye(p(M).define, null, {
        default: R(() => [
          le("li", we(Ae(X.value.li)), [
            le("span", we(Ae(X.value.span)), [
              O(Y.$slots, "ellipsis-text", {}, () => [
                de(ae(Y.ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (g(!0), I(me, null, Ee(Z.value, (ne) => (g(), I(me, {
        key: `page-${ne.number}`
      }, [
        ne === -1 ? (g(), H(p(Ce).reuse, we(ee({ key: 0 }, Oe.value)), null, 16)) : ne === -2 ? (g(), H(p(Ce).reuse, we(ee({ key: 1 }, ve.value)), null, 16)) : ne === -3 ? (g(), H(p(Ce).reuse, we(ee({ key: 2 }, ge.value)), null, 16)) : ne === -4 ? (g(), H(p(Ce).reuse, we(ee({ key: 3 }, ke.value)), null, 16)) : ne === -5 ? (g(), H(p(M).reuse, { key: 4 })) : (g(), H(p(Ce).reuse, we(ee({ key: 5 }, he(ne))), null, 16))
      ], 64))), 128))
    ], 10, Gd));
  }
}), Je = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(e) {
    const t = e, o = P(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), a = P(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), l = w(() => ({
      [`col-${a.value}`]: a.value !== void 0 && o.value === void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = w(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = w(() => ({
      width: o.value === void 0 ? void 0 : `${o.value}%`
    }));
    return (s, i) => (g(), H(fe(s.wrapperTag), {
      class: G(n.value)
    }, {
      default: R(() => [
        (g(), H(fe(s.tag), ee(s.$attrs, {
          class: ["placeholder", l.value],
          style: r.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), En = /* @__PURE__ */ q({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`btn-${t.variant}`]: t.variant !== null
    }));
    return (a, l) => (g(), H(Je, {
      class: G(["btn disabled", o.value]),
      animation: a.animation,
      width: a.width,
      cols: a.cols,
      tag: a.tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), Xd = /* @__PURE__ */ q({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgBottom: { type: [Boolean, String], default: !1 },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: [Boolean, String], default: !1 },
    noFooter: { type: [Boolean, String], default: !1 },
    noHeader: { type: [Boolean, String], default: !1 },
    noImg: { type: [Boolean, String], default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, o = d(() => t.noButton), a = d(() => t.noHeader), l = d(() => t.noFooter), n = d(() => t.noImg), r = w(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), s = P(() => o.value ? Je : En);
    return (i, u) => (g(), H(Bn, { "img-bottom": i.imgBottom }, Ua({
      default: R(() => [
        O(i.$slots, "default", {}, () => [
          ye(Je, ee({ cols: "7" }, r.value), null, 16),
          ye(Je, ee({ cols: "4" }, r.value), null, 16),
          ye(Je, ee({ cols: "4" }, r.value), null, 16),
          ye(Je, ee({ cols: "6" }, r.value), null, 16),
          ye(Je, ee({ cols: "8" }, r.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      p(n) ? void 0 : {
        name: "img",
        fn: R(() => [
          O(i.$slots, "img", {}, () => [
            ye(vo, {
              blank: !i.imgSrc,
              "blank-color": i.imgBlankColor,
              height: i.imgSrc ? void 0 : i.imgHeight,
              src: i.imgSrc,
              top: !i.imgBottom,
              bottom: i.imgBottom,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "top", "bottom"])
          ])
        ]),
        key: "0"
      },
      p(a) ? void 0 : {
        name: "header",
        fn: R(() => [
          O(i.$slots, "header", {}, () => [
            ye(Je, {
              width: i.headerWidth,
              variant: i.headerVariant,
              animation: i.headerAnimation,
              size: i.headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      p(l) ? void 0 : {
        name: "footer",
        fn: R(() => [
          O(i.$slots, "footer", {}, () => [
            (g(), H(fe(s.value), {
              width: i.footerWidth,
              animation: i.footerAnimation,
              size: p(o) ? i.footerSize : void 0,
              variant: i.footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), Kd = ["id"], Yd = ["id"], go = /* @__PURE__ */ q({
  __name: "BTableSimple",
  props: {
    bordered: { type: [Boolean, String], default: !1 },
    borderless: { type: [Boolean, String], default: !1 },
    borderVariant: { default: null },
    captionTop: { type: [Boolean, String], default: !1 },
    dark: { type: [Boolean, String], default: !1 },
    fixed: { type: [Boolean, String], default: !1 },
    hover: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    noBorderCollapse: { type: [Boolean, String], default: !1 },
    outlined: { type: [Boolean, String], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    stickyHeader: { type: [Boolean, String], default: !1 },
    striped: { type: [Boolean, String], default: !1 },
    stripedColumns: { type: [Boolean, String], default: !1 },
    tableClass: { default: void 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = d(() => t.captionTop), a = d(() => t.borderless), l = d(() => t.bordered), n = d(() => t.dark), r = d(() => t.hover), s = d(() => t.small), i = d(() => t.striped), u = d(() => t.stickyHeader), c = d(() => t.stripedColumns), f = d(() => t.responsive), b = d(() => t.stacked), m = w(() => [
      t.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": l.value,
        "table-borderless": a.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "caption-top": o.value,
        "table-dark": n.value,
        "table-hover": r.value,
        "b-table-stacked": b.value === !0,
        [`b-table-stacked-${b.value}`]: typeof b.value == "string",
        "table-striped": i.value,
        "table-sm": s.value,
        [`table-${t.variant}`]: t.variant !== null,
        "table-striped-columns": c.value
      }
    ]), h = w(() => ({
      "table-responsive": f.value === !0,
      [`table-responsive-${f.value}`]: typeof f.value == "string",
      "b-table-sticky-header": u.value
    }));
    return ($, B) => p(f) ? (g(), I("div", {
      key: 1,
      class: G(h.value)
    }, [
      le("table", {
        id: $.id,
        class: G(m.value)
      }, [
        O($.$slots, "default")
      ], 10, Yd)
    ], 2)) : (g(), I("table", {
      key: 0,
      id: $.id,
      class: G(m.value)
    }, [
      O($.$slots, "default")
    ], 10, Kd));
  }
}), Zd = /* @__PURE__ */ q({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: [Boolean, String], default: !1 },
    rows: { default: 3 },
    showFooter: { type: [Boolean, String], default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, o = Se(() => t.columns), a = Se(() => t.rows), l = P(() => t.headerColumns ?? NaN), n = P(() => t.footerColumns ?? NaN), r = Se(l), s = Se(n), i = P(() => o.value || 5), u = P(() => a.value || 3), c = P(
      () => t.headerColumns === void 0 ? i.value : r.value
    ), f = P(
      () => t.footerColumns === void 0 ? i.value : s.value
    ), b = d(() => t.hideHeader), m = d(() => t.showFooter);
    return (h, $) => (g(), H(go, null, {
      default: R(() => [
        p(b) ? se("", !0) : O(h.$slots, "thead", { key: 0 }, () => [
          le("thead", null, [
            le("tr", null, [
              (g(!0), I(me, null, Ee(c.value, (B, v) => (g(), I("th", { key: v }, [
                ye(Je, {
                  size: h.headerSize,
                  variant: h.headerVariant,
                  animation: h.headerAnimation,
                  width: h.headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        O(h.$slots, "default", {}, () => [
          le("tbody", null, [
            (g(!0), I(me, null, Ee(u.value, (B, v) => (g(), I("tr", { key: v }, [
              (g(!0), I(me, null, Ee(i.value, (S, y) => (g(), I("td", { key: y }, [
                ye(Je, {
                  size: h.size,
                  variant: h.variant,
                  animation: h.animation,
                  width: h.cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        p(m) ? O(h.$slots, "tfoot", { key: 1 }, () => [
          le("tfoot", null, [
            le("tr", null, [
              (g(!0), I(me, null, Ee(f.value, (B, v) => (g(), I("th", { key: v }, [
                ye(Je, {
                  size: h.footerSize,
                  variant: h.footerVariant,
                  animation: h.footerAnimation,
                  width: h.footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : se("", !0)
      ]),
      _: 3
    }));
  }
}), Jd = /* @__PURE__ */ q({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: [Boolean, String], default: !1 }
  },
  setup(e) {
    const t = e, o = d(() => t.loading);
    return (a, l) => p(o) ? O(a.$slots, "loading", { key: 0 }) : O(a.$slots, "default", { key: 1 });
  }
}), Zo = Sa("cols", [""], { type: [String, Number], default: null }), Qd = q({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Zo
  },
  setup(e) {
    const t = d(() => e.noGutters), o = Jt(() => e.alignH), a = w(() => Il(e, Zo, "cols", "row-cols"));
    return {
      computedClasses: w(() => [
        a.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [o.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function ec(e, t, o, a, l, n) {
  return g(), H(fe(e.tag), {
    class: G(["row", e.computedClasses])
  }, {
    default: R(() => [
      O(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const tc = /* @__PURE__ */ $a(Qd, [["render", ec]]), Pn = /* @__PURE__ */ q({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`thead-${t.variant}`]: t.variant !== null
    }));
    return (a, l) => (g(), I("tbody", {
      class: G(o.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), ac = ["scope", "colspan", "rowspan", "data-label"], oc = { key: 0 }, Ft = /* @__PURE__ */ q({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = d(() => t.stickyColumn), a = w(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": o.value,
      "table-b-table-default": o.value && t.variant === null
    })), l = P(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), I("td", {
      scope: l.value,
      class: G(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading ? (g(), I("div", oc, [
        O(n.$slots, "default")
      ])) : O(n.$slots, "default", { key: 1 })
    ], 10, ac));
  }
}), qa = /* @__PURE__ */ q({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, l) => (g(), I("tfoot", {
      class: G(o.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), lc = ["scope", "colspan", "rowspan", "data-label"], nc = { key: 0 }, Wa = /* @__PURE__ */ q({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = d(() => t.stickyColumn), a = w(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": o.value,
      "table-b-table-default": o.value && t.variant === null
    })), l = P(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), I("th", {
      scope: l.value,
      class: G(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading !== void 0 ? (g(), I("div", nc, [
        O(n.$slots, "default")
      ])) : O(n.$slots, "default", { key: 1 })
    ], 10, lc));
  }
}), Nn = /* @__PURE__ */ q({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, l) => (g(), I("thead", {
      class: G(o.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), nt = /* @__PURE__ */ q({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, o = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, l) => (g(), I("tr", {
      class: G(o.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), sc = {
  key: 0,
  class: "b-table-stacked-label"
}, rc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, ic = { key: 2 }, In = /* @__PURE__ */ q({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: [Boolean, String], default: !1 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: [Boolean, String], default: !1 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: [Boolean, String], default: !1 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: [Boolean, String], default: void 0 },
    borderless: { type: [Boolean, String], default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: [Boolean, String], default: void 0 },
    dark: { type: [Boolean, String], default: void 0 },
    fixed: { type: [Boolean, String], default: void 0 },
    hover: { type: [Boolean, String], default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: [Boolean, String], default: void 0 },
    outlined: { type: [Boolean, String], default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: [Boolean, String], default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String], default: void 0 },
    striped: { type: [Boolean, String], default: void 0 },
    stripedColumns: { type: [Boolean, String], default: void 0 },
    tableClass: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = d(() => o.footClone), n = d(() => o.labelStacked), r = d(() => o.showEmpty), s = d(() => o.stacked), i = w(() => [
      o.tableClass,
      {
        [`align-${o.align}`]: o.align !== void 0
      }
    ]), u = w(() => !o.fields.length && o.items.length ? Object.keys(o.items[0]).map((v) => {
      const S = Va(v);
      return {
        key: v,
        label: S,
        tdAttr: s.value === !0 ? { "data-label": S } : void 0
      };
    }) : o.fields.map((v) => {
      if (typeof v == "string") {
        const S = Va(v);
        return {
          key: v,
          label: S,
          tdAttr: s.value === !0 ? { "data-label": S } : void 0
        };
      }
      return {
        ...v,
        tdAttr: s.value === !0 ? { "data-label": Va(v.key), ...v.tdAttr } : v.tdAttr
      };
    })), c = P(() => u.value.length), f = (v, S, y) => {
      const _ = st(v, S);
      return y && typeof y == "function" ? y(_, S, v) : y;
    }, b = (v, S, y = !1) => {
      const _ = typeof v == "string" ? v : v.key;
      a("head-clicked", _, v, S, y);
    }, m = (v) => {
      v._showDetails = !v._showDetails;
    }, h = (v) => [
      v.class,
      v.thClass,
      {
        "b-table-sticky-column": v.stickyColumn
      },
      o.fieldColumnClass ? typeof o.fieldColumnClass == "function" ? o.fieldColumnClass(v) : o.fieldColumnClass : null
    ], $ = (v, S) => {
      var y;
      return [
        v.class,
        v.tdClass,
        (y = S._cellVariants) != null && y[v.key] ? `table-${S._cellVariants[v.key]}` : null,
        {
          "b-table-sticky-column": v.stickyColumn
        }
      ];
    }, B = (v, S) => o.tbodyTrClass ? typeof o.tbodyTrClass == "function" ? o.tbodyTrClass(v, S) : o.tbodyTrClass : null;
    return (v, S) => (g(), H(go, {
      id: v.id,
      bordered: v.bordered,
      borderless: v.borderless,
      "border-variant": v.borderVariant,
      "caption-top": v.captionTop,
      dark: v.dark,
      fixed: v.fixed,
      hover: v.hover,
      "no-border-collapse": v.noBorderCollapse,
      outlined: v.outlined,
      responsive: v.responsive,
      small: v.small,
      stacked: p(s),
      "sticky-header": v.stickyHeader,
      striped: v.striped,
      "table-class": i.value,
      variant: v.variant,
      "striped-columns": v.stripedColumns
    }, {
      default: R(() => [
        ye(Nn, {
          variant: v.headVariant,
          class: G(v.theadClass)
        }, {
          default: R(() => [
            v.$slots["thead-top"] ? O(v.$slots, "thead-top", { key: 0 }) : se("", !0),
            ye(nt, {
              variant: v.headRowVariant,
              class: G(v.theadTrClass)
            }, {
              default: R(() => [
                (g(!0), I(me, null, Ee(u.value, (y) => (g(), H(Wa, ee({
                  key: y.key,
                  scope: "col",
                  class: h(y),
                  title: y.headerTitle,
                  variant: y.variant,
                  abbr: y.headerAbbr,
                  style: y.thStyle
                }, y.thAttr, {
                  onClick: (_) => b(y, _)
                }), {
                  default: R(() => [
                    O(v.$slots, v.$slots[`head(${String(y.key)})`] ? `head(${String(y.key)})` : "head()", {
                      label: y.label,
                      column: y.key,
                      field: y,
                      isFoot: !1
                    }, () => [
                      de(ae(p(ia)(y)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            v.$slots["thead-sub"] ? (g(), H(nt, { key: 1 }, {
              default: R(() => [
                (g(!0), I(me, null, Ee(u.value, (y) => (g(), H(Ft, {
                  key: y.key,
                  scope: "col",
                  variant: y.variant,
                  class: G([y.class, y.thClass])
                }, {
                  default: R(() => [
                    O(v.$slots, "thead-sub", ee({ items: u.value }, y), () => [
                      de(ae(y.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : se("", !0)
          ]),
          _: 3
        }, 8, ["variant", "class"]),
        ye(Pn, {
          class: G(v.tbodyClass)
        }, {
          default: R(() => [
            O(v.$slots, "custom-body", {
              fields: u.value,
              items: v.items,
              columns: u.value.length
            }, () => [
              !p(s) && v.$slots["top-row"] ? (g(), H(nt, { key: 0 }, {
                default: R(() => [
                  O(v.$slots, "top-row")
                ]),
                _: 3
              })) : se("", !0),
              (g(!0), I(me, null, Ee(v.items, (y, _) => (g(), I(me, { key: _ }, [
                ye(nt, {
                  class: G(B(y, "row")),
                  variant: y._rowVariant,
                  onClick: (C) => !p(aa)(C) && a("row-clicked", y, _, C),
                  onDblclick: (C) => !p(aa)(C) && a("row-dbl-clicked", y, _, C),
                  onMouseenter: (C) => !p(aa)(C) && a("row-hovered", y, _, C),
                  onMouseleave: (C) => !p(aa)(C) && a("row-unhovered", y, _, C)
                }, {
                  default: R(() => [
                    (g(!0), I(me, null, Ee(u.value, (C) => {
                      var T;
                      return g(), H(Ft, ee({
                        key: C.key,
                        variant: (T = y._cellVariants) != null && T[C.key] ? null : C.variant,
                        class: $(C, y)
                      }, f(y, String(C.key), C.tdAttr)), {
                        default: R(() => [
                          p(s) && p(n) ? (g(), I("label", sc, ae(p(ia)(C)), 1)) : se("", !0),
                          O(
                            v.$slots,
                            v.$slots[`cell(${String(C.key)})`] ? `cell(${String(C.key)})` : "cell()",
                            {
                              value: p(st)(y, String(C.key)),
                              index: _,
                              item: y,
                              field: C,
                              items: v.items,
                              toggleDetails: () => {
                                m(y);
                              },
                              detailsShowing: y._showDetails ?? !1
                            },
                            () => [
                              !v.$slots[`cell(${String(C.key)})`] && !v.$slots["cell()"] ? (g(), I(me, { key: 0 }, [
                                de(ae(p(Nl)(y, String(C.key), C.formatter)), 1)
                              ], 64)) : se("", !0)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                y._showDetails === !0 && v.$slots["row-details"] ? (g(), I(me, { key: 0 }, [
                  ye(nt, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  ye(nt, {
                    class: G(B(y, "row-details")),
                    variant: y._rowVariant
                  }, {
                    default: R(() => [
                      ye(Ft, { colspan: c.value }, {
                        default: R(() => [
                          O(v.$slots, "row-details", {
                            item: y,
                            toggleDetails: () => {
                              m(y);
                            },
                            fields: v.fields,
                            index: _
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan"])
                    ]),
                    _: 2
                  }, 1032, ["class", "variant"])
                ], 64)) : se("", !0)
              ], 64))), 128)),
              p(r) && v.items.length === 0 ? (g(), H(nt, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: R(() => [
                  ye(Ft, { colspan: c.value }, {
                    default: R(() => [
                      O(v.$slots, "empty", { items: v.items }, () => [
                        de(ae(v.emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : se("", !0),
              !p(s) && v.$slots["bottom-row"] ? (g(), H(nt, { key: 2 }, {
                default: R(() => [
                  O(v.$slots, "bottom-row")
                ]),
                _: 3
              })) : se("", !0)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        p(l) ? (g(), H(qa, {
          key: 0,
          variant: v.footVariant,
          class: G(v.tfootClass)
        }, {
          default: R(() => [
            ye(nt, {
              variant: v.footRowVariant,
              class: G(v.tfootTrClass)
            }, {
              default: R(() => [
                (g(!0), I(me, null, Ee(u.value, (y) => (g(), H(Wa, ee({
                  key: y.key,
                  scope: "col",
                  class: h(y),
                  title: y.headerTitle,
                  abbr: y.headerAbbr,
                  style: y.thStyle,
                  variant: y.variant
                }, y.thAttr, {
                  onClick: (_) => b(y, _, !0)
                }), {
                  default: R(() => [
                    le("div", rc, [
                      le("div", null, [
                        O(
                          v.$slots,
                          v.$slots[`foot(${String(y.key)})`] ? `foot(${String(y.key)})` : "foot()",
                          {
                            label: y.label,
                            column: y.key,
                            field: y,
                            isFoot: !0
                          },
                          () => [
                            de(ae(p(ia)(y)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : v.$slots["custom-foot"] ? (g(), H(qa, { key: 1 }, {
          default: R(() => [
            O(v.$slots, "custom-foot", {
              fields: u.value,
              items: v.items,
              columns: u.value.length
            })
          ]),
          _: 3
        })) : se("", !0),
        v.$slots["table-caption"] || v.caption ? (g(), I("caption", ic, [
          O(v.$slots, "table-caption", {}, () => [
            de(ae(v.caption), 1)
          ])
        ])) : se("", !0)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
}), uc = /* @__PURE__ */ le("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1), dc = [
  uc
], cc = /* @__PURE__ */ le("path", {
  "fill-rule": "evenodd",
  d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
}, null, -1), fc = [
  cc
], vc = { class: "d-flex align-items-center gap-2 mt-5" }, pc = /* @__PURE__ */ q({
  __name: "BTable",
  props: {
    provider: { default: void 0 },
    sortCompare: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: [Boolean, String], default: !1 },
    noProviderSorting: { type: [Boolean, String], default: !1 },
    noProviderFiltering: { type: [Boolean, String], default: !1 },
    sortBy: { default: void 0 },
    sortDesc: { type: [Boolean, String], default: !1 },
    selectable: { type: [Boolean, String], default: !1 },
    stickySelect: { type: [Boolean, String], default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: [Boolean, String], default: !1 },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: 1 / 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: [Boolean, String], default: !1 },
    noSelectOnClick: { type: [Boolean, String], default: !1 },
    sortCompareLocale: { default: void 0 },
    sortCompareOptions: { default: () => ({ numeric: !0 }) },
    selectedItems: { default: () => [] },
    noSortableIcon: { type: [Boolean, String], default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: [Boolean, String], default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: [Boolean, String], default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: [Boolean, String], default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: [Boolean, String], default: void 0 },
    borderless: { type: [Boolean, String], default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: [Boolean, String], default: void 0 },
    dark: { type: [Boolean, String], default: void 0 },
    fixed: { type: [Boolean, String], default: void 0 },
    hover: { type: [Boolean, String], default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: [Boolean, String], default: void 0 },
    outlined: { type: [Boolean, String], default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: [Boolean, String], default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String], default: void 0 },
    striped: { type: [Boolean, String], default: void 0 },
    stripedColumns: { type: [Boolean, String], default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-selected", "row-unhovered", "row-unselected", "selection", "sorted", "update:busy", "update:selectedItems", "update:sortDesc", "update:sortBy"],
  setup(e, { expose: t, emit: o }) {
    const a = e, l = o, n = _e(a, "sortBy", l, { passive: !0 }), r = _e(a, "busy", l, { passive: !0 }), s = _e(a, "sortDesc", l, { passive: !0 }), i = _e(a, "selectedItems", l, {
      passive: !0
    }), u = w({
      get: () => /* @__PURE__ */ new Set([...i.value]),
      set: (M) => {
        i.value = [...M];
      }
    }), c = {
      add: (M) => {
        const X = new Set(u.value);
        X.add(M), u.value = X, l("row-selected", M);
      },
      clear: () => {
        u.value.forEach((M) => {
          c.delete(M);
        });
      },
      delete: (M) => {
        const X = new Set(u.value);
        X.delete(M), u.value = X, l("row-unselected", M);
      },
      /* TODO
      This has method and the delete method suffer from an error when using a non-reactive source as the items prop
      ```ts
      const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]
      ```
      For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine
      Getting the reference properly will fix all outstanding issues
      */
      has: (M) => {
        if (!a.primaryKey)
          return u.value.has(M);
        const X = a.primaryKey;
        for (const L of u.value) {
          const j = st(L, X), Q = st(M, X);
          if (j && Q && j === Q)
            return !0;
        }
        return !1;
      }
    }, f = W([]), b = d(s), m = d(r), h = d(() => a.noProviderPaging), $ = d(() => a.noProviderSorting), B = d(() => a.noProviderFiltering), v = d(() => a.selectable), S = d(() => a.noSortableIcon), y = d(() => a.noSelectOnClick), _ = d(() => a.noLocalSorting), C = Se(() => a.perPage, { method: "parseInt" }), T = Se(() => a.currentPage, { method: "parseInt" }), k = P(() => !!a.filter), N = P(() => a.provider !== void 0), V = P(() => u.value.size > 0), A = w(
      () => n.value !== void 0 || a.fields.some((M) => typeof M == "string" ? !1 : M.sortable)
    ), E = w(
      () => a.fields.map(
        (M) => typeof M == "string" ? M : {
          ...M,
          thAttr: {
            "aria-sort": A.value === !1 ? void 0 : n.value !== M.key ? "none" : b.value === !0 ? "descending" : "ascending",
            ...M.thAttr
          }
        }
      )
    ), K = w(() => ({
      "b-table-busy": m.value,
      "b-table-selectable": v.value,
      "user-select-none": v.value && V.value
    })), oe = w(() => [
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(null, "table-busy") : a.tbodyTrClass : null
    ]), F = (M) => [
      {
        "b-table-sortable-column": A.value && M.sortable
      }
    ], z = (M, X) => [
      {
        [`selected table-${a.selectionVariant}`]: v.value && M && c.has(M)
      },
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(M, X) : a.tbodyTrClass : null
    ], D = (M) => n.value !== M.key ? { opacity: 0.5 } : {}, J = w(() => {
      const M = (j) => {
        const Q = n.value;
        if (Q === void 0)
          return j;
        const Z = E.value.find((Y) => typeof Y == "string" ? !1 : Y.key === Q);
        return typeof Z != "string" && (Z == null ? void 0 : Z.sortable) === !1 ? j : [...j].sort((Y, pe) => {
          if (a.sortCompare !== void 0)
            return a.sortCompare(Y, pe, Q, b.value);
          const ne = (Be) => {
            const ue = Be[Q];
            if (Z && typeof Z != "string" && Z.sortByFormatted) {
              const x = typeof Z.sortByFormatted == "function" ? Z.sortByFormatted : Z.formatter;
              if (x)
                return Nl(Be, String(Z.key), x);
            }
            return typeof ue == "object" && ue !== null ? JSON.stringify(ue) : (ue == null ? void 0 : ue.toString()) ?? "";
          };
          return ne(Y).localeCompare(ne(pe), a.sortCompareLocale, a.sortCompareOptions) * (b.value ? -1 : 1);
        });
      }, X = (j) => j.filter(
        (Q) => Object.entries(Q).some(([Z, Y]) => {
          var ne, Be, ue;
          return Y == null || Z[0] === "_" || !((ne = a.filterable) != null && ne.includes(Z)) && ((Be = a.filterable) != null && Be.length) ? !1 : (typeof Y == "object" ? JSON.stringify(Object.values(Y)) : Y.toString()).toLowerCase().includes(((ue = a.filter) == null ? void 0 : ue.toLowerCase()) ?? "");
        })
      );
      let L = N.value ? f.value : a.items;
      return (k.value === !0 && !N.value || k.value === !0 && N.value && B.value) && (L = X(L)), (A.value === !0 && !N.value && !_.value || A.value === !0 && N.value && $.value) && (L = M(L)), L;
    }), ie = w(() => Number.isNaN(C.value) || N.value && !h.value ? J.value : J.value.slice(
      (T.value - 1) * (C.value || 1 / 0),
      T.value * (C.value || 1 / 0)
    )), te = (M, X, L = !1, j = !1, Q = !1) => {
      if (v.value) {
        if (a.selectMode === "single" || a.selectMode === "multi") {
          if (L || j)
            return;
          c.has(M) ? c.delete(M) : (a.selectMode === "single" && c.clear(), c.add(M));
        } else if (j || Q)
          c.has(M) ? c.delete(M) : c.add(M);
        else if (L) {
          const Z = [...u.value].pop(), Y = a.items.findIndex((Be) => Be === Z), pe = Math.min(Y, X), ne = Math.max(Y, X);
          a.items.slice(pe, ne + 1).forEach((Be) => {
            c.has(Be) || c.add(Be);
          });
        } else
          c.clear(), c.add(M);
        ke();
      }
    }, he = (M, X, L) => {
      y.value === !1 && te(M, X, L.shiftKey, L.ctrlKey, L.metaKey), l("row-clicked", M, X, L);
    }, Oe = (M) => {
      if (!A.value)
        return;
      const X = typeof M == "string" ? M : M.key, L = typeof M == "string" ? !1 : M.sortable;
      A.value === !0 && L === !0 && (n.value !== X ? (n.value = X, s.value = !1) : b.value === !1 ? s.value = !0 : (n.value = void 0, s.value = !1), l("sorted", X, n.value === void 0 ? !1 : !b.value));
    }, ve = (M, X, L, j = !1) => {
      l("head-clicked", M, X, L, j), Oe(X);
    }, ge = async () => {
      if (!N.value || a.provider === void 0 || m.value)
        return;
      r.value = !0;
      const M = a.provider({
        currentPage: T.value,
        filter: a.filter,
        sortBy: n.value,
        sortDesc: a.sortDesc,
        perPage: C.value
      });
      try {
        const X = M instanceof Promise ? await M : M;
        if (X === void 0)
          return;
        f.value = X;
      } finally {
        r.value = !1;
      }
    }, ke = () => {
      v.value && l("selection", [...u.value]);
    }, Ce = async (M, X, L) => {
      if (X === L)
        return;
      const j = (pe) => {
        var ne;
        return ((ne = a.noProvider) == null ? void 0 : ne.includes(pe)) === !0;
      }, Q = (M === "currentPage" || M === "perPage") && (j("paging") || h.value === !0), Z = M === "filter" && (j("filtering") || B.value === !0), Y = (M === "sortBy" || M === "sortDesc") && (j("sorting") || $.value === !0);
      Q || Z || Y || (N.value === !0 && await ge(), M === "currentPage" || M === "perPage" || l("filtered", [...J.value]));
    };
    return ce(
      () => a.filter,
      (M, X) => {
        Ce("filter", M, X), !(M === X || N.value) && (M || l("filtered", [...J.value]));
      }
    ), ce(T, (M, X) => {
      Ce("currentPage", M, X);
    }), ce(C, (M, X) => {
      Ce("perPage", M, X);
    }), ce(n, (M, X) => {
      Ce("sortBy", M, X);
    }), ce(b, (M, X) => {
      Ce("sortDesc", M, X);
    }), ce(
      () => a.provider,
      (M) => {
        if (M === void 0) {
          f.value = [];
          return;
        }
        ge();
      }
    ), at(ge), t({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        v.value && (c.clear(), ke());
      },
      refresh: ge,
      selectAllRows: () => {
        if (!v.value)
          return;
        const M = u.value.size > 0 ? [...u.value] : [];
        u.value = /* @__PURE__ */ new Set([...J.value]), u.value.forEach((X) => {
          M.includes(X) || l("row-selected", X);
        }), ke();
      },
      selectRow: (M) => {
        if (!v.value)
          return;
        const X = J.value[M];
        !X || c.has(X) || (c.add(X), ke());
      },
      unselectRow: (M) => {
        if (!v.value)
          return;
        const X = J.value[M];
        !X || !c.has(X) || (c.delete(X), ke());
      }
    }), (M, X) => (g(), H(In, ee(a, {
      "aria-busy": p(m),
      items: ie.value,
      fields: E.value,
      "table-class": K.value,
      "tbody-tr-class": z,
      "field-column-class": F,
      onHeadClicked: ve,
      onRowClicked: he,
      onRowHovered: X[0] || (X[0] = (L, j, Q) => {
        l("row-hovered", L, j, Q);
      }),
      onRowUnhovered: X[1] || (X[1] = (L, j, Q) => {
        l("row-unhovered", L, j, Q);
      })
    }), Ua({
      "head()": R((L) => [
        de(ae(p(ia)(L.field)) + " ", 1),
        A.value && L.field.sortable && p(S) === !1 ? (g(), I(me, { key: 0 }, [
          p(b) ? O(M.$slots, "sortDesc", we(ee({ key: 1 }, { ...L })), () => [
            (g(), I("svg", {
              style: Me(D(L.field)),
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              fill: "currentColor",
              class: "bi bi-arrow-down-short",
              viewBox: "0 0 16 16",
              "aria-hidden": ""
            }, fc, 4))
          ]) : O(M.$slots, "sortAsc", we(ee({ key: 0 }, { ...L })), () => [
            (g(), I("svg", {
              style: Me(D(L.field)),
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              fill: "currentColor",
              class: "bi bi-arrow-up-short",
              viewBox: "0 0 16 16",
              "aria-hidden": ""
            }, dc, 4))
          ])
        ], 64)) : se("", !0)
      ]),
      "custom-body": R((L) => [
        p(m) ? (g(), H(nt, {
          key: 0,
          class: G(["b-table-busy-slot", oe.value])
        }, {
          default: R(() => [
            ye(Ft, {
              colspan: L.fields.length
            }, {
              default: R(() => [
                O(M.$slots, "table-busy", {}, () => [
                  ye(ka, { show: "" }, {
                    overlay: R(() => [
                      le("div", vc, [
                        ye(Ca),
                        le("strong", null, ae(M.busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : se("", !0)
      ]),
      _: 2
    }, [
      Ee(M.$slots, (L, j) => ({
        name: j,
        fn: R((Q) => [
          O(M.$slots, j, we(Ae(Q)))
        ])
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
}), mc = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "BTab",
  props: {
    active: { type: [Boolean, String], default: !1 },
    buttonId: { default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    lazy: { type: [Boolean, String], default: void 0 },
    lazyOnce: { type: [Boolean, String], default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  emits: ["update:active"],
  setup(e, { emit: t }) {
    const o = e, a = je(), l = t, n = ze(Ll, null), r = Pe(() => o.id, "tabpane"), s = Pe(() => o.buttonId, "tab"), i = d(() => o.active), u = d(() => o.disabled), c = d(() => o.lazyOnce ?? o.lazy), f = d(() => o.noBody), b = W(!1), m = W(null), { onClick: h, ...$ } = Zt(), B = w(
      () => ({
        id: r.value,
        buttonId: s.value,
        disabled: u.value,
        title: o.title,
        titleComponent: a.title,
        titleItemClass: o.titleItemClass,
        titleLinkAttrs: o.titleLinkAttrs,
        titleLinkClass: o.titleLinkClass,
        onClick: h,
        el: m.value
      })
    );
    at(() => {
      n && (n.registerTab(B), i.value && n.activateTab(r.value));
    }), Wn(() => {
      n && n.unregisterTab(r.value);
    });
    const v = P(() => (n == null ? void 0 : n.activeId.value) === r.value), S = W(v.value), y = P(() => !!(n != null && n.lazy.value || c.value)), _ = P(() => o.lazyOnce !== void 0), C = P(() => v.value && !u.value), T = P(
      () => C.value || !y.value || y.value && _.value && b.value
    );
    ce(v, (N) => {
      if (N) {
        l("update:active", !0), setTimeout(() => {
          S.value = !0;
        }, 0);
        return;
      }
      S.value = !1, l("update:active", !1);
    }), ce(i, (N) => {
      if (n) {
        if (!N) {
          v.value && n.activateTab(void 0);
          return;
        }
        n.activateTab(r.value);
      }
    });
    const k = w(() => [
      {
        active: v.value,
        show: S.value,
        "card-body": (n == null ? void 0 : n.card.value) && f.value === !1,
        fade: !(n != null && n.noFade.value)
      },
      S.value ? n == null ? void 0 : n.activeTabClass : n == null ? void 0 : n.inactiveTabClass,
      n == null ? void 0 : n.tabClass
    ]);
    return ce(T, (N) => {
      N && !b.value && (b.value = !0);
    }), (N, V) => (g(), H(fe(N.tag), ee({
      id: p(r),
      ref_key: "el",
      ref: m,
      class: ["tab-pane", k.value],
      role: "tabpanel",
      "aria-labelledby": p(s)
    }, $), {
      default: R(() => [
        T.value ? O(N.$slots, "default", { key: 0 }) : se("", !0)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
}), gc = ["aria-orientation"], bc = ["id", "aria-controls", "aria-selected", "onClick"], yc = /* @__PURE__ */ q({
  __name: "BTabs",
  props: {
    activeId: { default: void 0 },
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: [Boolean, String], default: !1 },
    contentClass: { default: void 0 },
    end: { type: [Boolean, String], default: !1 },
    fill: { type: [Boolean, String], default: !1 },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: [Boolean, String], default: !1 },
    lazy: { type: [Boolean, String], default: !1 },
    modelValue: { default: -1 },
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: [Boolean, String], default: !1 },
    noNavStyle: { type: [Boolean, String], default: !1 },
    pills: { type: [Boolean, String], default: !1 },
    small: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: [Boolean, String], default: !1 }
  },
  emits: ["activate-tab", "click", "update:activeId", "update:modelValue"],
  setup(e, { emit: t }) {
    const o = e, a = t, l = _e(o, "modelValue", a, { passive: !0 }), n = _e(o, "activeId", a, { passive: !0 }), r = d(() => o.card), s = d(() => o.end), i = d(() => o.fill), u = d(() => o.justified), c = d(() => o.lazy), f = d(() => o.noFade), b = d(() => o.noNavStyle), m = d(() => o.pills), h = d(() => o.small), $ = d(() => o.vertical), B = pa(), v = W([]), S = w(
      () => v.value.map((F) => {
        const z = p(F), D = z.id === n.value;
        return {
          ...z,
          active: D,
          navItemClasses: [
            {
              active: D,
              disabled: z.disabled
            },
            D ? o.activeNavItemClass : o.inactiveNavItemClass,
            o.navItemClass,
            z.titleLinkClass
          ]
        };
      })
    ), y = P(() => !(S != null && S.value && S.value.length > 0)), _ = w(() => ({
      "d-flex": $.value,
      "align-items-start": $.value
    })), C = Jt(() => o.align), T = w(() => ({
      "nav-pills": m.value,
      "flex-column me-3": $.value,
      [C.value]: o.align !== void 0,
      "nav-fill": i.value,
      "card-header-tabs": r.value,
      "nav-justified": u.value,
      "nav-tabs": !b.value && !m.value,
      small: h.value
    })), k = (F) => {
      var z;
      if (F !== void 0) {
        const D = (z = S.value[F]) == null ? void 0 : z.id;
        if (F > -1 && F < S.value.length && !S.value[F].disabled && (l.value < 0 || n.value !== D || l.value !== F)) {
          const J = new vt("activate-tab", { cancelable: !0 });
          a("activate-tab", F, l.value, J), J.defaultPrevented || (n.value !== D && (n.value = D), l.value !== F && (l.value = F));
        }
      }
    }, N = (F, z) => {
      var D, J, ie;
      k(z), z >= 0 && !S.value[z].disabled && ((D = S.value[z]) != null && D.onClick) && typeof S.value[z].onClick == "function" && ((ie = (J = S.value[z]).onClick) == null || ie.call(J, F));
    }, V = (F) => {
      var z, D;
      S.value.length <= 0 || (l.value = A(l.value + F, F), (D = document.getElementById((z = S.value[l.value]) == null ? void 0 : z.buttonId)) == null || D.focus());
    }, A = (F, z) => {
      let D = F, J = -1, ie = -1;
      for (let te = 0; te < S.value.length; te++)
        S.value[te].disabled || (J === -1 && (J = te), ie = te);
      for (; D >= J && D <= ie && S.value[D].disabled; )
        D += z;
      return D < J && (D = J), D > ie && (D = ie), D;
    };
    ce(l, (F, z) => {
      if (F === z || S.value.length <= 0)
        return;
      const D = A(F, F > z ? 1 : -1);
      Fe(() => {
        k(D);
      });
    }), ce(n, (F, z) => {
      const D = S.value.findIndex((J) => J.id === F);
      if (F !== z && !(S.value.length <= 0)) {
        if (D === -1) {
          k(A(0, 1));
          return;
        }
        k(D);
      }
    });
    const E = (F) => {
      v.value.find((z) => z.value.id === F.value.id) ? v.value[v.value.findIndex((z) => z.value.id === F.value.id)] = F : v.value.push(F), v.value.sort((z, D) => {
        if (!Node || !z.value.el || !D.value.el)
          return 0;
        const J = z.value.el.compareDocumentPosition(D.value.el);
        return J & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : J & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, K = (F) => {
      v.value = v.value.filter((z) => z.value.id !== F);
    };
    ce(
      v,
      () => {
        oe();
      },
      { deep: !0 }
    );
    const oe = () => {
      var F;
      if (S.value.length === 0) {
        l.value = -1, n.value = void 0;
        return;
      }
      if (l.value >= 0 && !n.value && (n.value = (F = S.value[l.value]) == null ? void 0 : F.id), S.value.find((z) => z.id === n.value)) {
        k(S.value.findIndex((z) => z.id === n.value));
        return;
      }
      k(S.value.map((z) => !z.disabled).indexOf(!0));
    };
    return dt(Ll, {
      lazy: c,
      card: r,
      noFade: f,
      activeTabClass: P(() => o.activeTabClass),
      inactiveTabClass: P(() => o.inactiveTabClass),
      tabClass: P(() => o.tabClass),
      registerTab: E,
      unregisterTab: K,
      activeId: n,
      activateTab: (F) => {
        const z = S.value.findIndex((D) => D.id === F);
        if (F === void 0 || z === -1) {
          k(A(0, 1));
          return;
        }
        k(z);
      }
    }), (F, z) => (g(), H(fe(F.tag), {
      id: F.id,
      class: G(["tabs", _.value])
    }, {
      default: R(() => [
        ye(p(B).define, null, {
          default: R(() => [
            le("div", {
              class: G(["tab-content", F.contentClass])
            }, [
              O(F.$slots, "default"),
              y.value ? (g(), I("div", {
                key: "bv-empty-tab",
                class: G(["tab-pane active", { "card-body": p(r) }])
              }, [
                O(F.$slots, "empty")
              ], 2)) : se("", !0)
            ], 2)
          ]),
          _: 3
        }),
        p(s) ? (g(), H(p(B).reuse, { key: 0 })) : se("", !0),
        le("div", {
          class: G([F.navWrapperClass, { "card-header": p(r), "ms-auto": F.vertical && p(s) }])
        }, [
          le("ul", {
            class: G(["nav", [T.value, F.navClass]]),
            role: "tablist",
            "aria-orientation": F.vertical ? "vertical" : "horizontal"
          }, [
            O(F.$slots, "tabs-start"),
            (g(!0), I(me, null, Ee(S.value, (D, J) => (g(), I("li", {
              key: D.id,
              class: G(["nav-item", D.titleItemClass]),
              role: "presentation"
            }, [
              le("button", ee({
                id: D.buttonId,
                class: ["nav-link", D.navItemClasses],
                role: "tab",
                "aria-controls": D.id,
                "aria-selected": D.active
              }, D.titleLinkAttrs, {
                onKeydown: [
                  z[0] || (z[0] = ta(ht((ie) => V(-1), ["stop", "prevent"]), ["left"])),
                  z[1] || (z[1] = ta(ht((ie) => V(1), ["stop", "prevent"]), ["right"])),
                  z[2] || (z[2] = ta(ht((ie) => V(-999), ["stop", "prevent"]), ["page-up"])),
                  z[3] || (z[3] = ta(ht((ie) => V(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: ht((ie) => N(ie, J), ["stop", "prevent"])
              }), [
                D.titleComponent ? (g(), H(fe(D.titleComponent), { key: 0 })) : (g(), I(me, { key: 1 }, [
                  de(ae(D.title), 1)
                ], 64))
              ], 16, bc)
            ], 2))), 128)),
            O(F.$slots, "tabs-end")
          ], 10, gc)
        ], 2),
        p(s) ? se("", !0) : (g(), H(p(B).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), hc = { id: "__BVID__toaster-container" }, Bc = /* @__PURE__ */ q({
  __name: "BToastOrchestrator",
  props: {
    teleportDisabled: { type: [Boolean, String], default: !1 },
    teleportTo: { default: "body" },
    appendToast: { type: [Boolean, String], default: !1 }
  },
  setup(e, { expose: t }) {
    const o = e, a = d(() => o.teleportDisabled), l = d(() => o.appendToast), n = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, { remove: r, toasts: s, show: i, _setIsAppend: u } = rn();
    ce(
      l,
      (f) => {
        u == null || u(f);
      },
      { immediate: !0 }
    );
    const c = (f) => wa(f, ["_modelValue", "_self", "pos"]);
    return t({
      remove: r,
      show: i,
      toasts: s
    }), (f, b) => (g(), H(_t, {
      to: f.teleportTo,
      disabled: p(a)
    }, [
      le("div", hc, [
        (g(), I(me, null, Ee(n, (m, h) => le("div", {
          key: h,
          class: G([m, "toast-container position-fixed p-3"])
        }, [
          ye(al, { name: "b-list" }, {
            default: R(() => {
              var $;
              return [
                (g(!0), I(me, null, Ee(($ = p(s)) == null ? void 0 : $.filter((B) => B.value.props.pos === h), (B) => (g(), H(fe(B.value.component), ee({
                  key: B.value.props._self
                }, c(B.value.props), {
                  modelValue: B.value.props._modelValue,
                  "onUpdate:modelValue": (v) => B.value.props._modelValue = v,
                  "trans-props": { ...B.value.props.transProps, appear: !0 },
                  onHide: ht((v) => {
                    var S;
                    return (S = p(r)) == null ? void 0 : S(B.value.props._self);
                  }, ["prevent"])
                }), null, 16, ["modelValue", "onUpdate:modelValue", "trans-props", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2)), 64))
      ])
    ], 8, ["to", "disabled"]));
  }
}), Sc = /* @__PURE__ */ q({
  __name: "BTooltip",
  props: {
    interactive: { type: [Boolean, String], default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: [Boolean, String], default: void 0 },
    container: { default: void 0 },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    hide: { type: [Boolean, String], default: void 0 },
    html: { type: [Boolean, String], default: void 0 },
    id: { default: void 0 },
    inline: { type: [Boolean, String], default: void 0 },
    manual: { type: [Boolean, String], default: void 0 },
    modelValue: { type: [Boolean, String], default: void 0 },
    noAutoClose: { type: [Boolean, String], default: void 0 },
    noFade: { type: [Boolean, String], default: void 0 },
    noFlip: { type: [Boolean, String], default: void 0 },
    noHide: { type: [Boolean, String], default: void 0 },
    noShift: { type: [Boolean, String], default: void 0 },
    noSize: { type: [Boolean, String] },
    noninteractive: { type: [Boolean, String], default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: [Boolean, String] },
    realtime: { type: [Boolean, String], default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e, { expose: t }) {
    var n, r, s;
    const o = e, a = w(() => {
      const { interactive: i, noninteractive: u, ...c } = o;
      return { noninteractive: u !== void 0 ? u : !i, ...c };
    }), l = W(null);
    return t({
      hide: (n = l.value) == null ? void 0 : n.hide,
      show: (r = l.value) == null ? void 0 : r.show,
      toggle: (s = l.value) == null ? void 0 : s.toggle
    }), (i, u) => (g(), H(no, ee({
      ref_key: "popover",
      ref: l,
      tooltip: ""
    }, a.value), Ua({ _: 2 }, [
      Ee(i.$slots, (c, f) => ({
        name: f,
        fn: R((b) => [
          O(i.$slots, f, we(Ae(b)))
        ])
      }))
    ]), 1040));
  }
}), Jo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ui,
  BAccordionItem: ci,
  BAlert: vi,
  BAvatar: bi,
  BAvatarGroup: yi,
  BBadge: hi,
  BBreadcrumb: wi,
  BBreadcrumbItem: vn,
  BButton: Bt,
  BButtonGroup: Ci,
  BButtonToolbar: $i,
  BCard: Bn,
  BCardBody: yn,
  BCardFooter: hn,
  BCardGroup: Vi,
  BCardHeader: mn,
  BCardImg: vo,
  BCardSubtitle: bn,
  BCardText: Ai,
  BCardTitle: gn,
  BCarousel: zi,
  BCarouselSlide: Di,
  BCloseButton: jt,
  BCol: Ut,
  BCollapse: fn,
  BContainer: Wi,
  BDropdown: Sn,
  BDropdownDivider: Ki,
  BDropdownForm: Zi,
  BDropdownGroup: eu,
  BDropdownHeader: au,
  BDropdownItem: ou,
  BDropdownItemButton: su,
  BDropdownText: iu,
  BForm: wn,
  BFormCheckbox: kn,
  BFormCheckboxGroup: bu,
  BFormFile: Bu,
  BFormFloatingLabel: fu,
  BFormGroup: Vu,
  BFormInput: Ou,
  BFormInvalidFeedback: xa,
  BFormRadio: Tn,
  BFormRadioGroup: Fu,
  BFormRow: ua,
  BFormSelect: Mu,
  BFormSelectOption: po,
  BFormSelectOptionGroup: _n,
  BFormSpinbutton: Wu,
  BFormTag: Vn,
  BFormTags: sd,
  BFormText: Ma,
  BFormTextarea: id,
  BFormValidFeedback: Da,
  BImg: fo,
  BInputGroup: md,
  BInputGroupAddon: mo,
  BInputGroupAppend: gd,
  BInputGroupPrepend: bd,
  BInputGroupText: An,
  BLink: ft,
  BListGroup: yd,
  BListGroupItem: hd,
  BModal: Ra,
  BModalOrchestrator: Sd,
  BNav: wd,
  BNavForm: kd,
  BNavItem: Td,
  BNavItemDropdown: Vd,
  BNavText: Od,
  BNavbar: Ed,
  BNavbarBrand: Pd,
  BNavbarNav: Nd,
  BNavbarToggle: Dd,
  BOffcanvas: Wd,
  BOverlay: ka,
  BPagination: Ud,
  BPlaceholder: Je,
  BPlaceholderButton: En,
  BPlaceholderCard: Xd,
  BPlaceholderTable: Zd,
  BPlaceholderWrapper: Jd,
  BPopover: no,
  BProgress: dn,
  BProgressBar: un,
  BRow: tc,
  BSpinner: Ca,
  BTab: mc,
  BTable: pc,
  BTableLite: In,
  BTableSimple: go,
  BTabs: yc,
  BTbody: Pn,
  BTd: Ft,
  BTfoot: qa,
  BTh: Wa,
  BThead: Nn,
  BToast: cn,
  BToastOrchestrator: Bc,
  BTooltip: Sc,
  BTr: nt,
  BTransition: Dt
}, Symbol.toStringTag, { value: "Module" })), kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Kl,
  useColorMode: jr,
  useModal: Gr,
  useModalController: ln,
  useScrollspy: sn,
  useToast: rn
}, Symbol.toStringTag, { value: "Module" })), $c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: nl,
  BvEvent: vt,
  BvTriggerableEvent: Vt
}, Symbol.toStringTag, { value: "Module" })), Tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), _c = ({
  components: e = !1,
  directives: t = !1,
  plugins: o = {}
} = {}) => ({
  install(a) {
    const l = typeof e == "boolean" ? { all: e } : e, n = Object.keys(Jo);
    No(l, n).forEach((u) => {
      const c = Jo[u];
      a.component(u, c);
    });
    const r = typeof t == "boolean" ? { all: t } : t, s = Object.keys(Xo), i = (u) => u.toLowerCase().startsWith("v") ? u.slice(1) : u;
    No(r, s).forEach((u) => {
      const c = i(u), f = Xo[u];
      a.directive(c, f);
    }), ((o == null ? void 0 : o.breadcrumb) ?? !0) && a.use(ei), ((o == null ? void 0 : o.modalController) ?? !0) && a.use(ni), ((o == null ? void 0 : o.modalManager) ?? !0) && a.use(si), (((o == null ? void 0 : o.rtl) ?? !0) || typeof o.rtl == "object") && a.use(ri, o), ((o == null ? void 0 : o.toast) ?? !0) && a.use(Qr);
  }
});
export {
  ui as BAccordion,
  ci as BAccordionItem,
  vi as BAlert,
  bi as BAvatar,
  yi as BAvatarGroup,
  hi as BBadge,
  wi as BBreadcrumb,
  vn as BBreadcrumbItem,
  Bt as BButton,
  Ci as BButtonGroup,
  $i as BButtonToolbar,
  Bn as BCard,
  yn as BCardBody,
  hn as BCardFooter,
  Vi as BCardGroup,
  mn as BCardHeader,
  vo as BCardImg,
  bn as BCardSubtitle,
  Ai as BCardText,
  gn as BCardTitle,
  zi as BCarousel,
  Di as BCarouselSlide,
  jt as BCloseButton,
  Ut as BCol,
  fn as BCollapse,
  Wi as BContainer,
  Sn as BDropdown,
  Ki as BDropdownDivider,
  Zi as BDropdownForm,
  eu as BDropdownGroup,
  au as BDropdownHeader,
  ou as BDropdownItem,
  su as BDropdownItemButton,
  iu as BDropdownText,
  wn as BForm,
  kn as BFormCheckbox,
  bu as BFormCheckboxGroup,
  Bu as BFormFile,
  fu as BFormFloatingLabel,
  Vu as BFormGroup,
  Ou as BFormInput,
  xa as BFormInvalidFeedback,
  Tn as BFormRadio,
  Fu as BFormRadioGroup,
  ua as BFormRow,
  Mu as BFormSelect,
  po as BFormSelectOption,
  _n as BFormSelectOptionGroup,
  Wu as BFormSpinbutton,
  Vn as BFormTag,
  sd as BFormTags,
  Ma as BFormText,
  id as BFormTextarea,
  Da as BFormValidFeedback,
  fo as BImg,
  md as BInputGroup,
  mo as BInputGroupAddon,
  gd as BInputGroupAppend,
  bd as BInputGroupPrepend,
  An as BInputGroupText,
  ft as BLink,
  yd as BListGroup,
  hd as BListGroupItem,
  Ra as BModal,
  Sd as BModalOrchestrator,
  wd as BNav,
  kd as BNavForm,
  Td as BNavItem,
  Vd as BNavItemDropdown,
  Od as BNavText,
  Ed as BNavbar,
  Pd as BNavbarBrand,
  Nd as BNavbarNav,
  Dd as BNavbarToggle,
  Wd as BOffcanvas,
  ka as BOverlay,
  Ud as BPagination,
  Je as BPlaceholder,
  En as BPlaceholderButton,
  Xd as BPlaceholderCard,
  Zd as BPlaceholderTable,
  Jd as BPlaceholderWrapper,
  no as BPopover,
  dn as BProgress,
  un as BProgressBar,
  tc as BRow,
  Ca as BSpinner,
  mc as BTab,
  pc as BTable,
  In as BTableLite,
  go as BTableSimple,
  yc as BTabs,
  Pn as BTbody,
  Ft as BTd,
  qa as BTfoot,
  Wa as BTh,
  Nn as BThead,
  cn as BToast,
  Bc as BToastOrchestrator,
  Sc as BTooltip,
  nt as BTr,
  Dt as BTransition,
  nl as BvCarouselEvent,
  vt as BvEvent,
  Vt as BvTriggerableEvent,
  Jo as Components,
  kc as Composables,
  Xo as Directives,
  Tc as Types,
  $c as Utils,
  _c as createBootstrap,
  _c as default,
  Kl as useBreadcrumb,
  jr as useColorMode,
  Gr as useModal,
  ln as useModalController,
  sn as useScrollspy,
  rn as useToast,
  Id as vBColorMode,
  ja as vBModal,
  zd as vBPopover,
  Hd as vBScrollspy,
  ja as vBToggle,
  Rd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
